<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>配置文件指南</title>
      <link href="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/"/>
      <url>/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="配置百科"><a href="#配置百科" class="headerlink" title="配置百科"></a>配置百科</h1><ul><li>nacos 安装指南</li><li>RabbitMQ 安装指南</li><li>ElasticSearch 安装指南</li></ul><h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h2 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h2><p>开发阶段采用单机安装即可。</p><h3 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h3><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402161102887.png" alt="image-20210402161102887"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402161130261.png" alt="image-20210402161130261"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h3 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h3><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h3 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h3><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402162251093.png" alt="image-20210402162251093"></p><h3 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h3><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402162526774.png" alt="image-20210402162526774"></p><h3 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h3><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402162709515.png" alt="image-20210402162709515"></p><h2 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h2><p>Linux或者Mac安装方式与Windows类似。</p><h3 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h3><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402172334810.png" alt="image-20210402172334810"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h3><p>如图：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402161102887.png" alt="image-20210402161102887"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402161130261.png" alt="image-20210402161130261"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402163715580.png" alt="image-20210402163715580"></p><h3 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h3><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402163858429.png" alt="image-20210402163858429"></p><p>目录内部：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210402164414827.png" alt="image-20210402164414827"></p><h3 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h3><p>与windows中类似</p><h3 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h3><p>在nacos&#x2F;bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h2 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h2><p>父工程：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Docker-nacos的配置"><a href="#4-Docker-nacos的配置" class="headerlink" title="4.Docker -nacos的配置"></a>4.Docker -nacos的配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker  run --name nacos -p 8848:8848 \</span><br><span class="line">--privileged=true \</span><br><span class="line">-e JVM_XMS=256m \</span><br><span class="line">-e JVM_XMX=256m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">-e MYSQL_SERVICE_HOST=172.18.0.4 \</span><br><span class="line">-e MYSQL_SERVICE_PORT=3306 \</span><br><span class="line">-e MYSQL_SERVICE_DB_NAME=nacos \</span><br><span class="line">-e MYSQL_SERVICE_USER=root \</span><br><span class="line">-e MYSQL_SERVICE_PASSWORD=jiajun \</span><br><span class="line">--link confident_nobel \</span><br><span class="line">-v /myData/nacos8849/logs:/home/nacos/logs \</span><br><span class="line"></span><br><span class="line">-d nacos/nacos-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#挂载你的nacos配置文件</span><br><span class="line">-v /myData/nacos8849/conf/application.properties:/home/nacos/conf/application.properties \</span><br><span class="line"></span><br><span class="line">#ip 是你的mysql容器的ip（不要写成127.0.0.1）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">-e MYSQL_SERVICE_HOST=172.18.0.5 \</span><br><span class="line">-e MYSQL_SERVICE_PORT=3306 \</span><br><span class="line">-e MYSQL_SERVICE_USER=root \</span><br><span class="line">-e MYSQL_SERVICE_PASSWORD=jiajun \</span><br><span class="line">-e MYSQL_SERVICE_DB_NAME=nacos \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">--restart=always \</span><br><span class="line">--name nacos \</span><br><span class="line">nacos/nacos-server:v2.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询方式：docker inspect mysql | grep IPAddress 查询出来写上去即可</span><br><span class="line"></span><br><span class="line">查询所有容器的ip</span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; $(docker ps -aq)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常见问题</span><br><span class="line">https://wenku.baidu.com/view/50b6ab0ebe64783e0912a21614791711cc79796a.html</span><br><span class="line"></span><br><span class="line">容器互联</span><br><span class="line">https://blog.csdn.net/qq_37451395/article/details/125274071</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="RabbitMQ安装指南"><a href="#RabbitMQ安装指南" class="headerlink" title="RabbitMQ安装指南"></a>RabbitMQ安装指南</h1><h2 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h2><p>我们在Centos7虚拟机中使用Docker来安装。</p><h3 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h3><p>方式一：在线拉取</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>方式二：从本地加载</p><p>在课前资料已经提供了镜像包：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210423191210349.png" alt="image-20210423191210349"> </p><p>上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><h3 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h3><p>执行下面的命令来运行MQ容器：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=panda \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch-安装指南"><a href="#ElasticSearch-安装指南" class="headerlink" title="ElasticSearch 安装指南"></a>ElasticSearch 安装指南</h1><h2 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h2><p><strong>docker pull elasticsearch:7.12.1</strong></p><h2 id="1-1-创建网络"><a href="#1-1-创建网络" class="headerlink" title="1.1.创建网络"></a>1.1.创建网络</h2><p>因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure><h2 id="1-2-加载镜像"><a href="#1-2-加载镜像" class="headerlink" title="1.2.加载镜像"></a>1.2.加载镜像</h2><p>这里我们采用elasticsearch的7.12.1版本的镜像，这个镜像体积非常大，接近1G。不建议大家自己pull。</p><p>课前资料提供了镜像的tar包：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210510165308064.png" alt="image-20210510165308064"></p><p>大家将其上传到虚拟机中，然后运行命令加载即可：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">docker load -i es.tar</span><br></pre></td></tr></table></figure><p>同理还有<code>kibana</code>的tar包也需要这样做。</p><h2 id="1-3-运行"><a href="#1-3-运行" class="headerlink" title="1.3.运行"></a>1.3.运行</h2><p>运行docker命令，部署单点es：</p><p>出现的问题:<a href="https://blog.csdn.net/qq_31920553/article/details/115675409">https://blog.csdn.net/qq_31920553/article/details/115675409</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --name es \</span><br><span class="line">    -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">    -v /usr/local/es/data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v /usr/local/es/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">    -v /usr/local/es/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    --privileged \</span><br><span class="line">    --network docker_elastic \</span><br><span class="line">    -p 9201:9201 \</span><br><span class="line">    -p 9301:9301 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定es的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定es的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定es的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network es-net</code> ：加入一个名为es-net的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://192.168.150.101:9200/">http://192.168.150.101:9200</a> 即可看到elasticsearch的响应结果：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210506101053676.png" alt="image-20210506101053676"></p><h2 id="2-部署kibana"><a href="#2-部署kibana" class="headerlink" title="2.部署kibana"></a>2.部署kibana</h2><p>kibana可以给我们提供一个elasticsearch的可视化界面，便于我们学习。</p><h2 id="2-1-部署"><a href="#2-1-部署" class="headerlink" title="2.1.部署"></a>2.1.部署</h2><p>运行docker命令，部署kibana</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=docker_elastic \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200&quot;</code>：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana启动一般比较慢，需要多等待一会，可以通过命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker logs -f kibana</span><br></pre></td></tr></table></figure><p>查看运行日志，当查看到下面的日志，说明成功：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210109105135812.png" alt="image-20210109105135812"></p><p>此时，在浏览器输入地址访问：<a href="http://192.168.150.101:5601，即可看到结果">http://192.168.150.101:5601，即可看到结果</a></p><h2 id="2-2-DevTools"><a href="#2-2-DevTools" class="headerlink" title="2.2.DevTools"></a>2.2.DevTools</h2><p>kibana中提供了一个DevTools界面：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210506102630393.png" alt="image-20210506102630393"></p><p>这个界面中可以编写DSL来操作elasticsearch。并且对DSL语句有自动补全功能。</p><h2 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h2><h2 id="3-1-在线安装ik插件（较慢，不推荐使用）"><a href="#3-1-在线安装ik插件（较慢，不推荐使用）" class="headerlink" title="3.1.在线安装ik插件（较慢，不推荐使用）"></a>3.1.在线安装ik插件（较慢，不推荐使用）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器内部</span></span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线下载并安装</span></span><br><span class="line">./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h2 id="3-2-离线安装ik插件（推荐）"><a href="#3-2-离线安装ik插件（推荐）" class="headerlink" title="3.2.离线安装ik插件（推荐）"></a>3.2.离线安装ik插件（推荐）</h2><h3 id="1）查看数据卷目录"><a href="#1）查看数据卷目录" class="headerlink" title="1）查看数据卷目录"></a>1）查看数据卷目录</h3><p>安装插件需要知道elasticsearch的plugins目录位置，而我们用了数据卷挂载，因此需要查看elasticsearch的数据卷目录，通过下面命令查看:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect es-plugins</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-05-06T10:06:34+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es-plugins&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Options&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>说明plugins目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code>这个目录中。</p><h3 id="2）解压缩分词器安装包"><a href="#2）解压缩分词器安装包" class="headerlink" title="2）解压缩分词器安装包"></a>2）解压缩分词器安装包</h3><p>下面我们需要把课前资料中的ik分词器解压缩，重命名为ik</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210506110249144.png" alt="image-20210506110249144"></p><h3 id="3）上传到es容器的插件数据卷中"><a href="#3）上传到es容器的插件数据卷中" class="headerlink" title="3）上传到es容器的插件数据卷中"></a>3）上传到es容器的插件数据卷中</h3><p>也就是<code>/var/lib/docker/volumes/es-plugins/_data </code>：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210506110704293.png" alt="image-20210506110704293"></p><h3 id="4）重启容器"><a href="#4）重启容器" class="headerlink" title="4）重启容器"></a>4）重启容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、重启容器</span></span><br><span class="line">docker restart es</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看es日志</span></span><br><span class="line">docker logs -f es</span><br></pre></td></tr></table></figure><h3 id="5）测试："><a href="#5）测试：" class="headerlink" title="5）测试："></a>5）测试：</h3><p>IK分词器包含两种模式：</p><ul><li><p><code>ik_smart</code>：最少切分</p></li><li><p><code>ik_max_word</code>：最细切分</p><p>分布式查询学习:</p></li></ul><p><a href="https://cloud.tencent.com/developer/article/1589499">https://cloud.tencent.com/developer/article/1589499</a></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑马程序员学习java太棒了&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;黑马&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;程序员&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;程序&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;员&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;学习&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;java&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ENGLISH&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;太棒了&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;太棒&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;了&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> <span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> <span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;CN_CHAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span> <span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-扩展词词典"><a href="#3-3-扩展词词典" class="headerlink" title="3.3 扩展词词典"></a>3.3 扩展词词典</h2><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。比如：“奥力给”，“传智播客” 等。</p><p>所以我们的词汇也需要不断的更新，IK分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210506112225508.png" alt="image-20210506112225508"></p><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">传智播客</span></span><br><span class="line"><span class="attr">奥力给</span></span><br></pre></td></tr></table></figure><p>4）重启elasticsearch </p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20201115230900504.png" alt="image-20201115230900504"></p><p>日志中已经成功加载ext.dic配置文件</p><p>5）测试效果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;传智播客Java就业超过90%,奥力给！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p></blockquote><h2 id="3-4-停用词词典"><a href="#3-4-停用词词典" class="headerlink" title="3.4 停用词词典"></a>3.4 停用词词典</h2><p>在互联网项目中，在网络间传输的速度很快，所以很多语言是不允许在网络上传递的，如：关于宗教、政治等敏感词语，那么我们在搜索时也应该忽略当前词汇。</p><p>IK分词器也提供了强大的停用词功能，让我们在索引时就直接忽略当前的停用词汇表中的内容。</p><p>1）IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）在 stopword.dic 添加停用词</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">习大大</span></span><br></pre></td></tr></table></figure><p>4）重启elasticsearch </p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">docker restart elasticsearch</span><br><span class="line">docker restart kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><p>日志中已经成功加载stopword.dic配置文件</p><p>5）测试效果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;传智播客Java就业率超过95%,习大大都点赞,奥力给！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用Windows记事本编辑</p></blockquote><h2 id="4-部署es集群"><a href="#4-部署es集群" class="headerlink" title="4.部署es集群"></a>4.部署es集群</h2><p>我们会在单机上利用docker容器运行多个es实例来模拟es集群。不过生产环境推荐大家每一台服务节点仅部署一个es的实例。<br>下面的教程 是 使用了三个 2g 2 核的 腾讯云服务器搭建的。</p><p><a href="https://www.cnblogs.com/tianyiliang/p/10291305.html">手把手教你搭建一个Elasticsearch集群 - 天意凉 - 博客园 (cnblogs.com)</a></p><h2 id="4-1-创建es集群"><a href="#4-1-创建es集群" class="headerlink" title="4.1.创建es集群"></a>4.1.创建es集群</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先在linux 创建目录和文件 docker/docker.yml</span><br><span class="line">docker.yml</span><br><span class="line">cluster.name: elasticsearch-cluster </span><br><span class="line">#主节点名</span><br><span class="line">        cluster.initial_master_nodes : es-node1</span><br><span class="line">        node.name: es-node1 </span><br><span class="line">        network.bind_host: 0.0.0.0</span><br><span class="line">        #更换为本机地址</span><br><span class="line">        network.publish_host: 47.106.105.52</span><br><span class="line">        http.port: 9200</span><br><span class="line">        transport.tcp.port: 9300</span><br><span class="line">        http.cors.enabled: true </span><br><span class="line">        http.cors.allow-origin: &quot;*&quot; </span><br><span class="line">        node.master: true </span><br><span class="line">        node.data: true  </span><br><span class="line">        # es节点的列表</span><br><span class="line">        discovery.zen.ping.unicast.hosts:  [&quot;47.106.105.52&quot;,&quot;49.234.115.152&quot;,&quot;119.23.230.45&quot;]</span><br><span class="line"></span><br><span class="line">生成es 容器    </span><br><span class="line"></span><br><span class="line">docker run -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; \</span><br><span class="line">-d -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e ES_MIN_MEM=512m \</span><br><span class="line">-e ES_MAX_MEM=512m \</span><br><span class="line">-v /docker/docker.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /docker/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /docker/logs:/usr/share/elasticsearch/logs \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">--name es01 \</span><br><span class="line">elasticsearch:7.12.1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>es运行需要修改一些linux系统权限，修改<code>/etc/sysctl.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>添加下面的内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不改这个会 容器会启动失败</span></span><br><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure><p>然后执行命令，让配置生效：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>通过docker-compose启动集群：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="4-2-集群状态监控"><a href="#4-2-集群状态监控" class="headerlink" title="4.2.集群状态监控"></a>4.2.集群状态监控</h2><p>docker run -d <br>–name cerebro <br>–network&#x3D;docker_elastic <br>-p 9000:9000  \ registry.cn-hangzhou.aliyuncs.com&#x2F;eryajf&#x2F;cerebro</p><p>kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。</p><p>这里推荐使用cerebro来监控es集群状态，官方网址：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a></p><p>解压即可使用，非常方便。</p><p>解压好的目录如下：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602220824668.png" alt="image-20210602220824668"></p><p>进入对应的bin目录：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602220846137.png" alt="image-20210602220846137"></p><p>双击其中的cerebro.bat文件即可启动服务。</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602220941101.png" alt="image-20210602220941101"></p><p>访问<a href="http://localhost:9000/">http://localhost:9000</a> 即可进入管理界面：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602221115763.png" alt="image-20210602221115763"></p><p>输入你的elasticsearch的任意节点的地址和端口，点击connect即可：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210109181106866.png" alt="image-20210109181106866"></p><p>绿色的条，代表集群处于绿色（健康状态）。</p><h2 id="4-3-创建索引库"><a href="#4-3-创建索引库" class="headerlink" title="4.3.创建索引库"></a>4.3.创建索引库</h2><h3 id="1）利用kibana的DevTools创建索引库"><a href="#1）利用kibana的DevTools创建索引库" class="headerlink" title="1）利用kibana的DevTools创建索引库"></a>1）利用kibana的DevTools创建索引库</h3><p>在DevTools中输入指令：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /itcast</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number_of_shards&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="comment">// 分片数量</span></span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="comment">// 副本数量</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// mapping映射定义 ...</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2）利用cerebro创建索引库"><a href="#2）利用cerebro创建索引库" class="headerlink" title="2）利用cerebro创建索引库"></a>2）利用cerebro创建索引库</h3><p>利用cerebro还可以创建索引库：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602221409524.png" alt="image-20210602221409524"></p><p>填写索引库信息：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602221520629.png" alt="image-20210602221520629"></p><p>点击右下角的create按钮：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602221542745.png" alt="image-20210602221542745"></p><h2 id="4-4-查看分片效果"><a href="#4-4-查看分片效果" class="headerlink" title="4.4.查看分片效果"></a>4.4.查看分片效果</h2><p>回到首页，即可查看索引库分片效果：</p><p><img src="/2022/09/29/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%8D%97/image-20210602221914483.png" alt="image-20210602221914483"></p><p>关于es 配置文件参数的介绍可参考</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.1 集群配置参数</span><br><span class="line">一个集群名称，在该集群下的所有节点都会自动分配数据共享数据，达到负载均分的作用，重要</span><br><span class="line"></span><br><span class="line">cluster.name: &quot;docker-cluster&quot;</span><br><span class="line"></span><br><span class="line">2.2节点配置参数</span><br><span class="line">每一个节点都有自己的一个名称，仅此而已</span><br><span class="line"></span><br><span class="line">node.name: &quot;Franz Kafka&quot;</span><br><span class="line"></span><br><span class="line">2.3主从配置参数</span><br><span class="line">允许一个节点是否可以成为一个master节点,es是默认集群中的第一台机器为master,如果这台机器停止就会重新选举master.</span><br><span class="line"></span><br><span class="line">node.master: true</span><br><span class="line"></span><br><span class="line">允许该节点存储数据(默认开启)</span><br><span class="line"></span><br><span class="line">node.data: true</span><br><span class="line"></span><br><span class="line">配置文件中给出了三种配置高性能集群拓扑结构的模式,如下：</span><br><span class="line"></span><br><span class="line">1. 如果你想让节点从不选举为主节点,只用来存储数据,可作为负载器</span><br><span class="line"></span><br><span class="line">node.master: false</span><br><span class="line"></span><br><span class="line">node.data: true</span><br><span class="line"></span><br><span class="line">2. 如果想让节点成为主节点,且不存储任何数据,并保有空闲资源,可作为协调器</span><br><span class="line"></span><br><span class="line">node.master: true</span><br><span class="line"></span><br><span class="line"> node.data: false</span><br><span class="line"></span><br><span class="line">3. 如果想让节点既不称为主节点,又不成为数据节点,那么可将他作为搜索器,从节点 中获取数据,生成搜索结果等</span><br><span class="line"></span><br><span class="line">node.master: false</span><br><span class="line"></span><br><span class="line">node.data: false</span><br><span class="line"></span><br><span class="line">2.4索引配置参数</span><br><span class="line">设置索引的分片数,默认为5，每个节点都可以进行分片，将数据平均分配，达到负载均衡作用，是在创建索引生成后续不能修改</span><br><span class="line"></span><br><span class="line">index.number_of_shards: 5</span><br><span class="line"></span><br><span class="line">设置索引的副本数,默认为1，每个分片都会为其创建一个副本，用来作为备份，也可以起到查询作用，提高性能，后续可以修改</span><br><span class="line"></span><br><span class="line">index.number_of_replicas: 1</span><br><span class="line"></span><br><span class="line">2.5路径配置参数</span><br><span class="line">配置文件存储位置</span><br><span class="line"></span><br><span class="line">path.conf: /path/to/conf</span><br><span class="line"></span><br><span class="line">数据存储位置(所有数据都存在这一个目录下)</span><br><span class="line"></span><br><span class="line">path.data: /path/to/data</span><br><span class="line"></span><br><span class="line">多个数据存储位置,有利于性能提升（将所有数据分别存在不同目录下）</span><br><span class="line"></span><br><span class="line">path.data: /path/to/data1,/path/to/data2</span><br><span class="line"></span><br><span class="line">临时文件的路径</span><br><span class="line"></span><br><span class="line">path.work: /path/to/work</span><br><span class="line"></span><br><span class="line">日志文件的路径</span><br><span class="line"></span><br><span class="line">path.logs: /path/to/logs</span><br><span class="line"></span><br><span class="line">插件安装路径</span><br><span class="line"></span><br><span class="line">path.plugins: /path/to/plugins</span><br><span class="line"></span><br><span class="line">2.6内存配置参数</span><br><span class="line">当JVM开始写入交换空间时（swapping）ElasticSearch性能会低下,你应该保证它不会写入交换空间，设置这个属性为true来锁定内存,同时也要允许elasticsearch的进程可以锁住内存,</span><br><span class="line"></span><br><span class="line">bootstrap.mlockall: true</span><br><span class="line"></span><br><span class="line">2.7网络配置参数</span><br><span class="line">设置绑定的ip地址,可以是ipv4或ipv6的,默认为0.0.0.0</span><br><span class="line"></span><br><span class="line">network.bind_host: 192.168.0.1</span><br><span class="line"></span><br><span class="line">设置其它节点和该节点交互的ip地址,如果不设置它会自动设置,值必须是个真实的ip地址</span><br><span class="line"></span><br><span class="line">network.publish_host: 192.168.0.1</span><br><span class="line"></span><br><span class="line">同时设置bind_host和publish_host上面两个参数</span><br><span class="line"></span><br><span class="line">network.host: 192.168.0.1</span><br><span class="line"></span><br><span class="line">设置节点间交互的tcp端口,默认是9300</span><br><span class="line"></span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"></span><br><span class="line">设置是否压缩tcp传输时的数据，默认为false,不压缩</span><br><span class="line"></span><br><span class="line">transport.tcp.compress: true</span><br><span class="line"></span><br><span class="line">设置对外服务的http端口,默认为9200</span><br><span class="line"></span><br><span class="line">http.port: 9200</span><br><span class="line"></span><br><span class="line">设置请求内容的最大容量,默认100mb</span><br><span class="line"></span><br><span class="line">http.max_content_length: 100mb</span><br><span class="line"></span><br><span class="line">使用http协议对外提供服务,默认为true,开启</span><br><span class="line"></span><br><span class="line">http.enabled: false</span><br><span class="line"></span><br><span class="line">2.8网关配置参数</span><br><span class="line">gateway的类型,默认为local即为本地文件系统,可以设置为本地文件系统</span><br><span class="line"></span><br><span class="line">gateway.type: local</span><br><span class="line"></span><br><span class="line">下面的配置控制怎样以及何时启动一整个集群重启的初始化恢复过程(当使用shard gateway时,是为了尽可能的重用local data(本地数据))一个集群中的N个节点启动后,才允许进行恢复处理</span><br><span class="line"></span><br><span class="line">gateway.recover_after_nodes: 1</span><br><span class="line"></span><br><span class="line">设置初始化恢复过程的超时时间,超时时间从上一个配置中配置的N个节点启动后算起</span><br><span class="line"></span><br><span class="line">gateway.recover_after_time: 5m</span><br><span class="line"></span><br><span class="line">设置这个集群中期望有多少个节点.一旦这N个节点启动(并且recover_after_nodes也符合),立即开始恢复过程(不等待recover_after_time超时)</span><br><span class="line"></span><br><span class="line">gateway.expected_nodes: 2</span><br><span class="line"></span><br><span class="line">2.9集群发现配置参数</span><br><span class="line">设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点.默认为1,对于大的集群来说,可以设置大一点的值(2-4)</span><br><span class="line"></span><br><span class="line">discovery.zen.minimum_master_nodes: 1</span><br><span class="line"></span><br><span class="line">探查的超时时间,默认3秒,提高一点以应对网络不好的时候,防止脑裂</span><br><span class="line"></span><br><span class="line">discovery.zen.ping.timeout: 3s</span><br><span class="line"></span><br><span class="line">当多播不可用或者集群跨网段的时候集群通信还是用单播吧</span><br><span class="line"></span><br><span class="line">discovery.zen.ping.multicast.enabled: false</span><br><span class="line"></span><br><span class="line">这是一个集群中的主节点的初始列表,当节点(主节点或者数据节点)启动时使用这个列表进行探测</span><br><span class="line"></span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务保护</title>
      <link href="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/"/>
      <url>/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h1><h1 id="1-初识Sentinel"><a href="#1-初识Sentinel" class="headerlink" title="1.初识Sentinel"></a>1.初识Sentinel</h1><h2 id="1-1-雪崩问题及解决方案"><a href="#1-1-雪崩问题及解决方案" class="headerlink" title="1.1.雪崩问题及解决方案"></a>1.1.雪崩问题及解决方案</h2><h3 id="1-1-1-雪崩问题"><a href="#1-1-1-雪崩问题" class="headerlink" title="1.1.1.雪崩问题"></a>1.1.1.雪崩问题</h3><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p><p> <img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/1533829099748.png" alt="1533829099748"></p><p>如图，如果服务提供者I发生了故障，当前的应用的部分业务因为依赖于服务I，因此也会被阻塞。此时，其它不依赖于服务I的业务似乎不受影响。</p><p> <img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/1533829198240.png" alt="1533829198240"></p><p>但是，依赖服务I的业务请求被阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p><p> <img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/1533829307389.png" alt="1533829307389"></p><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。</p><p>那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715172710340.png" alt="image-20210715172710340"></p><h3 id="1-1-2-超时处理"><a href="#1-1-2-超时处理" class="headerlink" title="1.1.2.超时处理"></a>1.1.2.超时处理</h3><p>解决雪崩问题的常见方式有四种：</p><p>•超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715172820438.png" alt="image-20210715172820438"></p><h3 id="1-1-3-仓壁模式"><a href="#1-1-3-仓壁模式" class="headerlink" title="1.1.3.仓壁模式"></a>1.1.3.仓壁模式</h3><p>方案2：仓壁模式</p><p>仓壁模式来源于船舱的设计：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715172946352.png" alt="image-20210715172946352"></p><p>船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。</p><p>于此类似，我们可以限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，因此也叫线程隔离。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715173215243.png" alt="image-20210715173215243"></p><h3 id="1-1-4-断路器"><a href="#1-1-4-断路器" class="headerlink" title="1.1.4.断路器"></a>1.1.4.断路器</h3><p>断路器模式：由<strong>断路器</strong>统计业务执行的异常比例，如果超出阈值则会<strong>熔断</strong>该业务，拦截访问该业务的一切请求。</p><p>断路器会统计访问某个服务的请求数量，异常比例：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715173327075.png" alt="image-20210715173327075"></p><p>当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715173428073.png" alt="image-20210715173428073"></p><h3 id="1-1-5-限流"><a href="#1-1-5-限流" class="headerlink" title="1.1.5.限流"></a>1.1.5.限流</h3><p><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715173555158.png" alt="image-20210715173555158"></p><h3 id="1-1-6-总结"><a href="#1-1-6-总结" class="headerlink" title="1.1.6.总结"></a>1.1.6.总结</h3><p>什么是雪崩问题？</p><ul><li>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</li></ul><p>可以认为：</p><p><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</p><p><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</p><h2 id="1-2-服务保护技术对比"><a href="#1-2-服务保护技术对比" class="headerlink" title="1.2.服务保护技术对比"></a>1.2.服务保护技术对比</h2><p>在SpringCloud当中支持多种服务保护技术：</p><ul><li><a href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></li><li><a href="https://github.com/alibaba/Sentinel">Sentinel</a></li><li><a href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li></ul><p>早期比较流行的是Hystrix框架，但目前国内实用最广泛的还是阿里巴巴的Sentinel框架，这里我们做下对比：</p><table><thead><tr><th></th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离&#x2F;信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h2 id="1-3-Sentinel介绍和安装"><a href="#1-3-Sentinel介绍和安装" class="headerlink" title="1.3.Sentinel介绍和安装"></a>1.3.Sentinel介绍和安装</h2><h3 id="1-3-1-初识Sentinel"><a href="#1-3-1-初识Sentinel" class="headerlink" title="1.3.1.初识Sentinel"></a>1.3.1.初识Sentinel</h3><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p><p>Sentinel 具有以下特征:</p><p>•<strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p><p>•<strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p><p>•<strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p><p>•<strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><h3 id="1-3-2-安装Sentinel"><a href="#1-3-2-安装Sentinel" class="headerlink" title="1.3.2.安装Sentinel"></a>1.3.2.安装Sentinel</h3><p>1）下载</p><p>sentinel官方提供了UI控制台，方便我们对系统做限流设置。大家可以在<a href="https://github.com/alibaba/Sentinel/releases">GitHub</a>下载。</p><p>课前资料也提供了下载好的jar包：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715174252531.png" alt="image-20210715174252531"></p><p>2）运行</p><p>将jar包放到任意非中文目录，执行命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure><p>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>例如，修改端口：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">java -jar sentinel-dashboard-1.8.1.jar --server.port=8090</span><br></pre></td></tr></table></figure><p>3）访问</p><p>访问<a href="http://localhost:8080页面，就可以看到sentinel的控制台了：">http://localhost:8080页面，就可以看到sentinel的控制台了：</a></p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715190827846.png" alt="image-20210715190827846"></p><p>需要输入账号和密码，默认都是：sentinel</p><p>登录后，发现一片空白，什么都没有：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715191134448.png" alt="image-20210715191134448"></p><p>这是因为我们还没有与微服务整合。</p><h2 id="1-4-微服务整合Sentinel"><a href="#1-4-微服务整合Sentinel" class="headerlink" title="1.4.微服务整合Sentinel"></a>1.4.微服务整合Sentinel</h2><p>我们在order-service中整合sentinel，并连接sentinel的控制台，步骤如下：</p><p>1）引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改application.yaml文件，添加下面内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8088</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br></pre></td></tr></table></figure><p>3）访问order-service的任意端点</p><p>打开浏览器，访问<a href="http://localhost:8088/order/101%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A6%E5%8F%91sentinel%E7%9A%84%E7%9B%91%E6%8E%A7%E3%80%82">http://localhost:8088/order/101，这样才能触发sentinel的监控。</a></p><p>然后再访问sentinel的控制台，查看效果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715191241799.png" alt="image-20210715191241799"></p><h1 id="2-流量控制"><a href="#2-流量控制" class="headerlink" title="2.流量控制"></a>2.流量控制</h1><p>雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。</p><h2 id="2-1-簇点链路"><a href="#2-1-簇点链路" class="headerlink" title="2.1.簇点链路"></a>2.1.簇点链路</h2><p>当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做<strong>簇点链路</strong>。簇点链路中被监控的每一个接口就是一个<strong>资源</strong>。</p><p>默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>EndPoint 其作用就是监控应用,以及跟应用之间的交互:</p><ul><li>Health EndPoint 应用的健康检查 ,  HttpTrace EndPoint Http历史链路</li><li>Loggers EndPoint 动态改变应用的日志级别。</li></ul><p> Springboot ,Spring cloud提供了一些常用的EndPoint:</p><table><thead><tr><th><strong>EndPointID</strong></th><th><strong>描述</strong></th><th><strong>默认是否1开启</strong></th></tr></thead><tbody><tr><td>beans</td><td>显示SpringApplication Context 所有的ban</td><td>默认开启</td></tr><tr><td>conditions</td><td>显示条件注解是否满足条件的匹配信息</td><td>默认开启</td></tr><tr><td>configprops</td><td>显示所有ConfigurationProperties 对应的配置信息</td><td>默认开启</td></tr><tr><td>env</td><td>Spring平EZ之信息,可以看到加载哪些PropertySource</td><td>默认开启</td></tr><tr><td>health</td><td>显示应用健康信息</td><td>默认开启</td></tr><tr><td>httptrace</td><td>显示Http链路信息</td><td>默认开启,需要一个HttpTraceRepository bean</td></tr><tr><td>info</td><td>显示应用基本信息</td><td>默认开启</td></tr><tr><td>loggers</td><td>显示或修改应用的日志配置</td><td>默认开启</td></tr><tr><td>mapper</td><td>显示@RequestMapping的映射信息</td><td>默认开启</td></tr><tr><td>shutdown</td><td>可以让应用关闭</td><td>默认关闭</td></tr><tr><td>features</td><td>显示SpringCloud 提供的 feature 列表</td><td>默认关闭</td></tr><tr><td>service-registry</td><td>显示or 修改服务实例的状态</td><td>默认关闭</td></tr></tbody></table><p>例如，我们刚才访问的order-service中的OrderController中的端点：&#x2F;order&#x2F;{orderId}</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715191757319.png" alt="image-20210715191757319"></p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><ul><li>流控：流量控制</li><li>降级：降级熔断</li><li>热点：热点参数限流，是限流的一种</li><li>授权：请求的权限控制</li></ul><h2 id="2-1-快速入门"><a href="#2-1-快速入门" class="headerlink" title="2.1.快速入门"></a>2.1.快速入门</h2><h3 id="2-1-1-示例"><a href="#2-1-1-示例" class="headerlink" title="2.1.1.示例"></a>2.1.1.示例</h3><p>点击资源&#x2F;order&#x2F;{orderId}后面的流控按钮，就可以弹出表单。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715191757319.png" alt="image-20210715191757319"></p><p>表单中可以填写限流规则，如下：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715192010657.png" alt="image-20210715192010657"></p><p>其含义是限制 &#x2F;order&#x2F;{orderId}这个资源的单机QPS为1，即每秒只允许1次请求，超出的请求会被拦截并报错。</p><blockquote><p>QPS（Queries-per-second）即每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准；在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量<br> QPS &#x3D; 流量请求数 &#x2F; 规定时间</p></blockquote><h3 id="2-1-2-练习："><a href="#2-1-2-练习：" class="headerlink" title="2.1.2.练习："></a>2.1.2.练习：</h3><p>需求：给 &#x2F;order&#x2F;{orderId}这个资源设置流控规则，QPS不能超过 5，即在规定时间处理的最大请求数为5。<br>如果超过5，则请求失败，或等待其他请求结束后继续。</p><p>1）首先在sentinel控制台添加限流规则</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715192455429.png" alt="image-20210715192455429"></p><p>2）利用jmeter测试</p><p>如果没有用过jmeter，可以参考课前资料提供的文档《Jmeter快速入门.md》</p><p>课前资料提供了编写好的Jmeter测试样例：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715200431615.png" alt="image-20210715200431615"></p><p>打开jmeter，导入课前资料提供的测试样例：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715200537171.png" alt="image-20210715200537171"></p><p>选择：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715200635414.png" alt="image-20210715200635414"></p><p>20个用户，2秒内运行完，QPS是10，超过了5.</p><p>选中<code>流控入门，QPS&lt;5</code>右键运行：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715200804594.png" alt="image-20210715200804594"></p><blockquote><p>注意，不要点击菜单中的执行按钮来运行。</p></blockquote><p>结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715200853671.png" alt="image-20210715200853671"></p><p>可以看到，成功的请求每次只有5个</p><h2 id="2-2-流控模式"><a href="#2-2-流控模式" class="headerlink" title="2.2.流控模式"></a>2.2.流控模式</h2><p>在添加限流规则时，点击高级选项，可以选择三种<strong>流控模式</strong>：</p><ul><li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</li><li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li><li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</li></ul><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715201827886.png" alt="image-20210715201827886"></p><p>快速入门测试的就是直接模式。</p><h3 id="2-2-1-关联模式"><a href="#2-2-1-关联模式" class="headerlink" title="2.2.1.关联模式"></a>2.2.1.关联模式</h3><p><strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p><strong>配置规则</strong>：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715202540786.png" alt="image-20210715202540786"></p><p><strong>语法说明</strong>：当&#x2F;write资源访问量触发阈值时，就会对&#x2F;read资源限流，避免影响&#x2F;write资源。</p><p><strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p><p><strong>需求说明</strong>：</p><ul><li><p>在OrderController新建两个端点：&#x2F;order&#x2F;query和&#x2F;order&#x2F;update，无需实现业务</p></li><li><p>配置流控规则，当&#x2F;order&#x2F; update资源被访问的QPS超过5时，对&#x2F;order&#x2F;query请求限流</p></li></ul><p>1）定义&#x2F;order&#x2F;query端点，模拟订单查询</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义&#x2F;order&#x2F;update端点，模拟订单更新</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;更新订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，查看sentinel控制台的簇点链路：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716101805951.png" alt="image-20210716101805951"></p><p>3）配置流控规则</p><p>对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询&#x2F;order&#x2F;query限流，因此点击它后面的按钮：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716101934499.png" alt="image-20210716101934499"></p><p>在表单中填写流控规则：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716102103814.png" alt="image-20210716102103814"></p><p>4）在Jmeter测试</p><p>选择《流控模式-关联》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716102416266.png" alt="image-20210716102416266"></p><p>可以看到1000个用户，100秒，因此QPS为10，超过了我们设定的阈值：5</p><p>查看http请求：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716102532554.png" alt="image-20210716102532554"></p><p>请求的目标是&#x2F;order&#x2F;update，这样这个断点就会触发阈值。</p><p>但限流的目标是&#x2F;order&#x2F;query，我们在浏览器访问，可以发现：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716102636030.png" alt="image-20210716102636030"></p><p>确实被限流了。</p><p>5）总结</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716103143002.png" alt="image-20210716103143002"></p><h3 id="2-2-2-链路模式"><a href="#2-2-2-链路模式" class="headerlink" title="2.2.2.链路模式"></a>2.2.2.链路模式</h3><p><strong>链路模式</strong>：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p><p><strong>配置示例</strong>：</p><p>例如有两条请求链路：</p><ul><li><p>&#x2F;test1 –&gt; &#x2F;common</p></li><li><p>&#x2F;test2 –&gt; &#x2F;common</p></li></ul><p>如果只希望统计从&#x2F;test2进入到&#x2F;common的请求，则可以这样配置：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716103536346.png" alt="image-20210716103536346"></p><p><strong>实战案例</strong></p><p>需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p><p>步骤：</p><ol><li><p>在OrderService中添加一个queryGoods方法，不用实现业务</p></li><li><p>在OrderController中，改造&#x2F;order&#x2F;query端点，调用OrderService中的queryGoods方法</p></li><li><p>在OrderController中添加一个&#x2F;order&#x2F;save的端点，调用OrderService的queryGoods方法</p></li><li><p>给queryGoods设置限流规则，从&#x2F;order&#x2F;query进入queryGoods的方法限制QPS必须小于2</p></li></ol><p>实现：</p><h4 id="1）添加查询商品方法"><a href="#1）添加查询商品方法" class="headerlink" title="1）添加查询商品方法"></a>1）添加查询商品方法</h4><p>在order-service服务中，给OrderService类添加一个queryGoods方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）查询订单时，查询商品"><a href="#2）查询订单时，查询商品" class="headerlink" title="2）查询订单时，查询商品"></a>2）查询订单时，查询商品</h4><p>在order-service的OrderController中，修改&#x2F;order&#x2F;query端点的业务逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）新增订单，查询商品"><a href="#3）新增订单，查询商品" class="headerlink" title="3）新增订单，查询商品"></a>3）新增订单，查询商品</h4><p>在order-service的OrderController中，修改&#x2F;order&#x2F;save端点，模拟新增订单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.err.println(<span class="string">&quot;新增订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;新增订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）给查询商品添加资源标记"><a href="#4）给查询商品添加资源标记" class="headerlink" title="4）给查询商品添加资源标记"></a>4）给查询商品添加资源标记</h4><p>默认情况下，OrderService中的方法是不被Sentinel监控的，需要我们自己通过注解来标记要监控的方法。</p><p>给OrderService的queryGoods方法添加@SentinelResource注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入SpringMVC的所有请求设置同一个root资源，会导致链路模式失效。</p><p>我们需要关闭这种对SpringMVC的资源聚合，修改order-service服务的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure><p>重启服务，访问&#x2F;order&#x2F;query和&#x2F;order&#x2F;save，可以查看到sentinel的簇点链路规则中，出现了新的资源：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716105227163.png" alt="image-20210716105227163"></p><h4 id="5）添加流控规则"><a href="#5）添加流控规则" class="headerlink" title="5）添加流控规则"></a>5）添加流控规则</h4><p>点击goods资源后面的流控按钮，在弹出的表单中填写下面信息：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716105408723.png" alt="image-20210716105408723"></p><p>只统计从&#x2F;order&#x2F;query进入&#x2F;goods的资源，QPS阈值为2，超出则被限流。</p><h4 id="6）Jmeter测试"><a href="#6）Jmeter测试" class="headerlink" title="6）Jmeter测试"></a>6）Jmeter测试</h4><p>选择《流控模式-链路》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716105612312.png" alt="image-20210716105612312"></p><p>可以看到这里200个用户，50秒内发完，QPS为4，超过了我们设定的阈值2</p><p>一个http请求是访问&#x2F;order&#x2F;save：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716105812789.png" alt="image-20210716105812789"></p><p>运行的结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716110027064.png" alt="image-20210716110027064"></p><p>完全不受影响。</p><p>另一个是访问&#x2F;order&#x2F;query：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716105855951.png" alt="image-20210716105855951"></p><p>运行结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716105956401.png" alt="image-20210716105956401"></p><p>每次只有2个通过。</p><h3 id="2-2-3-总结"><a href="#2-2-3-总结" class="headerlink" title="2.2.3.总结"></a>2.2.3.总结</h3><p>流控模式有哪些？</p><p>•直接：对当前资源限流</p><p>•关联：高优先级资源触发阈值，对低优先级资源限流。</p><p>•链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</p><h2 id="2-3-流控效果"><a href="#2-3-流控效果" class="headerlink" title="2.3.流控效果"></a>2.3.流控效果</h2><p>在流控的高级选项中，还有一个流控效果选项：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716110225104.png" alt="image-20210716110225104"></p><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p><ul><li><p>快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。</p></li><li><p>warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p></li><li><p>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p></li></ul><h3 id="2-3-1-warm-up"><a href="#2-3-1-warm-up" class="headerlink" title="2.3.1.warm up"></a>2.3.1.warm up</h3><p>阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（<strong>冷启动</strong>），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。</p><p>warm up也叫<strong>预热模式</strong>，是应对服务冷启动的一种方案。请求阈值初始值是 maxThreshold &#x2F; coldFactor，持续指定时长后，逐渐提高到maxThreshold值。而coldFactor的默认值是3.</p><p>例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 &#x2F; 3 ，也就是3，然后在5秒后逐渐增长到10.</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716110629796.png" alt="image-20210716110629796"></p><p><strong>案例</strong></p><p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒</p><h4 id="1）配置流控规则："><a href="#1）配置流控规则：" class="headerlink" title="1）配置流控规则："></a>1）配置流控规则：</h4><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716111012387.png" alt="image-20210716111012387"></p><h4 id="2）Jmeter测试"><a href="#2）Jmeter测试" class="headerlink" title="2）Jmeter测试"></a>2）Jmeter测试</h4><p>选择《流控效果，warm up》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716111136699.png" alt="image-20210716111136699"></p><p>QPS为10.</p><p>刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716111303701.png" alt="image-20210716111303701"></p><p>随着时间推移，成功比例越来越高：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716111404717.png" alt="image-20210716111404717"></p><p>到Sentinel控制台查看实时监控：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716111526480.png" alt="image-20210716111526480"></p><p>一段时间后：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716111658541.png" alt="image-20210716111658541"></p><h3 id="2-3-2-排队等待"><a href="#2-3-2-排队等待" class="headerlink" title="2.3.2.排队等待"></a>2.3.2.排队等待</h3><p>当请求超过QPS阈值时，快速失败和warm up 会拒绝新的请求并抛出异常。</p><p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>工作原理</p><p>例如：QPS &#x3D; 5，意味着每200ms处理一个队列中的请求；timeout &#x3D; 2000，意味着<strong>预期等待时长</strong>超过2000ms的请求会被拒绝并抛出异常。</p><p>那什么叫做预期等待时长呢？</p><p>比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么：</p><ul><li>第6个请求的<strong>预期等待时长</strong> &#x3D;  200 * （6 - 1） &#x3D; 1000ms</li><li>第12个请求的预期等待时长 &#x3D; 200 * （12-1） &#x3D; 2200ms</li></ul><p>现在，第1秒同时接收到10个请求，但第2秒只有1个请求，此时QPS的曲线这样的：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716113147176.png" alt="image-20210716113147176"></p><p>如果使用队列模式做流控，所有进入的请求都要排队，以固定的200ms的间隔执行，QPS会变的很平滑：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716113426524.png" alt="image-20210716113426524"></p><p>平滑的QPS曲线，对于服务器来说是更友好的。</p><p><strong>案例</strong></p><p>需求：给&#x2F;order&#x2F;{orderId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s</p><h4 id="1）添加流控规则"><a href="#1）添加流控规则" class="headerlink" title="1）添加流控规则"></a>1）添加流控规则</h4><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716114048918.png" alt="image-20210716114048918"></p><h4 id="2）Jmeter测试-1"><a href="#2）Jmeter测试-1" class="headerlink" title="2）Jmeter测试"></a>2）Jmeter测试</h4><p>选择《流控效果，队列》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716114243558.png" alt="image-20210716114243558"></p><p>QPS为15，已经超过了我们设定的10。</p><p>如果是之前的 快速失败、warmup模式，超出的请求应该会直接报错。</p><p>但是我们看看队列模式的运行结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716114429361.png" alt="image-20210716114429361"></p><p>全部都通过了。</p><p>再去sentinel查看实时监控的QPS曲线：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716114522935.png" alt="image-20210716114522935"></p><p>QPS非常平滑，一致保持在10，但是超出的请求没有被拒绝，而是放入队列。因此<strong>响应时间</strong>（等待时间）会越来越长。</p><p>当队列满了以后，才会有部分请求失败：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716114651137.png" alt="image-20210716114651137"></p><h3 id="2-3-3-总结"><a href="#2-3-3-总结" class="headerlink" title="2.3.3.总结"></a>2.3.3.总结</h3><p>流控效果有哪些？</p><ul><li><p>快速失败：QPS超过阈值时，拒绝新的请求</p></li><li><p>warm up： QPS超过阈值时，拒绝新的请求；QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。</p></li><li><p>排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝</p></li></ul><h2 id="2-4-热点参数限流"><a href="#2-4-热点参数限流" class="headerlink" title="2.4.热点参数限流"></a>2.4.热点参数限流</h2><p>之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是<strong>分别统计参数值相同的请求</strong>，判断是否超过QPS阈值。</p><h3 id="2-4-1-全局参数限流"><a href="#2-4-1-全局参数限流" class="headerlink" title="2.4.1.全局参数限流"></a>2.4.1.全局参数限流</h3><p>例如，一个根据id查询商品的接口：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716115014663.png" alt="image-20210716115014663"></p><p>访问&#x2F;goods&#x2F;{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716115131463.png" alt="image-20210716115131463"></p><p>当id&#x3D;1的请求触发阈值被限流时，id值不为1的请求不受影响。</p><p>配置示例：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716115232426.png" alt="image-20210716115232426"></p><p>代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒<strong>相同参数值</strong>的请求数不能超过5</p><h3 id="2-4-2-热点参数限流"><a href="#2-4-2-热点参数限流" class="headerlink" title="2.4.2.热点参数限流"></a>2.4.2.热点参数限流</h3><p>刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS都限定为5.</p><p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716115717523.png" alt="image-20210716115717523"></p><p>结合上一个配置，这里的含义是对0号的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：</p><p>•如果参数值是100，则每1秒允许的QPS为10</p><p>•如果参数值是101，则每1秒允许的QPS为15</p><h3 id="2-4-4-案例"><a href="#2-4-4-案例" class="headerlink" title="2.4.4.案例"></a>2.4.4.案例</h3><p><strong>案例需求</strong>：给&#x2F;order&#x2F;{orderId}这个资源添加热点参数限流，规则如下：</p><p>•默认的热点参数规则是每1秒请求量不超过2</p><p>•给102这个参数设置例外：每1秒请求量不超过4</p><p>•给103这个参数设置例外：每1秒请求量不超过10</p><p><strong>注意事项</strong>：热点参数限流对默认的SpringMVC资源无效，需要利用@SentinelResource注解标记资源</p><h4 id="1）标记资源"><a href="#1）标记资源" class="headerlink" title="1）标记资源"></a>1）标记资源</h4><p>给order-service中的OrderController中的&#x2F;order&#x2F;{orderId}资源添加注解：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120033572.png" alt="image-20210716120033572"></p><h4 id="2）热点参数限流规则"><a href="#2）热点参数限流规则" class="headerlink" title="2）热点参数限流规则"></a>2）热点参数限流规则</h4><p>访问该接口，可以看到我们标记的hot资源出现了：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120208509.png" alt="image-20210716120208509"></p><p>这里不要点击hot后面的按钮，页面有BUG</p><p>点击左侧菜单中<strong>热点规则</strong>菜单：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120319009.png" alt="image-20210716120319009"></p><p>点击新增，填写表单：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120536714.png" alt="image-20210716120536714"></p><h4 id="3）Jmeter测试"><a href="#3）Jmeter测试" class="headerlink" title="3）Jmeter测试"></a>3）Jmeter测试</h4><p>选择《热点参数限流 QPS1》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120754527.png" alt="image-20210716120754527"></p><p>这里发起请求的QPS为5.</p><p>包含3个http请求：</p><p>普通参数，QPS阈值为2</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120840501.png" alt="image-20210716120840501"></p><p>运行结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716121105567.png" alt="image-20210716121105567"></p><p>例外项，QPS阈值为4</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120900365.png" alt="image-20210716120900365"></p><p>运行结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716121201630.png" alt="image-20210716121201630"></p><p>例外项，QPS阈值为10</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716120919131.png" alt="image-20210716120919131"></p><p>运行结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716121220305.png" alt="image-20210716121220305"></p><h1 id="3-隔离和降级"><a href="#3-隔离和降级" class="headerlink" title="3.隔离和降级"></a>3.隔离和降级</h1><p>限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p><p>而要将这些故障控制在一定范围，避免雪崩，就要靠<strong>线程隔离</strong>（舱壁模式）和<strong>熔断降级</strong>手段了。</p><p><strong>线程隔离</strong>之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715173215243.png" alt="image-20210715173215243"></p><p><strong>熔断降级</strong>：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210715173428073.png" alt="image-20210715173428073"></p><p>可以看到，不管是线程隔离还是熔断降级，都是对<strong>客户端</strong>（调用方）的保护。需要在<strong>调用方</strong> 发起远程调用时做线程隔离、或者服务熔断。</p><p>而我们的微服务远程调用都是基于Feign来完成的，因此我们需要将Feign与Sentinel整合，在Feign里面实现线程隔离和服务熔断。</p><h2 id="3-1-FeignClient整合Sentinel"><a href="#3-1-FeignClient整合Sentinel" class="headerlink" title="3.1.FeignClient整合Sentinel"></a>3.1.FeignClient整合Sentinel</h2><p>SpringCloud中，微服务调用都是通过Feign来实现的，因此做客户端保护必须整合Feign和Sentinel。</p><h3 id="3-1-1-修改配置，开启sentinel功能"><a href="#3-1-1-修改配置，开启sentinel功能" class="headerlink" title="3.1.1.修改配置，开启sentinel功能"></a>3.1.1.修改配置，开启sentinel功能</h3><p>修改OrderService的application.yml文件，开启Feign的Sentinel功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><h3 id="3-1-2-编写失败降级逻辑"><a href="#3-1-2-编写失败降级逻辑" class="headerlink" title="3.1.2.编写失败降级逻辑"></a>3.1.2.编写失败降级逻辑</h3><p>业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p><p>给FeignClient编写失败后的降级逻辑</p><p>①方式一：FallbackClass，无法对远程调用的异常做处理</p><p>②方式二：FallbackFactory，可以对远程调用的异常做处理，我们选择这种</p><p>这里我们演示方式二的失败降级处理。</p><p><strong>步骤一</strong>：在feing-api项目中定义类，实现FallbackFactory：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716122403502.png" alt="image-20210716122403502"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.feign.clients.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.clients.UserClient;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.pojo.User;</span><br><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;UserClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;查询用户异常&quot;</span>, throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>步骤二</strong>：在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserClientFallbackFactory <span class="title function_">userClientFallbackFactory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserClientFallbackFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤三</strong>：在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.feign.clients.fallback.UserClientFallbackFactory;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启后，访问一次订单查询业务，然后查看sentinel控制台，可以看到新的簇点链路：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716123705780.png" alt="image-20210716123705780"></p><h3 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3.总结"></a>3.1.3.总结</h3><p>Sentinel支持的雪崩解决方案：</p><ul><li>线程隔离（仓壁模式）</li><li>降级熔断</li></ul><p>Feign整合Sentinel的步骤：</p><ul><li>在application.yml中配置：feign.sentienl.enable&#x3D;true</li><li>给FeignClient编写FallbackFactory并注册为Bean</li><li>将FallbackFactory配置到FeignClient</li></ul><h2 id="3-2-线程隔离（舱壁模式）"><a href="#3-2-线程隔离（舱壁模式）" class="headerlink" title="3.2.线程隔离（舱壁模式）"></a>3.2.线程隔离（舱壁模式）</h2><h3 id="3-2-1-线程隔离的实现方式"><a href="#3-2-1-线程隔离的实现方式" class="headerlink" title="3.2.1.线程隔离的实现方式"></a>3.2.1.线程隔离的实现方式</h3><p>线程隔离有两种方式实现：</p><ul><li><p>线程池隔离</p></li><li><p>信号量隔离（Sentinel默认采用）</p></li></ul><p>如图：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716123036937.png" alt="image-20210716123036937"></p><p><strong>线程池隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</p><p><strong>信号量隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</p><p>两者的优缺点：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716123240518.png" alt="image-20210716123240518"></p><h3 id="3-2-2-sentinel的线程隔离"><a href="#3-2-2-sentinel的线程隔离" class="headerlink" title="3.2.2.sentinel的线程隔离"></a>3.2.2.sentinel的线程隔离</h3><p><strong>用法说明</strong>：</p><p>在添加限流规则时，可以选择两种阈值类型：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716123411217.png" alt="image-20210716123411217"></p><ul><li><p>QPS：就是每秒的请求数，在快速入门中已经演示过</p></li><li><p>线程数：是该资源能使用用的tomcat线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</p></li></ul><p><strong>案例需求</strong>：给 order-service服务中的UserClient的查询用户接口设置流控规则，线程数不能超过 2。然后利用jemeter测试。</p><h4 id="1）配置隔离规则"><a href="#1）配置隔离规则" class="headerlink" title="1）配置隔离规则"></a>1）配置隔离规则</h4><p>选择feign接口后面的流控按钮：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716123831992.png" alt="image-20210716123831992"></p><p>填写表单：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716123936844.png" alt="image-20210716123936844"></p><h4 id="2）Jmeter测试-2"><a href="#2）Jmeter测试-2" class="headerlink" title="2）Jmeter测试"></a>2）Jmeter测试</h4><p>选择《阈值类型-线程数&lt;2》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716124229894.png" alt="image-20210716124229894"></p><p>一次发生10个请求，有较大概率并发线程数超过2，而超出的请求会走之前定义的失败降级逻辑。</p><p>查看运行结果：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716124147820.png" alt="image-20210716124147820"></p><p>发现虽然结果都是通过了，不过部分请求得到的响应是降级返回的null信息。</p><h3 id="3-2-3-总结"><a href="#3-2-3-总结" class="headerlink" title="3.2.3.总结"></a>3.2.3.总结</h3><p>线程隔离的两种手段是？</p><ul><li><p>信号量隔离</p></li><li><p>线程池隔离</p></li></ul><p>信号量隔离的特点是？</p><ul><li>基于计数器模式，简单，开销小</li></ul><p>线程池隔离的特点是？</p><ul><li>基于线程池模式，有额外开销，但隔离控制更强</li></ul><h2 id="3-3-熔断降级"><a href="#3-3-熔断降级" class="headerlink" title="3.3.熔断降级"></a>3.3.熔断降级</h2><p>熔断降级是解决雪崩问题的重要手段。其思路是由<strong>断路器</strong>统计服务调用的异常比例、慢请求比例，如果超出阈值则会<strong>熔断</strong>该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p><p>断路器控制熔断和放行是通过状态机来完成的：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716130958518.png" alt="image-20210716130958518"></p><p>状态机包括三个状态：</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态</li><li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>断路器熔断策略有三种：慢调用、异常比例、异常数</p><h3 id="3-3-1-慢调用"><a href="#3-3-1-慢调用" class="headerlink" title="3.3.1.慢调用"></a>3.3.1.慢调用</h3><p><strong>慢调用</strong>：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。</p><p>例如：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716145934347.png" alt="image-20210716145934347"></p><p>解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。</p><p><strong>案例</strong></p><p>需求：给 UserClient的查询用户接口设置降级规则，慢调用的RT阈值为50ms，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5</p><h4 id="1）设置慢调用"><a href="#1）设置慢调用" class="headerlink" title="1）设置慢调用"></a>1）设置慢调用</h4><p>修改user-service中的&#x2F;user&#x2F;{id}这个接口的业务。通过休眠模拟一个延迟时间：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150234787.png" alt="image-20210716150234787"></p><p>此时，orderId&#x3D;101的订单，关联的是id为1的用户，调用时长为60ms：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150510956.png" alt="image-20210716150510956"></p><p>orderId&#x3D;102的订单，关联的是id为2的用户，调用时长为非常短；</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150605208.png" alt="image-20210716150605208"></p><h4 id="2）设置熔断规则"><a href="#2）设置熔断规则" class="headerlink" title="2）设置熔断规则"></a>2）设置熔断规则</h4><p>下面，给feign接口设置降级规则：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150654094.png" alt="image-20210716150654094"></p><p>规则：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150740434.png" alt="image-20210716150740434"></p><p>超过50ms的请求都会被认为是慢请求</p><h4 id="3）测试"><a href="#3）测试" class="headerlink" title="3）测试"></a>3）测试</h4><p>在浏览器访问：<a href="http://localhost:8088/order/101%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%88%B7%E6%96%B05%E6%AC%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%EF%BC%9A">http://localhost:8088/order/101，快速刷新5次，可以发现：</a></p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150911004.png" alt="image-20210716150911004"></p><p>触发了熔断，请求时长缩短至5ms，快速失败了，并且走降级逻辑，返回的null</p><p>在浏览器访问：<a href="http://localhost:8088/order/102%EF%BC%8C%E7%AB%9F%E7%84%B6%E4%B9%9F%E8%A2%AB%E7%86%94%E6%96%AD%E4%BA%86%EF%BC%9A">http://localhost:8088/order/102，竟然也被熔断了：</a></p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716151107785.png" alt="image-20210716151107785"></p><h3 id="3-3-2-异常比例、异常数"><a href="#3-3-2-异常比例、异常数" class="headerlink" title="3.3.2.异常比例、异常数"></a>3.3.2.异常比例、异常数</h3><p><strong>异常比例或异常数</strong>：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p><p>例如，一个异常比例设置：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716131430682.png" alt="image-20210716131430682"></p><p>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于0.4，则触发熔断。</p><p>一个异常数设置：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716131522912.png" alt="image-20210716131522912"></p><p>解读：统计最近1000ms内的请求，如果请求量超过10次，并且异常比例不低于2次，则触发熔断。</p><p><strong>案例</strong></p><p>需求：给 UserClient的查询用户接口设置降级规则，统计时间为1秒，最小请求数量为5，失败阈值比例为0.4，熔断时长为5s</p><h4 id="1）设置异常请求"><a href="#1）设置异常请求" class="headerlink" title="1）设置异常请求"></a>1）设置异常请求</h4><p>首先，修改user-service中的&#x2F;user&#x2F;{id}这个接口的业务。手动抛出异常，以触发异常比例的熔断：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716151348183.png" alt="image-20210716151348183"></p><p>也就是说，id 为 2时，就会触发异常</p><h4 id="2）设置熔断规则-1"><a href="#2）设置熔断规则-1" class="headerlink" title="2）设置熔断规则"></a>2）设置熔断规则</h4><p>下面，给feign接口设置降级规则：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716150654094.png" alt="image-20210716150654094"></p><p>规则：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716151538785.png" alt="image-20210716151538785"></p><p>在5次请求中，只要异常比例超过0.4，也就是有2次以上的异常，就会触发熔断。</p><h4 id="3）测试-1"><a href="#3）测试-1" class="headerlink" title="3）测试"></a>3）测试</h4><p>在浏览器快速访问：<a href="http://localhost:8088/order/102%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%88%B7%E6%96%B05%E6%AC%A1%EF%BC%8C%E8%A7%A6%E5%8F%91%E7%86%94%E6%96%AD%EF%BC%9A">http://localhost:8088/order/102，快速刷新5次，触发熔断：</a></p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716151722916.png" alt="image-20210716151722916"></p><p>此时，我们去访问本来应该正常的103：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716151844817.png" alt="image-20210716151844817"></p><h1 id="4-授权规则"><a href="#4-授权规则" class="headerlink" title="4.授权规则"></a>4.授权规则</h1><p>授权规则可以对请求方来源做判断和控制。</p><h2 id="4-1-授权规则"><a href="#4-1-授权规则" class="headerlink" title="4.1.授权规则"></a>4.1.授权规则</h2><h3 id="4-1-1-基本规则"><a href="#4-1-1-基本规则" class="headerlink" title="4.1.1.基本规则"></a>4.1.1.基本规则</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li><p>白名单：来源（origin）在白名单内的调用者允许访问</p></li><li><p>黑名单：来源（origin）在黑名单内的调用者不允许访问</p></li></ul><p>点击左侧菜单的授权，可以看到授权规则：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716152010750.png" alt="image-20210716152010750"></p><ul><li><p>资源名：就是受保护的资源，例如&#x2F;order&#x2F;{orderId}</p></li><li><p>流控应用：是来源者的名单，</p><ul><li>如果是勾选白名单，则名单中的来源被许可访问。</li><li>如果是勾选黑名单，则名单中的来源被禁止访问。</li></ul></li></ul><p>比如：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716152349191.png" alt="image-20210716152349191"></p><p>我们允许请求从gateway到order-service，不允许浏览器访问order-service，那么白名单中就要填写<strong>网关的来源名称（origin）</strong>。</p><h3 id="4-1-2-如何获取origin"><a href="#4-1-2-如何获取origin" class="headerlink" title="4.1.2.如何获取origin"></a>4.1.2.如何获取origin</h3><p>Sentinel是通过RequestOriginParser这个接口的parseOrigin来获取请求的来源的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestOriginParser</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从请求request对象中获取origin，获取方式自定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用就是从request对象中，获取请求者的origin值并返回。</p><p>默认情况下，sentinel不管请求者从哪里来，返回值永远是default，也就是说一切请求的来源都被认为是一样的值default。</p><p>因此，我们需要自定义这个接口的实现，让<strong>不同的请求，返回不同的origin</strong>。</p><p>例如order-service服务中，我们定义一个RequestOriginParser的实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaderOriginParser</span> <span class="keyword">implements</span> <span class="title class_">RequestOriginParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(origin)) &#123;</span><br><span class="line">            origin = <span class="string">&quot;blank&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会尝试从request-header中获取origin值。</p><h3 id="4-1-3-给网关添加请求头"><a href="#4-1-3-给网关添加请求头" class="headerlink" title="4.1.3.给网关添加请求头"></a>4.1.3.给网关添加请求头</h3><p>既然获取请求origin的方式是从reques-header中获取origin值，我们必须让<strong>所有从gateway路由到微服务的请求都带上origin头</strong>。</p><p>这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。</p><p>修改gateway服务中的application.yml，添加一个defaultFilter：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=origin,gateway</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">       <span class="comment"># ...略</span></span><br></pre></td></tr></table></figure><p>这样，从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。</p><h3 id="4-1-4-配置授权规则"><a href="#4-1-4-配置授权规则" class="headerlink" title="4.1.4.配置授权规则"></a>4.1.4.配置授权规则</h3><p>接下来，我们添加一个授权规则，放行origin值为gateway的请求。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716153250134.png" alt="image-20210716153250134"></p><p>配置如下：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716153301069.png" alt="image-20210716153301069"></p><p>现在，我们直接跳过网关，访问order-service服务：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716153348396.png" alt="image-20210716153348396"></p><p>通过网关访问：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716153434095.png" alt="image-20210716153434095"></p><h2 id="4-2-自定义异常结果"><a href="#4-2-自定义异常结果" class="headerlink" title="4.2.自定义异常结果"></a>4.2.自定义异常结果</h2><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p><h3 id="4-2-1-异常类型"><a href="#4-2-1-异常类型" class="headerlink" title="4.2.1.异常类型"></a>4.2.1.异常类型</h3><p>而如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有三个参数：</p><ul><li>HttpServletRequest request：request对象</li><li>HttpServletResponse response：response对象</li><li>BlockException e：被sentinel拦截时抛出的异常</li></ul><p>这里的BlockException包含多个不同的子类：</p><table><thead><tr><th><strong>异常</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>FlowException</td><td>限流异常</td></tr><tr><td>ParamFlowException</td><td>热点参数限流的异常</td></tr><tr><td>DegradeException</td><td>降级异常</td></tr><tr><td>AuthorityException</td><td>授权规则异常</td></tr><tr><td>SystemBlockException</td><td>系统规则异常</td></tr></tbody></table><h3 id="4-2-2-自定义异常处理"><a href="#4-2-2-自定义异常处理" class="headerlink" title="4.2.2.自定义异常处理"></a>4.2.2.自定义异常处理</h3><p>下面，我们就在order-service定义一个自定义异常处理类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">BlockExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;未知异常&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">429</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;</span><br><span class="line">            status = <span class="number">401</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(status);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&#123;\&quot;msg\&quot;: \&quot;&quot;</span> + msg + <span class="string">&quot;\&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启测试，在不同场景下，会返回不同的异常消息.</p><p>限流：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716153938887.png" alt="image-20210716153938887"></p><p>授权拦截时：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716154012736.png" alt="image-20210716154012736"></p><h1 id="5-规则持久化"><a href="#5-规则持久化" class="headerlink" title="5.规则持久化"></a>5.规则持久化</h1><p>现在，sentinel的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。</p><h2 id="5-1-规则管理模式"><a href="#5-1-规则管理模式" class="headerlink" title="5.1.规则管理模式"></a>5.1.规则管理模式</h2><p>规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：</p><ul><li>原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。</li><li>pull模式</li><li>push模式</li></ul><h3 id="5-1-1-pull模式"><a href="#5-1-1-pull模式" class="headerlink" title="5.1.1.pull模式"></a>5.1.1.pull模式</h3><p>pull模式：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716154155238.png" alt="image-20210716154155238"></p><h3 id="5-1-2-push模式"><a href="#5-1-2-push模式" class="headerlink" title="5.1.2.push模式"></a>5.1.2.push模式</h3><p>push模式：控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716154215456.png" alt="image-20210716154215456"></p><h2 id="5-2-实现push模式"><a href="#5-2-实现push模式" class="headerlink" title="5.2.实现push模式"></a>5.2.实现push模式</h2><p>详细步骤可以参考课前资料的《sentinel规则持久化》：</p><p><img src="/2022/09/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/image-20210716154255466.png" alt="image-20210716154255466"></p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> SrpingCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-data-elasticSearch</title>
      <link href="/2022/09/28/SpringES/"/>
      <url>/2022/09/28/SpringES/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="01-Spring-Data-简介"><a href="#01-Spring-Data-简介" class="headerlink" title="01.Spring Data 简介"></a>01.Spring Data 简介</h1><h2 id="what：是什么"><a href="#what：是什么" class="headerlink" title="what：是什么"></a>what：是什么</h2><p>Spring Data是一个用于简化持久层数据访问的开源框架。<br>其主要目标是使得对数据的访问变得方便快捷。<br>Spring Data可以极大的简化数据操作的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。<br>包括CRUD外，还包括如分页、排序等一些常用的功能，几乎可以节省持久层代码80%以上的编码工作量。<br>Spring Data的官网：<a href="http://projects.spring.io/spring-data/">http://projects.spring.io/spring-data/</a></p><h1 id="02-Spring-Data-ElasticSearch简介"><a href="#02-Spring-Data-ElasticSearch简介" class="headerlink" title="02.Spring Data ElasticSearch简介"></a>02.Spring Data ElasticSearch简介</h1><h2 id="what：是什么-1"><a href="#what：是什么-1" class="headerlink" title="what：是什么"></a>what：是什么</h2><ul><li>Templates as a high-level abstraction for storing, searching, sorting documents and building aggregations.<br> 模板类 ElasticsearchRestTemplate 作为存储、搜索、排序文档和构建聚合的高级抽象</li><li>Repositories which for example enable the user to express queries by defining interfaces having customized method names<br>允许用户通过定义具有自定义方法名的接口来表示查询的存储库</li><li>Spring Data ElasticSearch 基于 spring data API 简化 elasticSearch操作，将原始操作elasticSearch的客户端API 进行封装 。</li><li>Spring Data为Elasticsearch项目提供集成搜索引擎。</li><li>Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储库数据访问层。</li></ul><p>官方网站：<a href="http://projects.spring.io/spring-data-elasticsearch/">http://projects.spring.io/spring-data-elasticsearch/</a></p><h2 id="why：为什么使用"><a href="#why：为什么使用" class="headerlink" title="why：为什么使用"></a>why：为什么使用</h2><p>用来操作ElasticSearch的框架，使得开发更加便捷</p><h1 id="03-环境搭建"><a href="#03-环境搭建" class="headerlink" title="03.环境搭建"></a>03.环境搭建</h1><p>实现步骤：</p><ul><li><p>创建SpringBoot的项目：版本为<version>2.1.9.RELEASE</version></p></li><li><p>勾选starter依赖坐标</p></li><li><p>编写持久层接口GoodDao，编写pojo实体类</p></li><li><p>配置文件，集群配置，ElasticSearch服务地址<a href="http://127.0.0.1:9300/">http://127.0.0.1:9300</a><br>实现过程：</p></li><li><p>创建SpringBoot的项目!</p></li><li><p>勾选starter依赖坐标，依赖如下</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hotel-demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;hotel-demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;elasticsearch&gt;7.12.1&lt;/elasticsearch&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;!--FastJson--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.71&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- es-restclient--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--新增amqp--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!----&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;excludes&gt;</span><br><span class="line">                        &lt;exclude&gt;</span><br><span class="line">                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                        &lt;/exclude&gt;</span><br><span class="line">                    &lt;/excludes&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件：applacation.properties</p><p>集群配置，ElasticSearch服务地址<a href="http://127.0.0.1:9301/">http://127.0.0.1:9301</a><br>这里的集群名称和服务地址要与之前教程中配置的保持一致</p><blockquote><p>配置集群名称<br>spring.data.elasticsearch.cluster-name&#x3D;my-Elasticsearch<br>  配置es的服务地址<br>spring.data.elasticsearch.cluster-nodes&#x3D;127.0.0.1:9301</p></blockquote><h1 id="04编写持久层接口GoodDao，编写pojo实体类。"><a href="#04编写持久层接口GoodDao，编写pojo实体类。" class="headerlink" title="04编写持久层接口GoodDao，编写pojo实体类。"></a>04编写持久层接口GoodDao，编写pojo实体类。</h1><p>编写ES实体类 与索引库的_resources字段建立映射。<br>索引库我已建好存放在ES,关于字段类型和 其他属性配置，参考：</p><p>元数据类型 官网参考:<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html</a></p><p>Field 自定义字段数据类型参考官网: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</a></p><p>Mapping 作用参考 :<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html</a></p><blockquote><p>简单介绍<br>几个用到的注解：<br>@Document：声明索引库配置<br>indexName：索引库名称<br>type：类型名称，默认是“docs”<br>shards：分片数量，默认5<br>replicas：副本数量，默认1<br>@Id：声明实体类的id<br>@Field：声明字段属性<br>type：字段的数据类型<br>analyzer：指定分词器类型<br>index：是否创建索引 默认为true<br>store:是否存储 默认为false</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tommy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HotelIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28/19:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">//声明文档数据</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelIndex</span> &#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@Field(type = FieldType.Text,analyzer = &quot;text_anlyzer&quot;,searchAnalyzer = &quot;ik_smart&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword,index = false)</span></span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Integer,index = false)</span></span><br><span class="line"><span class="keyword">private</span> Integer price;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword)</span></span><br><span class="line"><span class="keyword">private</span> Integer score;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword,copyTo = &quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String brand;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword)</span></span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword)</span></span><br><span class="line"><span class="keyword">private</span> String starName;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword,copyTo = &quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String business;</span><br><span class="line"><span class="meta">@GeoPointField</span></span><br><span class="line"><span class="keyword">private</span> String location;</span><br><span class="line"><span class="meta">@Field(type=FieldType.Keyword,copyTo = &quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object distance;</span><br><span class="line"><span class="keyword">private</span> Boolean isAD;</span><br><span class="line"><span class="meta">@CompletionField(analyzer = &quot;completion_analyzer&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HotelDao 继承于 ElasticRepository -&gt; PagingAndSortingRepository -&gt; CrudRepository,<br>提供了基础的CURD 方法。<br><img src="/2022/09/28/SpringES/img1.png" alt="image1"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.pojo.HotelIndex;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tommy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HotelDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/9/28/19:38</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HotelDao</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;HotelIndex,Long&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="05-文档的常见增删改查"><a href="#05-文档的常见增删改查" class="headerlink" title="05.文档的常见增删改查"></a>05.文档的常见增删改查</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.dao.HotelDao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.pojo.HotelIndex;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.sort.SortBuilders;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HotelIndexTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HotelDao hotelDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HotelIndex</span> <span class="variable">hotelIndex</span> <span class="operator">=</span> hotelDao.findById(<span class="number">36934L</span>).get();</span><br><span class="line">        System.out.println(hotelIndex.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findByPageable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置当前页,和 每页显示多少条  ,按id 倒序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">PageRequest</span> <span class="variable">pageRequest</span> <span class="operator">=</span> PageRequest.of(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 将分页数据 传入 findAll(Pageable pageable)处理</span></span><br><span class="line">        <span class="comment">//处理完成 返回获取所有 分页好的 数据</span></span><br><span class="line">        Page&lt;HotelIndex&gt; pages = hotelDao.findAll(pageRequest);</span><br><span class="line">        <span class="comment">//遍历每个Hotel的信息</span></span><br><span class="line">        <span class="keyword">for</span> (HotelIndex hotelIndex : pages) &#123;</span><br><span class="line">            System.out.println(hotelIndex.toString()+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="06-自定义方法名称查询-重点"><a href="#06-自定义方法名称查询-重点" class="headerlink" title="06 自定义方法名称查询(重点)"></a>06 自定义方法名称查询(重点)</h1><ul><li>Repository提供了非常强大的自定义查询功能；只要遵循SpringData提供的语法，我们可以任意定义方法声明</li><li>查询语法：findBy+字段名+Keyword+字段名+</li></ul><p>官网注释, 继承ElasticsearchRepository的接口 hotelDao.search() 等方法已被舍弃。<br>Deprecated since 4.0, use standard repository method naming<br>or @Query annotated methods<br>or org.springframework.data.elasticsearch.core.ElasticsearchOperations.</p><p>现在可以使用基于 @Query 在Dao 持久层接口的方法上拼接 DSL 语句,但<strong>不推荐</strong>,因为编写难度大。<br>因此主要介绍org.springframework.data.elasticsearch.core:<br>以下是官网类注释</p><blockquote><p>ElasticsearchOperations. Since 4.0 this interface only contains common helper functions,<br>自从4.0后这接口只提供 普通的,查询帮助方法<br>the other methods have been moved to the different interfaces that are extended by ElasticsearchOperations.<br>其他方法已经移动到不同的 实现类中</p><blockquote><p>ElasticsearchOperations接口 继承 DocumentOperations  和 SearchOperations </p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务(下)</title>
      <link href="/2022/09/28/SpringCloud-2/"/>
      <url>/2022/09/28/SpringCloud-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="SpringCloud实用篇02"><a href="#SpringCloud实用篇02" class="headerlink" title="SpringCloud实用篇02"></a>SpringCloud实用篇02</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：<strong>bootstrap.yml</strong>文件，会在application.yml之前被读取，流程如下：</p><p><img src="/2022/09/28/SpringCloud-2/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.config.PatternProperties;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="/2022/09/28/SpringCloud-2/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8081/user/prop，结果：</a></p><p><img src="/2022/09/28/SpringCloud-2/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop%EF%BC%8C%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8082/user/prop，结果：</a></p><p><img src="/2022/09/28/SpringCloud-2/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714174728042.png" alt="image-20210714174728042"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：&#x2F;user&#x2F;{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714175415087.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714190528450.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714190640857.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1%E6%97%B6%EF%BC%8C%E7%AC%A6%E5%90%88%60/user/**%60%E8%A7%84%E5%88%99%EF%BC%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%88%B0uri%EF%BC%9Ahttp://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="/2022/09/28/SpringCloud-2/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714211742956.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714215713563.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="/2022/09/28/SpringCloud-2/image-20210714215832675.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期(单位：秒)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SrpingCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/09/27/RabbitMQ/"/>
      <url>/2022/09/27/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="/2022/09/27/RabbitMQ/image-20210717161939695.png" alt="image-20210717161939695"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="/2022/09/27/RabbitMQ/image-20210717162004285.png" alt="image-20210717162004285"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="/2022/09/27/RabbitMQ/image-20210422095356088.png" alt="image-20210422095356088"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考课前资料：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=panda \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq</span><br></pre></td></tr></table></figure><p><img src="/2022/09/27/RabbitMQ/image-20210717162628635.png" alt="image-20210717162628635"></p><p>MQ的基本结构：</p><p><img src="/2022/09/27/RabbitMQ/image-20210717162752376.png" alt="image-20210717162752376"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="/2022/09/27/RabbitMQ/image-20210717163332646.png" alt="image-20210717163332646"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>课前资料提供了一个Demo工程，mq-demo:</p><p><img src="/2022/09/27/RabbitMQ/image-20210717163253264.png" alt="image-20210717163253264"></p><p>导入后可以看到结构如下：</p><p><img src="/2022/09/27/RabbitMQ/image-20210717163604330.png" alt="image-20210717163604330"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="/2022/09/27/RabbitMQ/image-20210717163434647.png" alt="image-20210717163434647"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itheima.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PublisherTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itheima.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.150.101&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span><br><span class="line"><span class="params">                                       AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="/2022/09/27/RabbitMQ/image-20210717164024967.png" alt="image-20210717164024967"></p><p><img src="/2022/09/27/RabbitMQ/image-20210717164038678.png" alt="image-20210717164038678"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itheima.mq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itheima.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/2022/09/27/RabbitMQ/image-20210717164238910.png" alt="image-20210717164238910"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-x2F-订阅"><a href="#3-3-发布-x2F-订阅" class="headerlink" title="3.3.发布&#x2F;订阅"></a>3.3.发布&#x2F;订阅</h2><p>发布订阅的模型如图：</p><p><img src="/2022/09/27/RabbitMQ/image-20210717165309625.png" alt="image-20210717165309625"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="/2022/09/27/RabbitMQ/image-20210717165438225.png" alt="image-20210717165438225"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="/2022/09/27/RabbitMQ/1661223812142.png" alt="1661223812142"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="/2022/09/27/RabbitMQ/image-20210717165552676.png" alt="image-20210717165552676"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itheima.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;exchange.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;exchange.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/2022/09/27/RabbitMQ/image-20210717170041447.png" alt="image-20210717170041447"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><p><img src="/2022/09/27/RabbitMQ/1661223916373.png" alt="1661223916373"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;exchange.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;exchange.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="/2022/09/27/RabbitMQ/image-20210717170705380.png" alt="image-20210717170705380"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><p><img src="/2022/09/27/RabbitMQ/1661223980744.png" alt="1661223980744"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * topicExchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;exchange.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;exchange.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;exchange.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="/2022/09/27/RabbitMQ/image-20200525170410401.png" alt="image-20200525170410401"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>,<span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="/2022/09/27/RabbitMQ/image-20210422232835363.png" alt="image-20210422232835363"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ElatiscSeach 分布式搜索引擎(下)</title>
      <link href="/2022/09/27/ES03/"/>
      <url>/2022/09/27/ES03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="分布式搜索引擎03"><a href="#分布式搜索引擎03" class="headerlink" title="分布式搜索引擎03"></a>分布式搜索引擎03</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-数据聚合"><a href="#1-数据聚合" class="headerlink" title="1.数据聚合"></a>1.数据聚合</h1><p>**<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h2 id="1-1-聚合的种类"><a href="#1-1-聚合的种类" class="headerlink" title="1.1.聚合的种类"></a>1.1.聚合的种类</h2><p>聚合常见的有三类：</p><ul><li><p><strong>桶（Bucket）</strong>聚合：用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p><strong>度量（Metric）</strong>聚合：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li><p><strong>管道（pipeline）</strong>聚合：其它聚合的结果为基础做聚合</p></li></ul><blockquote><p><strong>注意：</strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</p></blockquote><h2 id="1-2-DSL实现聚合"><a href="#1-2-DSL实现聚合" class="headerlink" title="1.2.DSL实现聚合"></a>1.2.DSL实现聚合</h2><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p><h3 id="1-2-1-Bucket聚合语法"><a href="#1-2-1-Bucket聚合语法" class="headerlink" title="1.2.1.Bucket聚合语法"></a>1.2.1.Bucket聚合语法</h3><p>语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">// 设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//给聚合起个名字</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> <span class="comment">// 参与聚合的字段</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// 希望获取的聚合结果数量</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/2022/09/27/ES03/image-20210723171948228.png" alt="image-20210723171948228"></p><h3 id="1-2-2-聚合结果排序"><a href="#1-2-2-聚合结果排序" class="headerlink" title="1.2.2.聚合结果排序"></a>1.2.2.聚合结果排序</h3><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p><p>我们可以指定order属性，自定义聚合的排序方式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;_count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="comment">// 按照_count升序排列</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-限定聚合范围"><a href="#1-2-3-限定聚合范围" class="headerlink" title="1.2.3.限定聚合范围"></a>1.2.3.限定聚合范围</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加query条件即可：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这次，聚合得到的品牌明显变少了：</p><p><img src="/2022/09/27/ES03/image-20210723172404836.png" alt="image-20210723172404836"></p><h3 id="1-2-4-Metric聚合语法"><a href="#1-2-4-Metric聚合语法" class="headerlink" title="1.2.4.Metric聚合语法"></a>1.2.4.Metric聚合语法</h3><p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p><p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p><p>语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;score&quot;</span> <span class="comment">// 聚合字段，这里是score</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p><p><img src="/2022/09/27/ES03/image-20210723172917636.png" alt="image-20210723172917636"></p><h3 id="1-2-5-小结"><a href="#1-2-5-小结" class="headerlink" title="1.2.5.小结"></a>1.2.5.小结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="1-3-RestAPI实现聚合"><a href="#1-3-RestAPI实现聚合" class="headerlink" title="1.3.RestAPI实现聚合"></a>1.3.RestAPI实现聚合</h2><h3 id="1-3-1-API语法"><a href="#1-3-1-API语法" class="headerlink" title="1.3.1.API语法"></a>1.3.1.API语法</h3><p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p><p>聚合条件的语法：</p><p><img src="/2022/09/27/ES03/image-20210723173057733.png" alt="image-20210723173057733"></p><p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p><p><img src="/2022/09/27/ES03/image-20210723173215728.png" alt="image-20210723173215728"></p><h3 id="1-3-2-业务需求"><a href="#1-3-2-业务需求" class="headerlink" title="1.3.2.业务需求"></a>1.3.2.业务需求</h3><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p><p><img src="/2022/09/27/ES03/image-20210723192605566.png" alt="image-20210723192605566"></p><p>分析：</p><p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p><p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是<strong>限定范围的聚合</strong>，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p><p><img src="/2022/09/27/ES03/image-20210723193730799.png" alt="image-20210723193730799"></p><p>请求<strong>参数与搜索文档的参数完全一致</strong>。</p><p>返回值类型就是页面要展示的最终结果：</p><p><img src="/2022/09/27/ES03/image-20210723203915982.png" alt="image-20210723203915982"></p><p>结果是一个Map结构：</p><ul><li>key是字符串，城市、星级、品牌、价格</li><li>value是集合，例如多个城市的名称</li></ul><h3 id="1-3-3-业务实现"><a href="#1-3-3-业务实现" class="headerlink" title="1.3.3.业务实现"></a>1.3.3.业务实现</h3><p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p><ul><li>请求方式：<code>POST</code></li><li>请求路径：<code>/hotel/filters</code></li><li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li><li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;filters&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">getFilters</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hotelService.filters(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了IHotelService中的getFilters方法，尚未实现。</p><p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></table></figure><p>在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line">        <span class="comment">// 2.2.设置size</span></span><br><span class="line">        request.source().size(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2.3.聚合</span></span><br><span class="line">        buildAggregation(request);</span><br><span class="line">        <span class="comment">// 3.发出请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">        <span class="comment">// 4.1.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; brandList = getAggByName(aggregations, <span class="string">&quot;brandAgg&quot;</span>);</span><br><span class="line">        result.put(<span class="string">&quot;brand&quot;</span>, brandList);</span><br><span class="line">        <span class="comment">// 4.2.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; cityList = getAggByName(aggregations, <span class="string">&quot;cityAgg&quot;</span>);</span><br><span class="line">        result.put(<span class="string">&quot;city&quot;</span>, cityList);</span><br><span class="line">        <span class="comment">// 4.3.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; starList = getAggByName(aggregations, <span class="string">&quot;starAgg&quot;</span>);</span><br><span class="line">        result.put(<span class="string">&quot;starName&quot;</span>, starList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildAggregation</span><span class="params">(SearchRequest request)</span> &#123;</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">&quot;brandAgg&quot;</span>)</span><br><span class="line">                                 .field(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">&quot;cityAgg&quot;</span>)</span><br><span class="line">                                 .field(<span class="string">&quot;city&quot;</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">&quot;starAgg&quot;</span>)</span><br><span class="line">                                 .field(<span class="string">&quot;starName&quot;</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getAggByName</span><span class="params">(Aggregations aggregations, String aggName)</span> &#123;</span><br><span class="line">    <span class="comment">// 4.1.根据聚合名称获取聚合结果</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(aggName);</span><br><span class="line">    <span class="comment">// 4.2.获取buckets</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;String&gt; brandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 4.4.获取key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        brandList.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> brandList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-自动补全"><a href="#2-自动补全" class="headerlink" title="2.自动补全"></a>2.自动补全</h1><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p><p><img src="/2022/09/27/ES03/image-20210723204936367.png" alt="image-20210723204936367"></p><p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h2 id="2-1-拼音分词器"><a href="#2-1-拼音分词器" class="headerlink" title="2.1.拼音分词器"></a>2.1.拼音分词器</h2><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p><img src="/2022/09/27/ES03/image-20210723205932746.png" alt="image-20210723205932746"></p><p>课前资料中也提供了拼音分词器的安装包：</p><p><img src="/2022/09/27/ES03/image-20210723205722303.png" alt="image-20210723205722303"> </p><p>安装方式与IK分词器一样，分三步：</p><p>​①解压</p><p>​②上传到虚拟机中，elasticsearch的plugin目录</p><p>​③重启elasticsearch</p><p>​④测试</p><p>详细安装步骤可以参考IK分词器的安装过程。</p><p>测试用法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家酒店还不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/09/27/ES03/image-20210723210126506.png" alt="image-20210723210126506"> </p><h2 id="2-2-自定义分词器"><a href="#2-2-自定义分词器" class="headerlink" title="2.2.自定义分词器"></a>2.2.自定义分词器</h2><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p>文档分词时会依次由这三部分来处理文档：</p><p>   <img src="/2022/09/27/ES03/image-20210723210427878.png" alt="image-20210723210427878"></p><p>声明自定义分词器的语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 分词器名称</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 自定义tokenizer filter</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 过滤器名称</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span> <span class="comment">// 过滤器类型，这里是pinyin</span></span><br><span class="line">  <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_analyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="/2022/09/27/ES03/image-20210723211829150.png" alt="image-20210723211829150"></p><p>总结：</p><p>如何使用拼音分词器？</p><ul><li><p>①下载pinyin分词器</p></li><li><p>②解压并放到elasticsearch的plugin目录</p></li><li><p>③重启即可</p></li></ul><p>如何自定义分词器？</p><ul><li><p>①创建索引库时，在settings中配置，可以包含三部分</p></li><li><p>②character filter</p></li><li><p>③tokenizer</p></li><li><p>④filter</p></li></ul><p>拼音分词器注意事项？</p><ul><li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li></ul><h2 id="2-3-自动补全查询"><a href="#2-3-自动补全查询" class="headerlink" title="2.3.自动补全查询"></a>2.3.自动补全查询</h2><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是completion类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p></li></ul><p>比如，一个这样的索引库：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建索引库</span></span><br><span class="line">PUT test</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后插入下面的数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Sony&quot;</span><span class="punctuation">,</span> <span class="string">&quot;WH-1000XM3&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;SK-II&quot;</span><span class="punctuation">,</span> <span class="string">&quot;PITERA&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST test/_doc</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;Nintendo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;switch&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动补全查询</span></span><br><span class="line">GET /test/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title_suggest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span> <span class="comment">// 关键字</span></span><br><span class="line">      <span class="attr">&quot;completion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span> <span class="comment">// 补全查询的字段</span></span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 跳过重复的</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">// 获取前10条结果</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-实现酒店搜索框自动补全"><a href="#2-4-实现酒店搜索框自动补全" class="headerlink" title="2.4.实现酒店搜索框自动补全"></a>2.4.实现酒店搜索框自动补全</h2><p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改hotel索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的name、all字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p></li><li><p>给HotelDoc类添加suggestion字段，内容包含brand、business</p></li><li><p>重新导入数据到hotel库</p></li></ol><h3 id="2-4-1-修改酒店映射结构"><a href="#2-4-1-修改酒店映射结构" class="headerlink" title="2.4.1.修改酒店映射结构"></a>2.4.1.修改酒店映射结构</h3><p>代码如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;text_anlyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;completion_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;py&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;py&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pinyin&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_anlyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;starName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text_anlyzer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;suggestion&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;completion_analyzer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-修改HotelDoc实体"><a href="#2-4-2-修改HotelDoc实体" class="headerlink" title="2.4.2.修改HotelDoc实体"></a>2.4.2.修改HotelDoc实体</h3><p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">        <span class="comment">// 组装suggestion</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.business.contains(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// business有多个值，需要切割</span></span><br><span class="line">            String[] arr = <span class="built_in">this</span>.business.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="built_in">this</span>.suggestion = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.suggestion.add(<span class="built_in">this</span>.brand);</span><br><span class="line">            Collections.addAll(<span class="built_in">this</span>.suggestion, arr);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.suggestion = Arrays.asList(<span class="built_in">this</span>.brand, <span class="built_in">this</span>.business);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-重新导入"><a href="#2-4-3-重新导入" class="headerlink" title="2.4.3.重新导入"></a>2.4.3.重新导入</h3><p>重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p><p><img src="/2022/09/27/ES03/image-20210723213546183.png" alt="image-20210723213546183"></p><h3 id="2-4-4-自动补全查询的JavaAPI"><a href="#2-4-4-自动补全查询的JavaAPI" class="headerlink" title="2.4.4.自动补全查询的JavaAPI"></a>2.4.4.自动补全查询的JavaAPI</h3><p>之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p><p><img src="/2022/09/27/ES03/image-20210723213759922.png" alt="image-20210723213759922"></p><p>而自动补全的结果也比较特殊，解析的代码如下：</p><p><img src="/2022/09/27/ES03/image-20210723213917524.png" alt="image-20210723213917524"></p><h3 id="2-4-5-实现搜索框自动补全"><a href="#2-4-5-实现搜索框自动补全" class="headerlink" title="2.4.5.实现搜索框自动补全"></a>2.4.5.实现搜索框自动补全</h3><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p><p><img src="/2022/09/27/ES03/image-20210723214021062.png" alt="image-20210723214021062"></p><p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p><p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;suggestion&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(<span class="meta">@RequestParam(&quot;key&quot;)</span> String prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hotelService.getSuggestions(prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span>;</span><br></pre></td></tr></table></figure><p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        request.source().suggest(<span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">            <span class="string">&quot;suggestions&quot;</span>,</span><br><span class="line">            SuggestBuilders.completionSuggestion(<span class="string">&quot;suggestion&quot;</span>)</span><br><span class="line">            .prefix(prefix)</span><br><span class="line">            .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">            .size(<span class="number">10</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3.发起请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line">        <span class="comment">// 4.1.根据补全查询名称，获取补全结果</span></span><br><span class="line">        <span class="type">CompletionSuggestion</span> <span class="variable">suggestions</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">&quot;suggestions&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.2.获取options</span></span><br><span class="line">        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();</span><br><span class="line">        <span class="comment">// 4.3.遍历</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(options.size());</span><br><span class="line">        <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : options) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> option.getText().toString();</span><br><span class="line">            list.add(text);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-数据同步"><a href="#3-数据同步" class="headerlink" title="3.数据同步"></a>3.数据同步</h1><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p><p><img src="/2022/09/27/ES03/image-20210723214758392.png" alt="image-20210723214758392"></p><h2 id="3-1-思路分析"><a href="#3-1-思路分析" class="headerlink" title="3.1.思路分析"></a>3.1.思路分析</h2><p>常见的数据同步方案有三种：</p><ul><li>同步调用</li><li>异步通知</li><li>监听binlog</li></ul><h3 id="3-1-1-同步调用"><a href="#3-1-1-同步调用" class="headerlink" title="3.1.1.同步调用"></a>3.1.1.同步调用</h3><p>方案一：同步调用</p><p><img src="/2022/09/27/ES03/image-20210723214931869.png" alt="image-20210723214931869"></p><p>基本步骤如下：</p><ul><li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li><li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li></ul><h3 id="3-1-2-异步通知"><a href="#3-1-2-异步通知" class="headerlink" title="3.1.2.异步通知"></a>3.1.2.异步通知</h3><p>方案二：异步通知</p><p><img src="/2022/09/27/ES03/image-20210723215140735.png" alt="image-20210723215140735"></p><p>流程如下：</p><ul><li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li><li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li></ul><h3 id="3-1-3-监听binlog"><a href="#3-1-3-监听binlog" class="headerlink" title="3.1.3.监听binlog"></a>3.1.3.监听binlog</h3><p>方案三：监听binlog</p><p><img src="/2022/09/27/ES03/image-20210723215518541.png" alt="image-20210723215518541"></p><p>流程如下：</p><ul><li>给mysql开启binlog功能</li><li>mysql完成增、删、改操作都会记录在binlog中</li><li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li></ul><h3 id="3-1-4-选择"><a href="#3-1-4-选择" class="headerlink" title="3.1.4.选择"></a>3.1.4.选择</h3><p>方式一：同步调用</p><ul><li>优点：实现简单，粗暴</li><li>缺点：业务耦合度高</li></ul><p>方式二：异步通知</p><ul><li>优点：低耦合，实现难度一般</li><li>缺点：依赖mq的可靠性</li></ul><p>方式三：监听binlog</p><ul><li>优点：完全解除服务间耦合</li><li>缺点：开启binlog增加数据库负担、实现复杂度高</li></ul><h2 id="3-2-实现数据同步"><a href="#3-2-实现数据同步" class="headerlink" title="3.2.实现数据同步"></a>3.2.实现数据同步</h2><h3 id="3-2-1-思路"><a href="#3-2-1-思路" class="headerlink" title="3.2.1.思路"></a>3.2.1.思路</h3><p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p><p>步骤：</p><ul><li><p>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p></li><li><p>声明exchange、queue、RoutingKey</p></li><li><p>在hotel-admin中的增、删、改业务中完成消息发送</p></li><li><p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><h3 id="3-2-2-导入demo"><a href="#3-2-2-导入demo" class="headerlink" title="3.2.2.导入demo"></a>3.2.2.导入demo</h3><p>导入课前资料提供的hotel-admin项目：</p><p><img src="/2022/09/27/ES03/image-20210723220237930.png" alt="image-20210723220237930"></p><p>运行后，访问 <a href="http://localhost:8099/">http://localhost:8099</a></p><p><img src="/2022/09/27/ES03/image-20210723220354464.png" alt="image-20210723220354464"></p><p>其中包含了酒店的CRUD功能：</p><p><img src="/2022/09/27/ES03/image-20210723220511090.png" alt="image-20210723220511090"></p><h3 id="3-2-3-声明交换机、队列"><a href="#3-2-3-声明交换机、队列" class="headerlink" title="3.2.3.声明交换机、队列"></a>3.2.3.声明交换机、队列</h3><p>MQ结构如图：</p><p><img src="/2022/09/27/ES03/image-20210723215850307.png" alt="image-20210723215850307"></p><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><p>在hotel-admin、hotel-demo中引入rabbitmq的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2）声明队列交换机名称"><a href="#2）声明队列交换机名称" class="headerlink" title="2）声明队列交换机名称"></a>2）声明队列交换机名称</h4><p>在hotel-admin和hotel-demo中的<code>cn.itcast.hotel.constatnts</code>包下新建一个类<code>MqConstants</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constatnts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstants</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;hotel.topic&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听新增和修改的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;hotel.insert.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听删除的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;hotel.delete.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或修改的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_KEY</span> <span class="operator">=</span> <span class="string">&quot;hotel.insert&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_KEY</span> <span class="operator">=</span> <span class="string">&quot;hotel.delete&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）声明队列交换机"><a href="#3）声明队列交换机" class="headerlink" title="3）声明队列交换机"></a>3）声明队列交换机</h4><p>在hotel-demo中，定义配置类，声明队列、交换机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(MqConstants.HOTEL_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_INSERT_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deleteQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_DELETE_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">insertQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deleteQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-发送MQ消息"><a href="#3-2-4-发送MQ消息" class="headerlink" title="3.2.4.发送MQ消息"></a>3.2.4.发送MQ消息</h3><p>在hotel-admin中的增、删、改业务中分别发送MQ消息：</p><p><img src="/2022/09/27/ES03/image-20210723221843816.png" alt="image-20210723221843816"></p><h3 id="3-2-5-接收MQ消息"><a href="#3-2-5-接收MQ消息" class="headerlink" title="3.2.5.接收MQ消息"></a>3.2.5.接收MQ消息</h3><p>hotel-demo接收到MQ消息要做的事情包括：</p><ul><li>新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库</li><li>删除消息：根据传递的hotel的id删除索引库中的一条数据</li></ul><p>1）首先在hotel-demo的<code>cn.itcast.hotel.service</code>包下的<code>IHotelService</code>中新增新增、删除业务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><p>2）给hotel-demo中的<code>cn.itcast.hotel.service.impl</code>包下的HotelService中实现业务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, id.toString());</span><br><span class="line">        <span class="comment">// 2.发送请求</span></span><br><span class="line">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 0.根据id查询酒店数据</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 转换为文档类型</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotel.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）编写监听器</p><p>在hotel-demo中的<code>cn.itcast.hotel.mq</code>包新增一个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店新增或修改的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店删除的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-集群"><a href="#4-集群" class="headerlink" title="4.集群"></a>4.集群</h1><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li><li>单点故障问题：将分片数据在不同节点备份（replica ）</li></ul><p><strong>ES集群相关概念</strong>:</p><ul><li><p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p></li><li><p><font color="red">节点（node)</font>   ：集群中的一个 Elasticearch 实例</p></li><li><p><font color="red">分片（shard）</font>：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p><p>解决问题：数据量太大，单点存储量有限的问题。</p><p><img src="/2022/09/27/ES03/image-20200104124440086-5602723.png" alt="image-20200104124440086"></p><blockquote><p>此处，我们把数据分成3片：shard0、shard1、shard2</p></blockquote></li><li><p>主分片（Primary shard）：相对于副本分片的定义。</p></li><li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p><p>​</p></li></ul><p></p><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对每个分片进行备份，放到对方节点，完成互相备份</li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="/2022/09/27/ES03/image-20200104124551912.png" alt="image-20200104124551912"></p><p>现在，每个分片都有1个备份，存储在3个节点：</p><ul><li>node0：保存了分片0和1</li><li>node1：保存了分片0和2</li><li>node2：保存了分片1和2</li></ul><h2 id="4-1-搭建ES集群"><a href="#4-1-搭建ES集群" class="headerlink" title="4.1.搭建ES集群"></a>4.1.搭建ES集群</h2><p>参考课前资料的文档：</p><p><img src="/2022/09/27/ES03/image-20210723222732427.png" alt="image-20210723222732427"> </p><p>其中的第四章节：</p><p><img src="/2022/09/27/ES03/image-20210723222812619.png" alt="image-20210723222812619"> </p><h2 id="4-2-集群脑裂问题"><a href="#4-2-集群脑裂问题" class="headerlink" title="4.2.集群脑裂问题"></a>4.2.集群脑裂问题</h2><h3 id="4-2-1-集群职责划分"><a href="#4-2-1-集群职责划分" class="headerlink" title="4.2.1.集群职责划分"></a>4.2.1.集群职责划分</h3><p>elasticsearch中集群节点有不同的职责划分：</p><p><img src="/2022/09/27/ES03/image-20210723223008967.png" alt="image-20210723223008967"></p><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li>master节点：对CPU要求高，但是内存要求第</li><li>data节点：对CPU和内存要求都高</li><li>coordinating节点：对网络带宽、CPU要求高</li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的es集群职责划分如图：</p><p><img src="/2022/09/27/ES03/image-20210723223629142.png" alt="image-20210723223629142"></p><h3 id="4-2-2-脑裂问题"><a href="#4-2-2-脑裂问题" class="headerlink" title="4.2.2.脑裂问题"></a>4.2.2.脑裂问题</h3><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="/2022/09/27/ES03/image-20210723223804995.png" alt="image-20210723223804995"></p><p>此时，node2和node3认为node1宕机，就会重新选主：</p><p><img src="/2022/09/27/ES03/image-20210723223845754.png" alt="image-20210723223845754"></p><p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="/2022/09/27/ES03/image-20210723224000555.png" alt="image-20210723224000555"></p><p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）&#x2F; 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p><p>例如：3个节点形成的集群，选票必须超过 （3 + 1） &#x2F; 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p><h3 id="4-2-3-小结"><a href="#4-2-3-小结" class="headerlink" title="4.2.3.小结"></a>4.2.3.小结</h3><p>master eligible节点的作用是什么？</p><ul><li>参与集群选主</li><li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li></ul><p>data节点的作用是什么？</p><ul><li>数据的CRUD</li></ul><p>coordinator节点的作用是什么？</p><ul><li><p>路由请求到其它节点</p></li><li><p>合并查询到的结果，返回给用户</p></li></ul><h2 id="4-3-集群分布式存储"><a href="#4-3-集群分布式存储" class="headerlink" title="4.3.集群分布式存储"></a>4.3.集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p><h3 id="4-3-1-分片存储测试"><a href="#4-3-1-分片存储测试" class="headerlink" title="4.3.1.分片存储测试"></a>4.3.1.分片存储测试</h3><p>插入三条数据：</p><p><img src="/2022/09/27/ES03/image-20210723225006058.png" alt="image-20210723225006058"></p><p><img src="/2022/09/27/ES03/image-20210723225034637.png" alt="image-20210723225034637"></p><p><img src="/2022/09/27/ES03/image-20210723225112029.png" alt="image-20210723225112029"></p><p>测试可以看到，三条数据分别在不同分片：</p><p><img src="/2022/09/27/ES03/image-20210723225227928.png" alt="image-20210723225227928"></p><p>结果：</p><p><img src="/2022/09/27/ES03/image-20210723225342120.png" alt="image-20210723225342120"></p><h3 id="4-3-2-分片存储原理"><a href="#4-3-2-分片存储原理" class="headerlink" title="4.3.2.分片存储原理"></a>4.3.2.分片存储原理</h3><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p><p><img src="/2022/09/27/ES03/image-20210723224354904.png" alt="image-20210723224354904"></p><p>说明：</p><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>新增文档的流程如下：</p><p><img src="/2022/09/27/ES03/image-20210723225436084.png" alt="image-20210723225436084"></p><p>解读：</p><ul><li>1）新增一个id&#x3D;1的文档</li><li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li><li>3）shard-2的主分片在node3节点，将数据路由到node3</li><li>4）保存文档</li><li>5）同步给shard-2的副本replica-2，在node2节点</li><li>6）返回结果给coordinating-node节点</li></ul><h2 id="4-4-集群分布式查询"><a href="#4-4-集群分布式查询" class="headerlink" title="4.4.集群分布式查询"></a>4.4.集群分布式查询</h2><p>elasticsearch的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p></li></ul><p><img src="/2022/09/27/ES03/image-20210723225809848.png" alt="image-20210723225809848"></p><h2 id="4-5-集群故障转移"><a href="#4-5-集群故障转移" class="headerlink" title="4.5.集群故障转移"></a>4.5.集群故障转移</h2><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p>1）例如一个集群结构如图：</p><p><img src="/2022/09/27/ES03/image-20210723225945963.png" alt="image-20210723225945963"></p><p>现在，node1是主节点，其它两个节点是从节点。</p><p>2）突然，node1发生了故障：</p><p><img src="/2022/09/27/ES03/image-20210723230020574.png" alt="image-20210723230020574"></p><p>宕机后的第一件事，需要重新选主，例如选中了node2：</p><p><img src="/2022/09/27/ES03/image-20210723230055974.png" alt="image-20210723230055974"></p><p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p><p><img src="/2022/09/27/ES03/image-20210723230216642.png" alt="image-20210723230216642"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 分布式搜索引擎(中)</title>
      <link href="/2022/09/27/ES02/"/>
      <url>/2022/09/27/ES02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="分布式搜索引擎02"><a href="#分布式搜索引擎02" class="headerlink" title="分布式搜索引擎02"></a>分布式搜索引擎02</h1><p>我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。</p><p>所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。</p><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-DSL查询文档"><a href="#1-DSL查询文档" class="headerlink" title="1.DSL查询文档"></a>1.DSL查询文档</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p><h2 id="1-1-DSL查询分类"><a href="#1-1-DSL查询分类" class="headerlink" title="1.1.DSL查询分类"></a>1.1.DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p></li><li><p><strong>全文检索（full text）查询</strong>：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul></li><li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span><span class="punctuation">:</span> <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们以查询所有为例，其中：</p><ul><li>查询类型为match_all</li><li>没有查询条件</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p><h2 id="1-2-全文检索查询"><a href="#1-2-全文检索查询" class="headerlink" title="1.2.全文检索查询"></a>1.2.全文检索查询</h2><h3 id="1-2-1-使用场景"><a href="#1-2-1-使用场景" class="headerlink" title="1.2.1.使用场景"></a>1.2.1.使用场景</h3><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：</p><p><img src="/2022/09/27/ES02/image-20210721165326938.png" alt="image-20210721165326938"></p><p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的text类型的字段。</p><h3 id="1-2-2-基本语法"><a href="#1-2-2-基本语法" class="headerlink" title="1.2.2.基本语法"></a>1.2.2.基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>mulit_match语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;FIELD1&quot;</span><span class="punctuation">,</span> <span class="string">&quot; FIELD12&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-示例"><a href="#1-2-3-示例" class="headerlink" title="1.2.3.示例"></a>1.2.3.示例</h3><p>match查询示例：</p><p><img src="/2022/09/27/ES02/image-20210721170455419.png" alt="image-20210721170455419"></p><p>multi_match查询示例：</p><p><img src="/2022/09/27/ES02/image-20210721170720691.png" alt="image-20210721170720691"></p><p>可以看到，两种查询结果是一样的，为什么？</p><p>因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。</p><p>但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</p><h3 id="1-2-4-总结"><a href="#1-2-4-总结" class="headerlink" title="1.2.4.总结"></a>1.2.4.总结</h3><p>match和multi_match的区别是什么？</p><ul><li>match：根据一个字段查询</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><h2 id="1-3-精准查询"><a href="#1-3-精准查询" class="headerlink" title="1.3.精准查询"></a>1.3.精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><h3 id="1-3-1-term查询"><a href="#1-3-1-term查询" class="headerlink" title="1.3.1.term查询"></a>1.3.1.term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// term查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例：</p><p>当我搜索的是精确词条时，能正确查询出结果：</p><p><img src="/2022/09/27/ES02/image-20210721171655308.png" alt="image-20210721171655308"></p><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><p><img src="/2022/09/27/ES02/image-20210721171838378.png" alt="image-20210721171838378"></p><h3 id="1-3-2-range查询"><a href="#1-3-2-range查询" class="headerlink" title="1.3.2.range查询"></a>1.3.2.range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p>基本语法：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// range查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="/2022/09/27/ES02/image-20210721172307172.png" alt="image-20210721172307172"></p><h3 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h3><p>精确查询常见的有哪些？</p><ul><li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li><li>range查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h2 id="1-4-地理坐标查询"><a href="#1-4-地理坐标查询" class="headerlink" title="1.4.地理坐标查询"></a>1.4.地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><p>附近的酒店：</p><p><img src="/2022/09/27/ES02/image-20210721172645103.png" alt="image-20210721172645103"> </p><p>附近的车：</p><p><img src="/2022/09/27/ES02/image-20210721172654880.png" alt="image-20210721172654880"> </p><h3 id="1-4-1-矩形范围查询"><a href="#1-4-1-矩形范围查询" class="headerlink" title="1.4.1.矩形范围查询"></a>1.4.1.矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p><p><img src="/2022/09/27/ES02/DKV9HZbVS6.gif" alt="DKV9HZbVS6"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><p>语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// geo_bounding_box查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 左上点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.5</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 右下点</span></span><br><span class="line">          <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">121.7</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种并不符合“附近的人”这样的需求，所以我们就不做了。</p><h3 id="1-4-2-附近查询"><a href="#1-4-2-附近查询" class="headerlink" title="1.4.2.附近查询"></a>1.4.2.附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="/2022/09/27/ES02/vZrdKAh19C.gif" alt="vZrdKAh19C"></p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// geo_distance 查询</span></span><br><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;distance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;15km&quot;</span><span class="punctuation">,</span> <span class="comment">// 半径</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;31.21,121.5&quot;</span> <span class="comment">// 圆心</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例：</p><p>我们先搜索陆家嘴附近15km的酒店：</p><p><img src="/2022/09/27/ES02/image-20210721175443234.png" alt="image-20210721175443234"></p><p>发现共有47家酒店。</p><p>然后把半径缩短到3公里：</p><p><img src="/2022/09/27/ES02/image-20210721182031475.png" alt="image-20210721182031475"></p><p>可以发现，搜索到的酒店数量减少到了5家。</p><h2 id="1-5-复合查询"><a href="#1-5-复合查询" class="headerlink" title="1.5.复合查询"></a>1.5.复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h3 id="1-5-1-相关性算分"><a href="#1-5-1-相关性算分" class="headerlink" title="1.5.1.相关性算分"></a>1.5.1.相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;虹桥如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;外滩如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> <span class="punctuation">:</span> <span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;迪士尼如家酒店真不错&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p><p><img src="/2022/09/27/ES02/image-20210721190152134.png" alt="image-20210721190152134"></p><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p><p><img src="/2022/09/27/ES02/image-20210721190416214.png" alt="image-20210721190416214"></p><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="/2022/09/27/ES02/image-20210721190907320.png" alt="image-20210721190907320"></p><p>小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法</li></ul><h3 id="1-5-2-算分函数查询"><a href="#1-5-2-算分函数查询" class="headerlink" title="1.5.2.算分函数查询"></a>1.5.2.算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p><p><img src="/2022/09/27/ES02/image-20210721191144560.png" alt="image-20210721191144560"></p><p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p><h4 id="1）语法说明"><a href="#1）语法说明" class="headerlink" title="1）语法说明"></a>1）语法说明</h4><p><img src="/2022/09/27/ES02/image-20210721191544750.png" alt="image-20210721191544750"></p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li><li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><h4 id="2）示例"><a href="#2）示例" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些</p><p>翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand &#x3D; “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  .... <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">      <span class="attr">&quot;functions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 算分函数</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 满足的条件，品牌必须是如家</span></span><br><span class="line">            <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;如家&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="comment">// 算分权重为2</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sum&quot;</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>测试，在未添加算分函数时，如家得分如下：</p><p><img src="/2022/09/27/ES02/image-20210721193152520.png" alt="image-20210721193152520"></p><p>添加了算分函数后，如家得分就提升了：</p><p><img src="/2022/09/27/ES02/image-20210721193458182.png" alt="image-20210721193458182"></p><h4 id="3）小结"><a href="#3）小结" class="headerlink" title="3）小结"></a>3）小结</h4><p>function score query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><h3 id="1-5-3-布尔查询"><a href="#1-5-3-布尔查询" class="headerlink" title="1.5.3.布尔查询"></a>1.5.3.布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p><p><img src="/2022/09/27/ES02/image-20210721193822848.png" alt="image-20210721193822848"></p><p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p><p>需要注意的是，搜索时，参与<strong>打分的字段越多，查询的性能也越差</strong>。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li><li>其它过滤条件，采用filter查询。不参与算分</li></ul><h4 id="1）语法示例："><a href="#1）语法示例：" class="headerlink" title="1）语法示例："></a>1）语法示例：</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;上海&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;皇冠假日&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华美达&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">500</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">45</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2）示例-1"><a href="#2）示例-1" class="headerlink" title="2）示例"></a>2）示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p><p>分析：</p><ul><li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li><li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li><li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li></ul><p><img src="/2022/09/27/ES02/image-20210721194744183.png" alt="image-20210721194744183"></p><h4 id="3）小结-1"><a href="#3）小结-1" class="headerlink" title="3）小结"></a>3）小结</h4><p>bool查询有几种逻辑关系？</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h1 id="2-搜索结果处理"><a href="#2-搜索结果处理" class="headerlink" title="2.搜索结果处理"></a>2.搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。</p><h2 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1.排序"></a>2.1.排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><h3 id="2-1-1-普通字段排序"><a href="#2-1-1-普通字段排序" class="headerlink" title="2.1.1.普通字段排序"></a>2.1.1.普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。</p><p><strong>语法</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p><p><strong>示例</strong>：</p><p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p><p><img src="/2022/09/27/ES02/image-20210721195728306.png" alt="image-20210721195728306"></p><h3 id="2-1-2-地理坐标排序"><a href="#2-1-2-地理坐标排序" class="headerlink" title="2.1.2.地理坐标排序"></a>2.1.2.地理坐标排序</h3><p>地理坐标排序略有不同。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;纬度，经度&quot;</span><span class="punctuation">,</span> <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span> <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><p><strong>示例：</strong></p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><p><img src="/2022/09/27/ES02/image-20210721200214690.png" alt="image-20210721200214690"></p><h2 id="2-2-分页"><a href="#2-2-分页" class="headerlink" title="2.2.分页"></a>2.2.分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><h3 id="2-2-1-基本的分页"><a href="#2-2-1-基本的分页" class="headerlink" title="2.2.1.基本的分页"></a>2.2.1.基本的分页</h3><p>分页的基本语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-深度分页问题"><a href="#2-2-2-深度分页问题" class="headerlink" title="2.2.2.深度分页问题"></a>2.2.2.深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p><p><img src="/2022/09/27/ES02/image-20210721200643029.png" alt="image-20210721200643029"></p><p>查询TOP1000，如果es是单点模式，这并无太大影响。</p><p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p><p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p><p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p><p><img src="/2022/09/27/ES02/image-20210721201003229.png" alt="image-20210721201003229"></p><p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul><h3 id="2-2-3-小结"><a href="#2-2-3-小结" class="headerlink" title="2.2.3.小结"></a>2.2.3.小结</h3><p>分页查询的常见实现方案以及优缺点：</p><ul><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul><h2 id="2-3-高亮"><a href="#2-3-高亮" class="headerlink" title="2.3.高亮"></a>2.3.高亮</h2><h3 id="2-3-1-高亮原理"><a href="#2-3-1-高亮原理" class="headerlink" title="2.3.1.高亮原理"></a>2.3.1.高亮原理</h3><p>什么是高亮显示呢？</p><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p><p><img src="/2022/09/27/ES02/image-20210721202705030.png" alt="image-20210721202705030"></p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><h3 id="2-3-2-实现高亮"><a href="#2-3-2-实现高亮" class="headerlink" title="2.3.2.实现高亮"></a>2.3.2.实现高亮</h3><p><strong>高亮的语法</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT&quot;</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 指定要高亮的字段</span></span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span>  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false</li></ul><p><strong>示例</strong>：</p><p><img src="/2022/09/27/ES02/image-20210721203349633.png" alt="image-20210721203349633"></p><h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4.总结"></a>2.4.总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：</p><p><img src="/2022/09/27/ES02/image-20210721203657850.png" alt="image-20210721203657850"></p><h1 id="3-RestClient查询文档"><a href="#3-RestClient查询文档" class="headerlink" title="3.RestClient查询文档"></a>3.RestClient查询文档</h1><p>文档的查询同样适用昨天学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li>1）准备Request对象</li><li>2）准备请求参数</li><li>3）发起请求</li><li>4）解析响应</li></ul><h2 id="3-1-快速入门"><a href="#3-1-快速入门" class="headerlink" title="3.1.快速入门"></a>3.1.快速入门</h2><p>我们以match_all查询为例</p><h3 id="3-1-1-发起查询请求"><a href="#3-1-1-发起查询请求" class="headerlink" title="3.1.1.发起查询请求"></a>3.1.1.发起查询请求</h3><p><img src="/2022/09/27/ES02/image-20210721203950559.png" alt="image-20210721203950559"></p><p>代码解读：</p><ul><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p><p><img src="/2022/09/27/ES02/image-20210721215640790.png" alt="image-20210721215640790"></p><p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p><p><img src="/2022/09/27/ES02/image-20210721215729236.png" alt="image-20210721215729236"></p><h3 id="3-1-2-解析响应"><a href="#3-1-2-解析响应" class="headerlink" title="3.1.2.解析响应"></a>3.1.2.解析响应</h3><p>响应结果的解析：</p><p><img src="/2022/09/27/ES02/image-20210721214221057.png" alt="image-20210721214221057"></p><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li></ul></li></ul></li></ul><h3 id="3-1-3-完整代码"><a href="#3-1-3-完整代码" class="headerlink" title="3.1.3.完整代码"></a>3.1.3.完整代码</h3><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4.小结"></a>3.1.4.小结</h3><p>查询的基本步骤是：</p><ol><li><p>创建SearchRequest对象</p></li><li><p>准备Request.source()，也就是DSL。</p><p>① QueryBuilders来构建查询条件</p><p>② 传入Request.source() 的 query() 方法</p></li><li><p>发送请求，得到结果</p></li><li><p>解析结果（参考JSON结果，从外到内，逐层解析）</p></li></ol><h2 id="3-2-match查询"><a href="#3-2-match查询" class="headerlink" title="3.2.match查询"></a>3.2.match查询</h2><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p><p><img src="/2022/09/27/ES02/image-20210721215923060.png" alt="image-20210721215923060"> </p><p>因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：</p><p><img src="/2022/09/27/ES02/image-20210721215843099.png" alt="image-20210721215843099"> </p><p>而结果解析代码则完全一致，可以抽取并共享。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-精确查询"><a href="#3-3-精确查询" class="headerlink" title="3.3.精确查询"></a>3.3.精确查询</h2><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><p>查询条件构造的API如下：</p><p><img src="/2022/09/27/ES02/image-20210721220305140.png" alt="image-20210721220305140"> </p><h2 id="3-4-布尔查询"><a href="#3-4-布尔查询" class="headerlink" title="3.4.布尔查询"></a>3.4.布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p><p><img src="/2022/09/27/ES02/image-20210721220927286.png" alt="image-20210721220927286"></p><p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;杭州&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-排序、分页"><a href="#3-5-排序、分页" class="headerlink" title="3.5.排序、分页"></a>3.5.排序、分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p><p>对应的API如下：</p><p><img src="/2022/09/27/ES02/image-20210721221121266.png" alt="image-20210721221121266"></p><p>完整代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-高亮"><a href="#3-6-高亮" class="headerlink" title="3.6.高亮"></a>3.6.高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li><li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li></ul><h3 id="3-6-1-高亮请求构建"><a href="#3-6-1-高亮请求构建" class="headerlink" title="3.6.1.高亮请求构建"></a>3.6.1.高亮请求构建</h3><p>高亮请求的构建API如下：</p><p><img src="/2022/09/27/ES02/image-20210721221744883.png" alt="image-20210721221744883"></p><p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-2-高亮结果解析"><a href="#3-6-2-高亮结果解析" class="headerlink" title="3.6.2.高亮结果解析"></a>3.6.2.高亮结果解析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><p>因此解析高亮的代码需要额外处理：</p><p><img src="/2022/09/27/ES02/image-20210721222057212.png" alt="image-20210721222057212"></p><p>代码解读：</p><ul><li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li><li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li><li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hotelDoc = &quot;</span> + hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-旅游案例"><a href="#4-旅游案例" class="headerlink" title="4.旅游案例"></a>4.旅游案例</h1><p>下面，我们通过旅游的案例来实战演练下之前学习的知识。</p><p>我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a href="http://localhost:8090，就能看到项目页面了：">http://localhost:8090，就能看到项目页面了：</a></p><p><img src="/2022/09/27/ES02/image-20210721223159598.png" alt="image-20210721223159598"></p><h2 id="4-1-酒店搜索和分页"><a href="#4-1-酒店搜索和分页" class="headerlink" title="4.1.酒店搜索和分页"></a>4.1.酒店搜索和分页</h2><p>案例需求：实现旅游的酒店搜索功能，完成关键字搜索和分页</p><h3 id="4-1-1-需求分析"><a href="#4-1-1-需求分析" class="headerlink" title="4.1.1.需求分析"></a>4.1.1.需求分析</h3><p>在项目的首页，有一个大大的搜索框，还有分页按钮：</p><p><img src="/2022/09/27/ES02/image-20210721223859419.png" alt="image-20210721223859419"></p><p>点击搜索按钮，可以看到浏览器控制台发出了请求：</p><p><img src="/2022/09/27/ES02/image-20210721224033789.png" alt="image-20210721224033789"></p><p>请求参数如下：</p><p><img src="/2022/09/27/ES02/image-20210721224112708.png" alt="image-20210721224112708"></p><p>由此可以知道，我们这个请求的信息如下：</p><ul><li>请求方式：POST</li><li>请求路径：&#x2F;hotel&#x2F;list</li><li>请求参数：JSON对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li>步骤一：定义实体类，接收请求参数的JSON对象</li><li>步骤二：编写controller，接收页面的请求</li><li>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页</li></ul><h3 id="4-1-2-定义实体类"><a href="#4-1-2-定义实体类" class="headerlink" title="4.1.2.定义实体类"></a>4.1.2.定义实体类</h3><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p><p>1）请求参数</p><p>前端请求的json结构如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索关键字&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sortBy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）返回值</p><p>分页查询，需要返回分页结果PageResult，包含两个属性：</p><ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul><p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.total = total;</span><br><span class="line">        <span class="built_in">this</span>.hotels = hotels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-定义controller"><a href="#4-1-3-定义controller" class="headerlink" title="4.1.3.定义controller"></a>4.1.3.定义controller</h3><p>定义一个HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：&#x2F;hotel&#x2F;list</li><li>请求参数：对象，类型为RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在<code>cn.itheima.hotel.web</code>中定义HotelController：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"><span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-4-实现搜索业务"><a href="#4-1-4-实现搜索业务" class="headerlink" title="4.1.4.实现搜索业务"></a>4.1.4.实现搜索业务</h3><p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。</p><p>1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></table></figure><p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestHighLevelClient <span class="title function_">client</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）在<code>cn.itheima.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="keyword">private</span> PageResult <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line"><span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total, hotels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-酒店结果过滤"><a href="#4-2-酒店结果过滤" class="headerlink" title="4.2.酒店结果过滤"></a>4.2.酒店结果过滤</h2><p>需求：添加品牌、城市、星级、价格等过滤功能</p><h3 id="4-2-1-需求分析"><a href="#4-2-1-需求分析" class="headerlink" title="4.2.1.需求分析"></a>4.2.1.需求分析</h3><p>在页面搜索框下面，会有一些过滤项：</p><p><img src="/2022/09/27/ES02/image-20210722091940726.png" alt="image-20210722091940726"></p><p>传递的参数如图：</p><p><img src="/2022/09/27/ES02/image-20210722092051994.png" alt="image-20210722092051994"> </p><p>包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li>修改请求参数的对象RequestParams，接收上述参数</li><li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li></ul><h3 id="4-2-2-修改实体类"><a href="#4-2-2-修改实体类" class="headerlink" title="4.2.2.修改实体类"></a>4.2.2.修改实体类</h3><p>修改在<code>cn.itheima.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-修改搜索业务"><a href="#4-2-3-修改搜索业务" class="headerlink" title="4.2.3.修改搜索业务"></a>4.2.3.修改搜索业务</h3><p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。</p><p>在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p><ul><li>品牌过滤：是keyword类型，用term查询</li><li>星级过滤：是keyword类型，用term查询</li><li>价格过滤：是数值类型，用range查询</li><li>城市过滤：是keyword类型，用term查询</li></ul><p>多个查询条件组合，肯定是boolean查询来组合：</p><ul><li>关键字搜索放到must中，参与算分</li><li>其它过滤条件放到filter中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：</p><p><img src="/2022/09/27/ES02/image-20210722092935453.png" alt="image-20210722092935453"></p><p>buildBasicQuery的代码如下：</p><p>import org.apache.commons.lang3.StringUtils;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(params.getKey())) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.城市条件</span></span><br><span class="line">    <span class="keyword">if</span> ( !StringUtils.isBlank(params.getCity())) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> ( !StringUtils.isBlank(params.getBrand()) ) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.星级条件</span></span><br><span class="line">    <span class="keyword">if</span> ( !StringUtils.isBlank(params.getStarName()) ) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 6.价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 7.放入source</span></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-我周边的酒店"><a href="#4-3-我周边的酒店" class="headerlink" title="4.3.我周边的酒店"></a>4.3.我周边的酒店</h2><p>需求：我附近的酒店</p><h3 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1.需求分析"></a>4.3.1.需求分析</h3><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：</p><p><img src="/2022/09/27/ES02/image-20210722093414542.png" alt="image-20210722093414542"> </p><p>并且，在前端会发起查询请求，将你的坐标发送到服务端：</p><p><img src="/2022/09/27/ES02/image-20210722093642382.png" alt="image-20210722093642382"> </p><p>我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li>修改RequestParams参数，接收location字段</li><li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li></ul><h3 id="4-3-2-修改实体类"><a href="#4-3-2-修改实体类" class="headerlink" title="4.3.2.修改实体类"></a>4.3.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-3-距离排序API"><a href="#4-3-3-距离排序API" class="headerlink" title="4.3.3.距离排序API"></a>4.3.3.距离排序API</h3><p>我们以前学习过排序功能，包括两种：</p><ul><li>普通字段排序</li><li>地理坐标排序</li></ul><p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;纬度，经度&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;km&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对应的java代码示例：</p><p><img src="/2022/09/27/ES02/image-20210722095227059.png" alt="image-20210722095227059"></p><h3 id="4-3-4-添加距离排序"><a href="#4-3-4-添加距离排序" class="headerlink" title="4.3.4.添加距离排序"></a>4.3.4.添加距离排序</h3><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：</p><p><img src="/2022/09/27/ES02/image-20210722095902314.png" alt="image-20210722095902314"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.排序</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> ( !StringUtils.isBlank(location) ) &#123;</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">&quot;location&quot;</span>, <span class="keyword">new</span> <span class="title class_">GeoPoint</span>(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                                 );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-排序距离显示"><a href="#4-3-5-排序距离显示" class="headerlink" title="4.3.5.排序距离显示"></a>4.3.5.排序距离显示</h3><p>重启服务后，测试我的酒店功能：</p><p><img src="/2022/09/27/ES02/image-20210722100040674.png" alt="image-20210722100040674"></p><p>发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？</p><p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p><p><img src="/2022/09/27/ES02/image-20210722095648542.png" alt="image-20210722095648542"></p><p>因此，我们在结果解析阶段，除了解析source部分以外，还要得到sort部分，也就是排序的距离，然后放到响应结果中。</p><p>我们要做两件事：</p><ul><li>修改HotelDoc，添加排序距离字段，用于页面显示</li><li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li></ul><p>1）修改HotelDoc类，添加距离字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）修改HotelService中的handleResponse方法</p><p><img src="/2022/09/27/ES02/image-20210722100613966.png" alt="image-20210722100613966"></p><p>重启后测试，发现页面能成功显示距离了：</p><p><img src="/2022/09/27/ES02/image-20210722100838604.png" alt="image-20210722100838604"></p><h2 id="4-4-酒店竞价排名"><a href="#4-4-酒店竞价排名" class="headerlink" title="4.4.酒店竞价排名"></a>4.4.酒店竞价排名</h2><p>需求：让指定的酒店在搜索结果中排名置顶</p><h3 id="4-4-1-需求分析"><a href="#4-4-1-需求分析" class="headerlink" title="4.4.1.需求分析"></a>4.4.1.需求分析</h3><p>要让指定酒店在搜索结果中排名置顶，效果如图：</p><p><img src="/2022/09/27/ES02/image-20210722100947292.png" alt="image-20210722100947292"></p><p>页面会给指定的酒店添加<strong>广告</strong>标记。</p><p>那怎样才能让指定的酒店排名置顶呢？</p><p>我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。</p><p>比如，我们给酒店添加一个字段：isAD，Boolean类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样function_score包含3个要素就很好确定了：</p><ul><li>过滤条件：判断isAD 是否为true</li><li>算分函数：我们可以用最简单暴力的weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li><p>给HotelDoc类添加isAD字段，Boolean类型</p></li><li><p>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</p></li><li><p>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</p></li></ol><h3 id="4-4-2-修改HotelDoc实体"><a href="#4-4-2-修改HotelDoc实体" class="headerlink" title="4.4.2.修改HotelDoc实体"></a>4.4.2.修改HotelDoc实体</h3><p>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：</p><p><img src="/2022/09/27/ES02/image-20210722101908062.png" alt="image-20210722101908062"></p><h3 id="4-4-3-添加广告标记"><a href="#4-4-3-添加广告标记" class="headerlink" title="4.4.3.添加广告标记"></a>4.4.3.添加广告标记</h3><p>接下来，我们挑几个酒店，添加isAD字段，设置为true：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">1902197537</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056126831</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST /hotel/_update/<span class="number">1989806195</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056105938</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-4-添加算分函数查询"><a href="#4-4-4-添加算分函数查询" class="headerlink" title="4.4.4.添加算分函数查询"></a>4.4.4.添加算分函数查询</h3><p>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。</p><p>function_score查询结构如下：</p><p><img src="/2022/09/27/ES02/image-20210721191544750.png" alt="image-20210721191544750"></p><p>对应的JavaAPI如下：</p><p><img src="/2022/09/27/ES02/image-20210722102850818.png" alt="image-20210722102850818"></p><p>我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。</p><p>修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> ( StringUtils.isBlank(params.getKey()) ) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> ( !StringUtils.isBlank(params.getCity()) ) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> ( !StringUtils.isBlank(params.getBrand()) ) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 星级条件</span></span><br><span class="line">    <span class="keyword">if</span> ( !StringUtils.isBlank(params.getStarName()) ) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.算分控制</span></span><br><span class="line">    <span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQuery</span> <span class="operator">=</span></span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分的查询</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score的数组</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]&#123;</span><br><span class="line">            <span class="comment">// 其中的一个function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;isAD&quot;</span>, <span class="literal">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line">    request.source().query(functionScoreQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch 分布式搜索引擎(上)</title>
      <link href="/2022/09/27/ES01/"/>
      <url>/2022/09/27/ES01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="分布式搜索引擎01"><a href="#分布式搜索引擎01" class="headerlink" title="分布式搜索引擎01"></a>分布式搜索引擎01</h1><p>– elasticsearch基础</p><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-初识elasticsearch"><a href="#1-初识elasticsearch" class="headerlink" title="1.初识elasticsearch"></a>1.初识elasticsearch</h1><h2 id="1-1-了解ES"><a href="#1-1-了解ES" class="headerlink" title="1.1.了解ES"></a>1.1.了解ES</h2><h3 id="1-1-1-elasticsearch的作用"><a href="#1-1-1-elasticsearch的作用" class="headerlink" title="1.1.1.elasticsearch的作用"></a>1.1.1.elasticsearch的作用</h3><p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p><p>例如：</p><ul><li><p>在GitHub搜索代码</p><p><img src="/2022/09/27/ES01/image-20210720193623245.png" alt="image-20210720193623245"></p></li><li><p>在电商网站搜索商品</p><p><img src="/2022/09/27/ES01/image-20210720193633483.png" alt="image-20210720193633483"></p></li><li><p>在百度搜索答案</p><p><img src="/2022/09/27/ES01/image-20210720193641907.png" alt="image-20210720193641907"></p></li><li><p>在打车软件搜索附近的车</p><p><img src="/2022/09/27/ES01/image-20210720193648044.png" alt="image-20210720193648044"></p></li></ul><h3 id="1-1-2-ELK技术栈"><a href="#1-1-2-ELK技术栈" class="headerlink" title="1.1.2.ELK技术栈"></a>1.1.2.ELK技术栈</h3><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p><p><img src="/2022/09/27/ES01/image-20210720194008781.png" alt="image-20210720194008781"></p><p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p><img src="/2022/09/27/ES01/image-20210720194230265.png" alt="image-20210720194230265"></p><h3 id="1-1-3-elasticsearch和lucene"><a href="#1-1-3-elasticsearch和lucene" class="headerlink" title="1.1.3.elasticsearch和lucene"></a>1.1.3.elasticsearch和lucene</h3><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p><p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p><p><img src="/2022/09/27/ES01/image-20210720194547780.png" alt="image-20210720194547780"></p><p><strong>elasticsearch</strong>的发展历史：</p><ul><li>2004年Shay Banon基于Lucene开发了Compass</li><li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li></ul><p><img src="/2022/09/27/ES01/image-20210720195001221.png" alt="image-20210720195001221"></p><h3 id="1-1-4-为什么不是其他搜索技术？"><a href="#1-1-4-为什么不是其他搜索技术？" class="headerlink" title="1.1.4.为什么不是其他搜索技术？"></a>1.1.4.为什么不是其他搜索技术？</h3><p>目前比较知名的搜索引擎技术排名：</p><p><img src="/2022/09/27/ES01/image-20210720195142535.png" alt="image-20210720195142535"></p><p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p><p><img src="/2022/09/27/ES01/image-20210720195306484.png" alt="image-20210720195306484"></p><h3 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h3><p>什么是elasticsearch？</p><ul><li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li></ul><p>什么是elastic stack（ELK）？</p><ul><li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li></ul><p>什么是Lucene？</p><ul><li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li></ul><h2 id="1-2-倒排索引"><a href="#1-2-倒排索引" class="headerlink" title="1.2.倒排索引"></a>1.2.倒排索引</h2><p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="1-2-1-正向索引"><a href="#1-2-1-正向索引" class="headerlink" title="1.2.1.正向索引"></a>1.2.1.正向索引</h3><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p><p><img src="/2022/09/27/ES01/image-20210720195531539.png" alt="image-20210720195531539"></p><p>如果是根据id查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p><p>1）用户搜索数据，条件是title符合<code>&quot;%手机%&quot;</code></p><p>2）逐行获取数据，比如id为1的数据</p><p>3）判断数据中的title是否符合用户搜索条件</p><p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p><h3 id="1-2-2-倒排索引"><a href="#1-2-2-倒排索引" class="headerlink" title="1.2.2.倒排索引"></a>1.2.2.倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul><p>如图：</p><p><img src="/2022/09/27/ES01/image-20210720200457207.png" alt="image-20210720200457207"></p><p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入内容<strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p><p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p><p>4）拿着文档id到正向索引中查找具体文档。</p><p>如图：</p><p><img src="/2022/09/27/ES01/image-20210720201115192.png" alt="image-20210720201115192"></p><p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p><h3 id="1-2-3-正向和倒排"><a href="#1-2-3-正向和倒排" class="headerlink" title="1.2.3.正向和倒排"></a>1.2.3.正向和倒排</h3><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p></li><li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p></li></ul><p>是不是恰好反过来了？</p><p>那么两者方式的优缺点是什么呢？</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="1-3-es的一些概念"><a href="#1-3-es的一些概念" class="headerlink" title="1.3.es的一些概念"></a>1.3.es的一些概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="1-3-1-文档和字段"><a href="#1-3-1-文档和字段" class="headerlink" title="1.3.1.文档和字段"></a>1.3.1.文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p><p><img src="/2022/09/27/ES01/image-20210720202707797.png" alt="image-20210720202707797"></p><p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><h3 id="1-3-2-索引和映射"><a href="#1-3-2-索引和映射" class="headerlink" title="1.3.2.索引和映射"></a>1.3.2.索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="/2022/09/27/ES01/image-20210720203022172.png" alt="image-20210720203022172"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="1-3-3-mysql与elasticsearch"><a href="#1-3-3-mysql与elasticsearch" class="headerlink" title="1.3.3.mysql与elasticsearch"></a>1.3.3.mysql与elasticsearch</h3><p>我们统一的把mysql与elasticsearch的概念做一下对比：</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p><p>并不是如此，两者各自有自己的擅长支出：</p><ul><li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p></li><li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p></li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="/2022/09/27/ES01/image-20210720203534945.png" alt="image-20210720203534945"></p><h2 id="1-4-安装es、kibana"><a href="#1-4-安装es、kibana" class="headerlink" title="1.4.安装es、kibana"></a>1.4.安装es、kibana</h2><h3 id="1-4-1-安装"><a href="#1-4-1-安装" class="headerlink" title="1.4.1.安装"></a>1.4.1.安装</h3><p>参考课前资料：</p><p><img src="/2022/09/27/ES01/image-20210720203805350.png" alt="image-20210720203805350"> </p><h3 id="1-4-2-分词器"><a href="#1-4-2-分词器" class="headerlink" title="1.4.2.分词器"></a>1.4.2.分词器</h3><p>参考课前资料：</p><p><img src="/2022/09/27/ES01/image-20210720203805350.png" alt="image-20210720203805350"> </p><h3 id="1-4-3-总结"><a href="#1-4-3-总结" class="headerlink" title="1.4.3.总结"></a>1.4.3.总结</h3><p>分词器的作用是什么？</p><ul><li>创建倒排索引时对文档分词</li><li>用户搜索时，对输入的内容分词</li></ul><p>IK分词器有几种模式？</p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><p>IK分词器如何拓展词条？如何停用词条？</p><ul><li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li><li>在词典中添加拓展词条或者停用词条</li></ul><h1 id="2-索引库操作"><a href="#2-索引库操作" class="headerlink" title="2.索引库操作"></a>2.索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p><p>我们要向es中存储数据，必须先创建“库”和“表”。</p><h2 id="2-1-mapping映射属性"><a href="#2-1-mapping映射属性" class="headerlink" title="2.1.mapping映射属性"></a>2.1.mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑马程序员Java讲师&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zy@itcast.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;云&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;赵&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性<ul><li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h2 id="2-2-索引库的CRUD"><a href="#2-2-索引库的CRUD" class="headerlink" title="2.2.索引库的CRUD"></a>2.2.索引库的CRUD</h2><p>这里我们统一使用Kibana编写DSL的方式来演示。</p><h3 id="2-2-1-创建索引库和映射"><a href="#2-2-1-创建索引库和映射" class="headerlink" title="2.2.1.创建索引库和映射"></a>2.2.1.创建索引库和映射</h3><h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><ul><li>请求方式：PUT</li><li>请求路径：&#x2F;索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p>格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT /heima</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;info&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;email&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="string">&quot;index&quot;</span>: <span class="string">&quot;falsae&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;firstName&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // ... 略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-查询索引库"><a href="#2-2-2-查询索引库" class="headerlink" title="2.2.2.查询索引库"></a>2.2.2.查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：&#x2F;索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="/2022/09/27/ES01/image-20210720211019329.png" alt="image-20210720211019329"></p><h3 id="2-2-3-修改索引库"><a href="#2-2-3-修改索引库" class="headerlink" title="2.2.3.修改索引库"></a>2.2.3.修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="/2022/09/27/ES01/image-20210720212357390.png" alt="image-20210720212357390"></p><h3 id="2-2-4-删除索引库"><a href="#2-2-4-删除索引库" class="headerlink" title="2.2.4.删除索引库"></a>2.2.4.删除索引库</h3><p><strong>语法：</strong></p><ul><li><p>请求方式：DELETE</p></li><li><p>请求路径：&#x2F;索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><p>在kibana中测试：</p><p><img src="/2022/09/27/ES01/image-20210720212123420.png" alt="image-20210720212123420"></p><h3 id="2-2-5-总结"><a href="#2-2-5-总结" class="headerlink" title="2.2.5.总结"></a>2.2.5.总结</h3><p>索引库操作有哪些？</p><ul><li>创建索引库：PUT &#x2F;索引库名</li><li>查询索引库：GET &#x2F;索引库名</li><li>删除索引库：DELETE &#x2F;索引库名</li><li>添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li></ul><h1 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3.文档操作"></a>3.文档操作</h1><h2 id="3-1-新增文档"><a href="#3-1-新增文档" class="headerlink" title="3.1.新增文档"></a>3.1.新增文档</h2><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /heima/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑马程序员Java讲师&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zy@itcast.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;云&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;赵&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><p><img src="/2022/09/27/ES01/image-20210720212933362.png" alt="image-20210720212933362"></p><h2 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2.查询文档"></a>3.2.查询文档</h2><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>通过kibana查看数据：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>查看结果：</strong></p><p><img src="/2022/09/27/ES01/image-20210720213345003.png" alt="image-20210720213345003"></p><h2 id="3-3-删除文档"><a href="#3-3-删除文档" class="headerlink" title="3.3.删除文档"></a>3.3.删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /&#123;索引库名&#125;/_doc/id值</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># 根据id删除数据</span><br><span class="line">DELETE /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/2022/09/27/ES01/image-20210720213634918.png" alt="image-20210720213634918"></p><h2 id="3-4-修改文档"><a href="#3-4-修改文档" class="headerlink" title="3.4.修改文档"></a>3.4.修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h3 id="3-4-1-全量修改"><a href="#3-4-1-全量修改" class="headerlink" title="3.4.1.全量修改"></a>3.4.1.全量修改</h3><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /heima/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑马程序员高级Java讲师&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zy@itcast.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;云&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;赵&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2-增量修改"><a href="#3-4-2-增量修改" class="headerlink" title="3.4.2.增量修改"></a>3.4.2.增量修改</h3><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /heima/_update/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZhaoYun@itcast.cn&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5.总结"></a>3.5.总结</h2><p>文档操作有哪些？</p><ul><li>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id   { json文档 }</li><li>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</li><li>修改文档：<ul><li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</li><li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li></ul></li></ul><h1 id="4-RestAPI"><a href="#4-RestAPI" class="headerlink" title="4.RestAPI"></a>4.RestAPI</h1><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的Java Rest Client又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul><p><img src="/2022/09/27/ES01/image-20210720214555863.png" alt="image-20210720214555863"></p><p>我们学习的是Java HighLevel Rest Client客户端API</p><h2 id="4-0-导入Demo工程"><a href="#4-0-导入Demo工程" class="headerlink" title="4.0.导入Demo工程"></a>4.0.导入Demo工程</h2><h3 id="4-0-1-导入数据"><a href="#4-0-1-导入数据" class="headerlink" title="4.0.1.导入数据"></a>4.0.1.导入数据</h3><p>首先导入课前资料提供的数据库数据：</p><p><img src="/2022/09/27/ES01/image-20210720220400297.png" alt="image-20210720220400297"> </p><p>数据结构如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_hotel` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店名称；例：7天酒店&#x27;</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店地址；例：航头路&#x27;</span>,</span><br><span class="line">  `price` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店价格；例：329&#x27;</span>,</span><br><span class="line">  `score` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店评分；例：45，就是4.5分&#x27;</span>,</span><br><span class="line">  `brand` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店品牌；例：如家&#x27;</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;所在城市；例：上海&#x27;</span>,</span><br><span class="line">  `star_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店星级，从低到高分别是：1星到5星，1钻到5钻&#x27;</span>,</span><br><span class="line">  `business` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商圈；例：虹桥&#x27;</span>,</span><br><span class="line">  `latitude` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;纬度；例：31.2497&#x27;</span>,</span><br><span class="line">  `longitude` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;经度；例：120.3925&#x27;</span>,</span><br><span class="line">  `pic` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店图片；例:/img/1.jpg&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="4-0-2-导入项目"><a href="#4-0-2-导入项目" class="headerlink" title="4.0.2.导入项目"></a>4.0.2.导入项目</h3><p>然后导入课前资料提供的项目:</p><p><img src="/2022/09/27/ES01/image-20210720220503411.png" alt="image-20210720220503411"> </p><p>项目结构如图：</p><p><img src="/2022/09/27/ES01/image-20210720220647541.png" alt="image-20210720220647541"></p><h3 id="4-0-3-mapping映射分析"><a href="#4-0-3-mapping映射分析" class="headerlink" title="4.0.3.mapping映射分析"></a>4.0.3.mapping映射分析</h3><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p><ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索</li><li>是否需要分词</li><li>如果分词，分词器是什么？</li></ul><p>其中：</p><ul><li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li><li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li><li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li><li>分词器，我们可以统一使用ik_max_word</li></ul><p>来看下酒店数据的索引库结构:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;all&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;starName&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;business&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li></ul><p>地理坐标说明：</p><p><img src="/2022/09/27/ES01/image-20210720222110126.png" alt="image-20210720222110126"></p><p>copy_to说明：</p><p><img src="/2022/09/27/ES01/image-20210720222221516.png" alt="image-20210720222221516"></p><h3 id="4-0-4-初始化RestClient"><a href="#4-0-4-初始化RestClient" class="headerlink" title="4.0.4.初始化RestClient"></a>4.0.4.初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p><p>分为三步：</p><p>1）引入es的RestHighLevelClient依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）初始化RestHighLevelClient：</p><p>初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelIndexTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-创建索引库"><a href="#4-1-创建索引库" class="headerlink" title="4.1.创建索引库"></a>4.1.创建索引库</h2><h3 id="4-1-1-代码解读"><a href="#4-1-1-代码解读" class="headerlink" title="4.1.1.代码解读"></a>4.1.1.代码解读</h3><p>创建索引库的API如下：</p><p><img src="/2022/09/27/ES01/image-20210720223049408.png" alt="image-20210720223049408"></p><p>代码分为三步：</p><ul><li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul><h3 id="4-1-2-完整示例"><a href="#4-1-2-完整示例" class="headerlink" title="4.1.2.完整示例"></a>4.1.2.完整示例</h3><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelConstants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;address\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;score\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;city\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;copy_to\&quot;: \&quot;all\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;starName\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;business\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;location\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;geo_point\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;pic\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;all\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-删除索引库"><a href="#4-2-删除索引库" class="headerlink" title="4.2.删除索引库"></a>4.2.删除索引库</h2><p>删除索引库的DSL语句非常简单：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel</span><br></pre></td></tr></table></figure><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p><ul><li>1）创建Request对象。这次是DeleteIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用delete方法</li></ul><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-判断索引库是否存在"><a href="#4-3-判断索引库是否存在" class="headerlink" title="4.3.判断索引库是否存在"></a>4.3.判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的。依然是三步走：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用exists方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4.总结"></a>4.4.总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul><h1 id="5-RestClient操作文档"><a href="#5-RestClient操作文档" class="headerlink" title="5.RestClient操作文档"></a>5.RestClient操作文档</h1><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p><ul><li>初始化RestHighLevelClient</li><li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.pojo.Hotel;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDocumentTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-1-新增文档"><a href="#5-1-新增文档" class="headerlink" title="5.1.新增文档"></a>5.1.新增文档</h2><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p><h3 id="5-1-1-索引库实体类"><a href="#5-1-1-索引库实体类" class="headerlink" title="5.1.1.索引库实体类"></a>5.1.1.索引库实体类</h3><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String longitude;</span><br><span class="line">    <span class="keyword">private</span> String latitude;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与我们的索引库结构存在差异：</p><ul><li>longitude和latitude需要合并为location</li></ul><p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-1-2-语法说明"><a href="#5-1-2-语法说明" class="headerlink" title="5.1.2.语法说明"></a>5.1.2.语法说明</h3><p>新增文档的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对应的java代码如图：</p><p><img src="/2022/09/27/ES01/image-20210720230027240.png" alt="image-20210720230027240"></p><p>可以看到与创建索引库类似，同样是三步走：</p><ul><li>1）创建Request对象</li><li>2）准备请求参数，也就是DSL中的JSON文档</li><li>3）发送请求</li></ul><p>变化的地方在于，这里直接使用client.xxx()的API，不再需要client.indices()了。</p><h3 id="5-1-3-完整代码"><a href="#5-1-3-完整代码" class="headerlink" title="5.1.3.完整代码"></a>5.1.3.完整代码</h3><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li><li>hotel对象需要转为HotelDoc对象</li><li>HotelDoc需要序列化为json格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>1）根据id查询酒店数据Hotel</li><li>2）将Hotel封装为HotelDoc</li><li>3）将HotelDoc序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询酒店数据</span></span><br><span class="line">    <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelService.getById(<span class="number">61083L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">    <span class="comment">// 3.将HotelDoc转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(hotelDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-查询文档"><a href="#5-2-查询文档" class="headerlink" title="5.2.查询文档"></a>5.2.查询文档</h2><h3 id="5-2-1-语法说明"><a href="#5-2-1-语法说明" class="headerlink" title="5.2.1.语法说明"></a>5.2.1.语法说明</h3><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>非常简单，因此代码大概分两步：</p><ul><li>准备Request对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p><p><img src="/2022/09/27/ES01/image-20210720230811674.png" alt="image-20210720230811674"></p><p>可以看到，结果是一个JSON，其中文档放在一个<code>_source</code>属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是查询，所以是GetRequest</li><li>2）发送请求，得到结果。因为是查询，这里调用client.get()方法</li><li>3）解析结果，就是对JSON做反序列化</li></ul><h3 id="5-2-2-完整代码"><a href="#5-2-2-完整代码" class="headerlink" title="5.2.2.完整代码"></a>5.2.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61082&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到响应</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line"></span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-删除文档"><a href="#5-3-删除文档" class="headerlink" title="5.3.删除文档"></a>5.3.删除文档</h2><p>删除的DSL为是这样的：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：</p><ul><li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>2）准备参数，无参</li><li>3）发送请求。因为是删除，所以是client.delete()方法</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-修改文档"><a href="#5-4-修改文档" class="headerlink" title="5.4.修改文档"></a>5.4.修改文档</h2><h3 id="5-4-1-语法说明"><a href="#5-4-1-语法说明" class="headerlink" title="5.4.1.语法说明"></a>5.4.1.语法说明</h3><p>修改我们讲过两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>这里不再赘述，我们主要关注增量修改。</p><p>代码示例如图：</p><p><img src="/2022/09/27/ES01/image-20210720231040875.png" alt="image-20210720231040875"></p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是修改，所以是UpdateRequest</li><li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li><li>3）更新文档。这里调用client.update()方法</li></ul><h3 id="5-4-2-完整代码"><a href="#5-4-2-完整代码" class="headerlink" title="5.4.2.完整代码"></a>5.4.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">        <span class="string">&quot;price&quot;</span>, <span class="string">&quot;952&quot;</span>,</span><br><span class="line">        <span class="string">&quot;starName&quot;</span>, <span class="string">&quot;四钻&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-批量导入文档"><a href="#5-5-批量导入文档" class="headerlink" title="5.5.批量导入文档"></a>5.5.批量导入文档</h2><p>案例需求：利用BulkRequest批量将数据库数据导入到索引库中。</p><p>步骤如下：</p><ul><li><p>利用mybatis-plus查询酒店数据</p></li><li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p></li><li><p>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</p></li></ul><h3 id="5-5-1-语法说明"><a href="#5-5-1-语法说明" class="headerlink" title="5.5.1.语法说明"></a>5.5.1.语法说明</h3><p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p><p>其中提供了一个add方法，用来添加其他请求：</p><p><img src="/2022/09/27/ES01/image-20210720232105943.png" alt="image-20210720232105943"></p><p>可以看到，能添加的请求包括：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p><p><img src="/2022/09/27/ES01/image-20210720232431383.png" alt="image-20210720232431383"></p><p>其实还是三步走：</p><ul><li>1）创建Request对象。这里是BulkRequest</li><li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li><li>3）发起请求。这里是批处理，调用的方法为client.bulk()方法</li></ul><p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p><h3 id="5-5-2-完整代码"><a href="#5-5-2-完整代码" class="headerlink" title="5.5.2.完整代码"></a>5.5.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 批量查询酒店数据</span></span><br><span class="line">    List&lt;Hotel&gt; hotels = hotelService.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备参数，添加多个新增的Request</span></span><br><span class="line">    <span class="keyword">for</span> (Hotel hotel : hotels) &#123;</span><br><span class="line">        <span class="comment">// 2.1.转换为文档类型HotelDoc</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">        <span class="comment">// 2.2.创建新增文档的Request对象</span></span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">                    .id(hotelDoc.getId().toString())</span><br><span class="line">                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6.小结"></a>5.6.小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 源码解析</title>
      <link href="/2022/09/27/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/27/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="容器与-bean"><a href="#容器与-bean" class="headerlink" title="容器与 bean"></a>容器与 bean</h2><h3 id="1-容器接口"><a href="#1-容器接口" class="headerlink" title="1) 容器接口"></a>1) 容器接口</h3><ul><li><p>BeanFactory 接口，典型功能有：</p><ul><li>getBean</li></ul></li><li><p>ApplicationContext 接口，是 BeanFactory 的子接口。它扩展了 BeanFactory 接口的功能，如：</p><ul><li>国际化</li><li>通配符方式获取一组 Resource 资源</li><li>整合 Environment 环境（能通过它获取各种来源的配置信息）</li><li>事件发布与监听，实现组件之间的解耦</li></ul></li></ul><p>可以看到，我们课上讲的，都是 BeanFactory 提供的基本功能，ApplicationContext 中的扩展功能都没有用到。</p><h4 id="演示1-BeanFactory-与-ApplicationContext-的区别"><a href="#演示1-BeanFactory-与-ApplicationContext-的区别" class="headerlink" title="演示1 - BeanFactory 与 ApplicationContext 的区别"></a>演示1 - BeanFactory 与 ApplicationContext 的区别</h4><h5 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a01</strong> 包</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.MessageSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.GenericApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ResourceBundleMessageSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.registerBean(<span class="string">&quot;messageSource&quot;</span>, MessageSource.class, () -&gt; &#123;</span><br><span class="line">            <span class="type">ResourceBundleMessageSource</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">            ms.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            ms.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.CHINESE));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.JAPANESE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultSingletonBeanRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BeanFactory 与 ApplicationContext 的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A01.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01.class, args);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1. 到底什么是 BeanFactory</span></span><br><span class="line"><span class="comment">                - 它是 ApplicationContext 的父接口</span></span><br><span class="line"><span class="comment">                - 它才是 Spring 的核心容器, 主要的 ApplicationContext 实现都【组合】了它的功能</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(context);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            2. BeanFactory 能干点啥</span></span><br><span class="line"><span class="comment">                - 表面上只有 getBean</span></span><br><span class="line"><span class="comment">                - 实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能, 都由它的实现类提供</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> DefaultSingletonBeanRegistry.class.getDeclaredField(<span class="string">&quot;singletonObjects&quot;</span>);</span><br><span class="line">        singletonObjects.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);</span><br><span class="line">        map.entrySet().stream().filter(e -&gt; e.getKey().startsWith(<span class="string">&quot;component&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; &#123;</span><br><span class="line">                    System.out.println(e.getKey() + <span class="string">&quot;=&quot;</span> + e.getValue());</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            3. ApplicationContext 比 BeanFactory 多点啥</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.CHINA));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.JAPANESE));</span><br><span class="line"></span><br><span class="line">        Resource[] resources = context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            System.out.println(resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">        System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        context.publishEvent(new UserRegisteredEvent(context));</span></span><br><span class="line">        context.getBean(Component1.class).register();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            4. 学到了什么</span></span><br><span class="line"><span class="comment">                a. BeanFactory 与 ApplicationContext 并不仅仅是简单接口继承的关系, ApplicationContext 组合并扩展了 BeanFactory 的功能</span></span><br><span class="line"><span class="comment">                b. 又新学一种代码之间解耦途径</span></span><br><span class="line"><span class="comment">            练习：完成用户注册与发送短信之间的解耦, 用事件方式、和 AOP 方式分别实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itheima.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEventPublisher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Component1.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;用户注册&quot;</span>);</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisteredEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.EventListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Component2.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">(UserRegisteredEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, event);</span><br><span class="line">        log.debug(<span class="string">&quot;发送短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisteredEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisteredEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡"><a href="#收获💡" class="headerlink" title="收获💡"></a>收获💡</h4><p>通过这个示例结合 debug 查看 ApplicationContext 对象的内部结构，学到：</p><ol><li><p>到底什么是 BeanFactory</p><ul><li>它是 ApplicationContext 的父接口</li><li>它才是 Spring 的核心容器, 主要的 ApplicationContext 实现都【组合】了它的功能，【组合】是指 ApplicationContext 的一个重要成员变量就是 BeanFactory</li></ul></li><li><p>BeanFactory 能干点啥</p><ul><li>表面上只有 getBean</li><li>实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能，都由它的实现类提供</li><li>例子中通过反射查看了它的成员变量 singletonObjects，内部包含了所有的单例 bean</li></ul></li><li><p>ApplicationContext 比 BeanFactory 多点啥</p><ul><li>ApplicationContext 组合并扩展了 BeanFactory 的功能</li><li>国际化、通配符方式获取一组 Resource 资源、整合 Environment 环境、事件发布与监听</li><li>新学一种代码之间解耦途径，事件解耦</li></ul></li></ol><p>建议练习：完成用户注册与发送短信之间的解耦，用事件方式、和 AOP 方式分别实现</p><blockquote><p><em><strong>注意</strong></em></p><ul><li>如果 jdk &gt; 8, 运行时请添加 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED，这是因为这些版本的 jdk 默认不允许跨 module 反射</li><li>事件发布还可以异步，这个视频中没有展示，请自行查阅 @EnableAsync，@Async 的用法</li></ul></blockquote><h4 id="演示2-国际化"><a href="#演示2-国际化" class="headerlink" title="演示2 - 国际化"></a>演示2 - 国际化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMessageSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.registerBean(<span class="string">&quot;messageSource&quot;</span>, MessageSource.class, () -&gt; &#123;</span><br><span class="line">            <span class="type">ResourceBundleMessageSource</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">            ms.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            ms.setBasename(<span class="string">&quot;messages&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.CHINESE));</span><br><span class="line">        System.out.println(context.getMessage(<span class="string">&quot;hi&quot;</span>, <span class="literal">null</span>, Locale.JAPANESE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>国际化文件均在 src&#x2F;resources 目录下</p><p>messages.properties（空）</p><p>messages_en.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hi</span>=<span class="string">Hello</span></span><br></pre></td></tr></table></figure><p>messages_ja.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hi</span>=<span class="string">こんにちは</span></span><br></pre></td></tr></table></figure><p>messages_zh.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hi</span>=<span class="string">你好</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>注意</strong></em></p><ul><li>ApplicationContext 中 MessageSource bean 的名字固定为 messageSource</li><li>使用 SpringBoot 时，国际化文件名固定为 messages</li><li>空的 messages.properties 也必须存在</li></ul></blockquote><h3 id="2-容器实现"><a href="#2-容器实现" class="headerlink" title="2) 容器实现"></a>2) 容器实现</h3><p>Spring 的发展历史较为悠久，因此很多资料还在讲解它较旧的实现，这里出于怀旧的原因，把它们都列出来，供大家参考</p><ul><li>DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现</li><li>ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）</li><li>FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）</li><li>XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）</li><li>AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）</li><li>AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器（新）</li><li>AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器（新）</li><li>AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器（新）</li></ul><p>另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是<strong>组合</strong>了 DefaultListableBeanFactory 的功能，并非继承而来</p><h4 id="演示1-DefaultListableBeanFactory"><a href="#演示1-DefaultListableBeanFactory" class="headerlink" title="演示1 - DefaultListableBeanFactory"></a>演示1 - DefaultListableBeanFactory</h4><h5 id="代码参考-1"><a href="#代码参考-1" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a02.TestBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// bean 的定义（class, scope, 初始化, 销毁）</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(<span class="string">&quot;singleton&quot;</span>).getBeanDefinition();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给 BeanFactory 添加一些常用的后处理器</span></span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanFactory 后处理器主要功能，补充了一些 bean 定义</span></span><br><span class="line">        beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -&gt; &#123;</span><br><span class="line">            beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...</span></span><br><span class="line">        beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()</span><br><span class="line">                .sorted(beanFactory.getDependencyComparator())</span><br><span class="line">                .forEach(beanPostProcessor -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&quot;</span> + beanPostProcessor);</span><br><span class="line">            beanFactory.addBeanPostProcessor(beanPostProcessor);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beanFactory.preInstantiateSingletons(); <span class="comment">// 准备好所有单例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span></span><br><span class="line">        System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            学到了什么:</span></span><br><span class="line"><span class="comment">            a. beanFactory 不会做的事</span></span><br><span class="line"><span class="comment">                   1. 不会主动调用 BeanFactory 后处理器</span></span><br><span class="line"><span class="comment">                   2. 不会主动添加 Bean 后处理器</span></span><br><span class="line"><span class="comment">                   3. 不会主动初始化单例</span></span><br><span class="line"><span class="comment">                   4. 不会解析beanFactory 还不会解析 $&#123; &#125; 与 #&#123; &#125;</span></span><br><span class="line"><span class="comment">            b. bean 后处理器会有排序的逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Common:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Autowired:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean3 <span class="title function_">bean3</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean3</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean4 <span class="title function_">bean4</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean1.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;构造 Bean1()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bean2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="meta">@Resource(name = &quot;bean4&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> Inter bean3;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Inter <span class="title function_">getInter</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bean3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean2.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;构造 Bean2()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="收获💡-1"><a href="#收获💡-1" class="headerlink" title="收获💡"></a>收获💡</h4><ul><li>beanFactory 可以通过 registerBeanDefinition 注册一个 bean definition 对象<ul><li>我们平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中</li><li>bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等</li></ul></li><li>beanFactory 需要手动调用 beanFactory 后处理器对它做增强<ul><li>例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition</li></ul></li><li>beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强<ul><li>例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的</li><li>bean 后处理的添加顺序会对解析结果有影响，见视频中同时加 @Autowired，@Resource 的例子</li></ul></li><li>beanFactory 需要手动调用方法来初始化单例</li><li>beanFactory 需要额外设置才能解析 ${} 与 #{}</li></ul><h4 id="演示2-常见-ApplicationContext-实现"><a href="#演示2-常见-ApplicationContext-实现" class="headerlink" title="演示2 - 常见 ApplicationContext 实现"></a>演示2 - 常见 ApplicationContext 实现</h4><h5 id="代码参考-2"><a href="#代码参考-2" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a02.A02</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.servlet.DispatcherServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    常见 ApplicationContext 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A02.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testClassPathXmlApplicationContext();</span><br><span class="line"><span class="comment">//        testFileSystemXmlApplicationContext();</span></span><br><span class="line"><span class="comment">//        testAnnotationConfigApplicationContext();</span></span><br><span class="line"><span class="comment">//        testAnnotationConfigServletWebServerApplicationContext();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;读取之前...&quot;);</span></span><br><span class="line"><span class="comment">        for (String name : beanFactory.getBeanDefinitionNames()) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;读取之后...&quot;);</span></span><br><span class="line"><span class="comment">        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);</span></span><br><span class="line"><span class="comment">        reader.loadBeanDefinitions(new FileSystemResource(&quot;src\\main\\resources\\a02.xml&quot;));</span></span><br><span class="line"><span class="comment">        for (String name : beanFactory.getBeanDefinitionNames()) &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(name);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            学到了什么</span></span><br><span class="line"><span class="comment">                a. 常见的 ApplicationContext 容器实现</span></span><br><span class="line"><span class="comment">                b. 内嵌容器、DispatcherServlet 的创建方法、作用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️较为经典的容器, 基于 classpath 下 xml 格式的配置文件来创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassPathXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;a02.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️基于磁盘路径下 xml 格式的配置文件来创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(</span><br><span class="line">                        <span class="string">&quot;src\\main\\resources\\a02.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️较为经典的容器, 基于 java 配置类来创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️较为经典的容器, 基于 java 配置类来创建, 用于 web 环境</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Controller <span class="title function_">controller1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">                response.getWriter().print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">            <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">            bean2.setBean1(bean1);</span><br><span class="line">            <span class="keyword">return</span> bean2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Bean1 bean1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.bean1 = bean1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">getBean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> bean1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="收获💡-2"><a href="#收获💡-2" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>常见的 ApplicationContext 容器实现</li><li>内嵌容器、DispatcherServlet 的创建方法、作用</li></ol><h3 id="3-Bean-的生命周期"><a href="#3-Bean-的生命周期" class="headerlink" title="3) Bean 的生命周期"></a>3) Bean 的生命周期</h3><p>一个受 Spring 管理的 bean，生命周期主要阶段有</p><ol><li>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</li><li>依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系</li><li>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</li><li>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）<ul><li>prototype 对象也能够销毁，不过需要容器这边主动调用</li></ul></li></ol><p>一些资料会提到，生命周期中还有一类 bean 后处理器：BeanPostProcessor，会在 bean 的初始化的前后，提供一些扩展逻辑。但这种说法是不完整的，见下面的演示1</p><h4 id="演示1-bean-生命周期"><a href="#演示1-bean-生命周期" class="headerlink" title="演示1 - bean 生命周期"></a>演示1 - bean 生命周期</h4><h5 id="代码参考-3"><a href="#代码参考-3" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a03</strong> 包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">创建 --&gt; 依赖注入</span><br><span class="line">依赖注入 --&gt; 初始化</span><br><span class="line">初始化 --&gt; 可用</span><br><span class="line">可用 --&gt; 销毁</span><br></pre></td></tr></table></figure><p>创建前后的增强</p><ul><li>postProcessBeforeInstantiation<ul><li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li></ul></li><li>postProcessAfterInstantiation<ul><li>这里如果返回 false 会跳过依赖注入阶段</li></ul></li></ul><p>依赖注入前的增强</p><ul><li>postProcessProperties<ul><li>如 @Autowired、@Value、@Resource</li></ul></li></ul><p>初始化前后的增强</p><ul><li>postProcessBeforeInitialization<ul><li>这里返回的对象会替换掉原本的 bean</li><li>如 @PostConstruct、@ConfigurationProperties</li></ul></li><li>postProcessAfterInitialization <ul><li>这里返回的对象会替换掉原本的 bean</li><li>如代理增强</li></ul></li></ul><p>销毁之前的增强</p><ul><li>postProcessBeforeDestruction<ul><li>如 @PreDestroy</li></ul></li></ul><h4 id="收获💡-3"><a href="#收获💡-3" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>Spring bean 生命周期各个阶段</li><li>模板设计模式, 指大流程已经固定好了, 通过接口回调（bean 后处理器）在一些关键点前后提供扩展</li></ol><h4 id="演示2-模板方法设计模式"><a href="#演示2-模板方法设计模式" class="headerlink" title="演示2 - 模板方法设计模式"></a>演示2 - 模板方法设计模式</h4><h5 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">        beanFactory.getBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法  Template Method Pattern</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">            System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean); <span class="comment">// @Autowired, @Resource</span></span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">                processor.inject(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;</span><br><span class="line">            processors.add(processor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>; <span class="comment">// 对依赖注入阶段的扩展</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="演示3-bean-后处理器排序"><a href="#演示3-bean-后处理器排序" class="headerlink" title="演示3 - bean 后处理器排序"></a>演示3 - bean 后处理器排序</h4><h5 id="代码参考-4"><a href="#代码参考-4" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a03.TestProcessOrder</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.PriorityOrdered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    bean 后处理的的排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        List&lt;BeanPostProcessor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(<span class="keyword">new</span> <span class="title class_">P1</span>(), <span class="keyword">new</span> <span class="title class_">P2</span>(), <span class="keyword">new</span> <span class="title class_">P3</span>(), <span class="keyword">new</span> <span class="title class_">P4</span>(), <span class="keyword">new</span> <span class="title class_">P5</span>()));</span><br><span class="line">        list.sort(beanFactory.getDependencyComparator());</span><br><span class="line"></span><br><span class="line">        list.forEach(processor-&gt;&#123;</span><br><span class="line">            processor.postProcessBeforeInitialization(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            学到了什么</span></span><br><span class="line"><span class="comment">                1. 实现了 PriorityOrdered 接口的优先级最高</span></span><br><span class="line"><span class="comment">                2. 实现了 Ordered 接口与加了 @Order 注解的平级, 按数字升序</span></span><br><span class="line"><span class="comment">                3. 其它的排在最后</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P1</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(P1.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;postProcessBeforeInitialization @Order(1)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(2)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P2</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(P2.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;postProcessBeforeInitialization @Order(2)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P3</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, PriorityOrdered &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(P3.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;postProcessBeforeInitialization PriorityOrdered&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P4</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, Ordered &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(P4.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;postProcessBeforeInitialization Ordered&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">P5</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(P5.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;postProcessBeforeInitialization&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="收获💡-4"><a href="#收获💡-4" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>实现了 PriorityOrdered 接口的优先级最高</li><li>实现了 Ordered 接口与加了 @Order 注解的平级, 按数字升序</li><li>其它的排在最后</li></ol><h3 id="4-Bean-后处理器"><a href="#4-Bean-后处理器" class="headerlink" title="4) Bean 后处理器"></a>4) Bean 后处理器</h3><h4 id="演示1-后处理器作用"><a href="#演示1-后处理器作用" class="headerlink" title="演示1 - 后处理器作用"></a>演示1 - 后处理器作用</h4><h5 id="代码参考-5"><a href="#代码参考-5" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a04</strong> 包</p><h4 id="收获💡-5"><a href="#收获💡-5" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成</li><li>每个后处理器各自增强什么功能<ul><li>AutowiredAnnotationBeanPostProcessor 解析 @Autowired 与 @Value</li><li>CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy</li><li>ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties</li></ul></li><li>另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等</li></ol><h4 id="演示2-Autowired-bean-后处理器运行分析"><a href="#演示2-Autowired-bean-后处理器运行分析" class="headerlink" title="演示2 - @Autowired bean 后处理器运行分析"></a>演示2 - @Autowired bean 后处理器运行分析</h4><h5 id="代码参考-6"><a href="#代码参考-6" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a04.DigInAutowired</strong></p><h4 id="收获💡-6"><a href="#收获💡-6" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata</li><li>InjectionMetadata 可以完成依赖注入</li><li>InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型</li><li>有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找</li></ol><h3 id="5-BeanFactory-后处理器"><a href="#5-BeanFactory-后处理器" class="headerlink" title="5) BeanFactory 后处理器"></a>5) BeanFactory 后处理器</h3><h4 id="演示1-BeanFactory-后处理器的作用"><a href="#演示1-BeanFactory-后处理器的作用" class="headerlink" title="演示1 - BeanFactory 后处理器的作用"></a>演示1 - BeanFactory 后处理器的作用</h4><h5 id="代码参考-7"><a href="#代码参考-7" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05</strong> 包</p><ul><li>ConfigurationClassPostProcessor 可以解析<ul><li>@ComponentScan</li><li>@Bean</li><li>@Import</li><li>@ImportResource</li></ul></li><li>MapperScannerConfigurer 可以解析<ul><li>Mapper 接口</li></ul></li></ul><h4 id="收获💡-7"><a href="#收获💡-7" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>@ComponentScan, @Bean, @Mapper 等注解的解析属于核心容器（即 BeanFactory）的扩展功能</li><li>这些扩展功能由不同的 BeanFactory 后处理器来完成，其实主要就是补充了一些 bean 定义</li></ol><h4 id="演示2-模拟解析-ComponentScan"><a href="#演示2-模拟解析-ComponentScan" class="headerlink" title="演示2 - 模拟解析 @ComponentScan"></a>演示2 - 模拟解析 @ComponentScan</h4><h5 id="代码参考-8"><a href="#代码参考-8" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05.ComponentScanPostProcessor</strong></p><h4 id="收获💡-8"><a href="#收获💡-8" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>Spring 操作元数据的工具类 CachingMetadataReaderFactory</li><li>通过注解元数据（AnnotationMetadata）获取直接或间接标注的注解信息</li><li>通过类元数据（ClassMetadata）获取类名，AnnotationBeanNameGenerator 生成 bean 名</li><li>解析元数据是基于 ASM 技术</li></ol><h4 id="演示3-模拟解析-Bean"><a href="#演示3-模拟解析-Bean" class="headerlink" title="演示3 - 模拟解析 @Bean"></a>演示3 - 模拟解析 @Bean</h4><h5 id="代码参考-9"><a href="#代码参考-9" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05.AtBeanPostProcessor</strong></p><h4 id="收获💡-9"><a href="#收获💡-9" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>进一步熟悉注解元数据（AnnotationMetadata）获取方法上注解信息</li></ol><h4 id="演示4-模拟解析-Mapper-接口"><a href="#演示4-模拟解析-Mapper-接口" class="headerlink" title="演示4 - 模拟解析 Mapper 接口"></a>演示4 - 模拟解析 Mapper 接口</h4><h5 id="代码参考-10"><a href="#代码参考-10" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a05.MapperPostProcessor</strong></p><h4 id="收获💡-10"><a href="#收获💡-10" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中</li><li>Spring 的诡异做法，根据接口生成的 BeanDefinition 仅为根据接口名生成 bean 名</li></ol><h3 id="6-Aware-接口"><a href="#6-Aware-接口" class="headerlink" title="6) Aware 接口"></a>6) Aware 接口</h3><h4 id="演示-Aware-接口及-InitializingBean-接口"><a href="#演示-Aware-接口及-InitializingBean-接口" class="headerlink" title="演示 - Aware 接口及 InitializingBean 接口"></a>演示 - Aware 接口及 InitializingBean 接口</h4><h5 id="代码参考-11"><a href="#代码参考-11" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a06</strong> 包</p><h4 id="收获💡-11"><a href="#收获💡-11" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>Aware 接口提供了一种【内置】 的注入手段，例如<ul><li>BeanNameAware 注入 bean 的名字</li><li>BeanFactoryAware 注入 BeanFactory 容器</li><li>ApplicationContextAware 注入 ApplicationContext 容器</li><li>EmbeddedValueResolverAware 注入 ${} 解析器</li></ul></li><li>InitializingBean 接口提供了一种【内置】的初始化手段</li><li>对比<ul><li>内置的注入和初始化不受扩展功能的影响，总会被执行</li><li>而扩展功能受某些情况影响可能会失效</li><li>因此 Spring 框架内部的类常用内置注入和初始化</li></ul></li></ol><h4 id="配置类-Autowired-失效分析"><a href="#配置类-Autowired-失效分析" class="headerlink" title="配置类 @Autowired 失效分析"></a>配置类 @Autowired 失效分析</h4><p>Java 配置类不包含 BeanFactoryPostProcessor 的情况</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant ac as ApplicationContext</span><br><span class="line">participant bfpp as BeanFactoryPostProcessor</span><br><span class="line">participant bpp as BeanPostProcessor</span><br><span class="line">participant config as Java配置类</span><br><span class="line">ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor</span><br><span class="line">ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor</span><br><span class="line">ac -&gt;&gt; +config : 3. 创建和初始化</span><br><span class="line">bpp -&gt;&gt; config : 3.1 依赖注入扩展(如 @Value 和 @Autowired)</span><br><span class="line">bpp -&gt;&gt; config : 3.2 初始化扩展(如 @PostConstruct)</span><br><span class="line">ac -&gt;&gt; config : 3.3 执行 Aware 及 InitializingBean</span><br><span class="line">config --&gt;&gt; -ac : 3.4 创建成功</span><br></pre></td></tr></table></figure><p>Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant ac as ApplicationContext</span><br><span class="line">participant bfpp as BeanFactoryPostProcessor</span><br><span class="line">participant bpp as BeanPostProcessor</span><br><span class="line">participant config as Java配置类</span><br><span class="line">ac -&gt;&gt; +config : 3. 创建和初始化</span><br><span class="line">ac -&gt;&gt; config : 3.1 执行 Aware 及 InitializingBean</span><br><span class="line">config --&gt;&gt; -ac : 3.2 创建成功</span><br><span class="line"></span><br><span class="line">ac -&gt;&gt; bfpp : 1. 执行 BeanFactoryPostProcessor</span><br><span class="line">ac -&gt;&gt; bpp : 2. 注册 BeanPostProcessor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyConfig1.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//  ⬅️ 注释或添加 beanFactory 后处理器对应上方两种情况</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;执行 processor1&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>注意</strong></em></p><p>解决方法：</p><ul><li>用内置依赖注入和初始化取代扩展依赖注入和初始化</li><li>用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建</li></ul></blockquote><h3 id="7-初始化与销毁"><a href="#7-初始化与销毁" class="headerlink" title="7) 初始化与销毁"></a>7) 初始化与销毁</h3><h4 id="演示-初始化销毁顺序"><a href="#演示-初始化销毁顺序" class="headerlink" title="演示 - 初始化销毁顺序"></a>演示 - 初始化销毁顺序</h4><h5 id="代码参考-12"><a href="#代码参考-12" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a07</strong> 包</p><h4 id="收获💡-12"><a href="#收获💡-12" class="headerlink" title="收获💡"></a>收获💡</h4><p>Spring 提供了多种初始化手段，除了课堂上讲的 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是</p><ol><li>@PostConstruct 标注的初始化方法</li><li>InitializingBean 接口的初始化方法</li><li>@Bean(initMethod) 指定的初始化方法</li></ol><p>与初始化类似，Spring 也提供了多种销毁手段，执行顺序为</p><ol><li>@PreDestroy 标注的销毁方法</li><li>DisposableBean 接口的销毁方法</li><li>@Bean(destroyMethod) 指定的销毁方法</li></ol><h3 id="8-Scope"><a href="#8-Scope" class="headerlink" title="8) Scope"></a>8) Scope</h3><p>在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope</p><ul><li>singleton，容器启动时创建（未设置延迟），容器关闭时销毁</li><li>prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁</li><li>request，每次请求用到此 bean 时创建，请求结束时销毁</li><li>session，每个会话用到此 bean 时创建，会话结束时销毁</li><li>application，web 容器用到此 bean 时创建，容器停止时销毁</li></ul><p>有些文章提到有 globalSession 这一 Scope，也是陈旧的说法，目前 Spring 中已废弃</p><p>但要注意，如果在 singleton 注入其它 scope 都会有问题，解决方法有</p><ul><li>@Lazy</li><li>@Scope(proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</li><li>ObjectFactory</li><li>ApplicationContext.getBean</li></ul><h4 id="演示1-request-session-application-作用域"><a href="#演示1-request-session-application-作用域" class="headerlink" title="演示1 - request, session, application 作用域"></a>演示1 - request, session, application 作用域</h4><h5 id="代码参考-13"><a href="#代码参考-13" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a08</strong> 包</p><ul><li>打开不同的浏览器, 刷新 <a href="http://localhost:8080/test">http://localhost:8080/test</a> 即可查看效果</li><li>如果 jdk &gt; 8, 运行时请添加 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li></ul><h4 id="收获💡-13"><a href="#收获💡-13" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>有几种 scope</li><li>在 singleton 中使用其它几种 scope 的方法</li><li>其它 scope 的销毁时机<ul><li>可以将通过 server.servlet.session.timeout&#x3D;30s 观察 session bean 的销毁</li><li>ServletContextScope 销毁机制疑似实现有误</li></ul></li></ol><h4 id="分析-singleton-注入其它-scope-失效"><a href="#分析-singleton-注入其它-scope-失效" class="headerlink" title="分析 - singleton 注入其它 scope 失效"></a>分析 - singleton 注入其它 scope 失效</h4><p>以单例注入多例为例</p><p>有一个单例对象 E</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(E.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> F f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;E()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setF</span><span class="params">(F f)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.f = f;</span><br><span class="line">        log.info(<span class="string">&quot;setF(F f) &#123;&#125;&quot;</span>, f.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> F <span class="title function_">getF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注入的对象 F 期望是多例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(F.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">F</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;F()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"><span class="type">F</span> <span class="variable">f1</span> <span class="operator">=</span> e.getF();</span><br><span class="line"><span class="type">F</span> <span class="variable">f2</span> <span class="operator">=</span> e.getF();</span><br><span class="line">System.out.println(f1);</span><br><span class="line">System.out.println(f2);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.itheima.demo.cycle.F@6622fc65</span><br><span class="line">com.itheima.demo.cycle.F@6622fc65</span><br></pre></td></tr></table></figure><p>发现它们是同一个对象，而不是期望的多例对象</p><p>对于单例对象来讲，依赖注入仅发生了一次，后续再没有用到多例的 F，因此 E 用的始终是第一次依赖注入的 F</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">e1(e 创建)</span><br><span class="line">e2(e set 注入 f)</span><br><span class="line"></span><br><span class="line">f1(f 创建)</span><br><span class="line"></span><br><span class="line">e1--&gt;f1--&gt;e2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决</p><ul><li>仍然使用 @Lazy 生成代理</li><li>代理对象虽然还是同一个，但当每次<strong>使用代理对象的任意方法</strong>时，由代理创建新的 f 对象</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">e1(e 创建)</span><br><span class="line">e2(e set 注入 f代理)</span><br><span class="line"></span><br><span class="line">f1(f 创建)</span><br><span class="line">f2(f 创建)</span><br><span class="line">f3(f 创建)</span><br><span class="line"></span><br><span class="line">e1--&gt;e2</span><br><span class="line">e2--使用f方法--&gt;f1</span><br><span class="line">e2--使用f方法--&gt;f2</span><br><span class="line">e2--使用f方法--&gt;f3</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setF</span><span class="params">(F f)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.f = f;</span><br><span class="line">        log.info(<span class="string">&quot;setF(F f) &#123;&#125;&quot;</span>, f.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>注意</strong></em></p><ul><li>@Lazy 加在也可以加在成员变量上，但加在 set 方法上的目的是可以观察输出，加在成员变量上就不行了</li><li>@Autowired 加在 set 方法的目的类似</li></ul></blockquote><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: setF(F f) class com.itheima.demo.cycle.F$$EnhancerBySpringCGLIB$$8b54f2bc</span><br><span class="line">F: F()</span><br><span class="line">com.itheima.demo.cycle.F@3a6f2de3</span><br><span class="line">F: F()</span><br><span class="line">com.itheima.demo.cycle.F@56303b57</span><br></pre></td></tr></table></figure><p>从输出日志可以看到调用 setF 方法时，f 对象的类型是代理类型</p><h4 id="演示2-4种解决方法"><a href="#演示2-4种解决方法" class="headerlink" title="演示2 - 4种解决方法"></a>演示2 - 4种解决方法</h4><h5 id="代码参考-14"><a href="#代码参考-14" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a08.sub</strong> 包</p><ul><li>如果 jdk &gt; 8, 运行时请添加 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li></ul><h4 id="收获💡-14"><a href="#收获💡-14" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>单例注入其它 scope 的四种解决方法<ul><li>@Lazy</li><li>@Scope(value &#x3D; “prototype”, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</li><li>ObjectFactory</li><li>ApplicationContext</li></ul></li><li>解决方法虽然不同，但理念上殊途同归: 都是推迟其它 scope bean 的获取</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p><p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p><ul><li><p>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中</p></li><li><p>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能</p></li><li><p>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</p></li></ul><p>简单比较的话：</p><ul><li>aspectj 在编译和加载时，修改目标字节码，性能较高</li><li>aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li><li>但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行</li></ul><h3 id="9-AOP-实现之-ajc-编译器"><a href="#9-AOP-实现之-ajc-编译器" class="headerlink" title="9) AOP 实现之 ajc 编译器"></a>9) AOP 实现之 ajc 编译器</h3><p>代码参考项目 <strong>demo6_advanced_aspectj_01</strong></p><h4 id="收获💡-15"><a href="#收获💡-15" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>编译器也能修改 class 实现增强</li><li>编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强</li></ol><blockquote><p><em><strong>注意</strong></em></p><ul><li>版本选择了 java 8, 因为目前的 aspectj-maven-plugin 1.14.0 最高只支持到 java 16</li><li>一定要用 maven 的 compile 来编译, idea 不会调用 ajc 编译器</li></ul></blockquote><h3 id="10-AOP-实现之-agent-类加载"><a href="#10-AOP-实现之-agent-类加载" class="headerlink" title="10) AOP 实现之 agent 类加载"></a>10) AOP 实现之 agent 类加载</h3><p>代码参考项目 <strong>demo6_advanced_aspectj_02</strong></p><h4 id="收获💡-16"><a href="#收获💡-16" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>类加载时可以通过 agent 修改 class 实现增强</li></ol><h3 id="11-AOP-实现之-proxy"><a href="#11-AOP-实现之-proxy" class="headerlink" title="11) AOP 实现之 proxy"></a>11) AOP 实现之 proxy</h3><h4 id="演示1-jdk-动态代理"><a href="#演示1-jdk-动态代理" class="headerlink" title="演示1 - jdk 动态代理"></a>演示1 - jdk 动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(</span><br><span class="line">                Target.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;,</span><br><span class="line">                (p, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy before...</span><br><span class="line">target foo</span><br><span class="line">proxy after...</span><br></pre></td></tr></table></figure><h4 id="收获💡-17"><a href="#收获💡-17" class="headerlink" title="收获💡"></a>收获💡</h4><ul><li>jdk 动态代理要求目标<strong>必须</strong>实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系</li></ul><h4 id="演示2-cglib-代理"><a href="#演示2-cglib-代理" class="headerlink" title="演示2 - cglib 代理"></a>演示2 - cglib 代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, </span><br><span class="line">                (MethodInterceptor) (p, method, args, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invoke(target, args);</span><br><span class="line">            <span class="comment">// 另一种调用方法，不需要目标对象实例</span></span><br><span class="line"><span class="comment">//            Object result = methodProxy.invokeSuper(p, args);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 调用代理</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果与 jdk 动态代理相同</p><h4 id="收获💡-18"><a href="#收获💡-18" class="headerlink" title="收获💡"></a>收获💡</h4><ul><li>cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系</li><li>限制⛔：根据上述分析 final 类无法被 cglib 增强</li></ul><h3 id="12-jdk-动态代理进阶"><a href="#12-jdk-动态代理进阶" class="headerlink" title="12) jdk 动态代理进阶"></a>12) jdk 动态代理进阶</h3><h4 id="演示1-模拟-jdk-动态代理"><a href="#演示1-模拟-jdk-动态代理" class="headerlink" title="演示1 - 模拟 jdk 动态代理"></a>演示1 - 模拟 jdk 动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A12</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] param)</span> &#123;</span><br><span class="line">        <span class="comment">// ⬇️1. 创建代理，这时传入 InvocationHandler</span></span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;    </span><br><span class="line">            <span class="comment">// ⬇️5. 进入 InvocationHandler</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                <span class="comment">// ⬇️6. 功能增强</span></span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="comment">// ⬇️7. 反射调用目标方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// ⬇️2. 调用代理方法</span></span><br><span class="line">        proxy.foo();</span><br><span class="line">        proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟代理实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⬇️这就是 jdk 代理类的源码, 秘密都在里面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A12</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ⬇️3. 进入代理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ⬇️4. 回调 InvocationHandler</span></span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = A12.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            bar = A12.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-19"><a href="#收获💡-19" class="headerlink" title="收获💡"></a>收获💡</h4><p>代理一点都不难，无非就是利用了多态、反射的知识</p><ol><li>方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部</li><li>通过接口回调将【增强逻辑】置于代理类之外</li><li>配合接口方法反射（是多态调用），就可以再联动调用目标方法</li><li>会用 arthas 的 jad 工具反编译代理类</li><li>限制⛔：代理增强是借助多态来实现，因此成员变量、静态方法、final 方法均不能通过代理实现</li></ol><h4 id="演示2-方法反射优化"><a href="#演示2-方法反射优化" class="headerlink" title="演示2 - 方法反射优化"></a>演示2 - 方法反射优化</h4><h5 id="代码参考-15"><a href="#代码参考-15" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a12.TestMethodInvoke</strong></p><h4 id="收获💡-20"><a href="#收获💡-20" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>前 16 次反射性能较低</li><li>第 17 次调用会生成代理类，优化为非反射调用</li><li>会用 arthas 的 jad 工具反编译第 17 次调用生成的代理类</li></ol><blockquote><p><em><strong>注意</strong></em></p><p>运行时请添加 –add-opens java.base&#x2F;java.lang.reflect&#x3D;ALL-UNNAMED –add-opens java.base&#x2F;jdk.internal.reflect&#x3D;ALL-UNNAMED</p></blockquote><h3 id="13-cglib-代理进阶"><a href="#13-cglib-代理进阶" class="headerlink" title="13) cglib 代理进阶"></a>13) cglib 代理进阶</h3><h4 id="演示-模拟-cglib-代理"><a href="#演示-模拟-cglib-代理" class="headerlink" title="演示 - 模拟 cglib 代理"></a>演示 - 模拟 cglib 代理</h4><h5 id="代码参考-16"><a href="#代码参考-16" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a13</strong> 包</p><h4 id="收获💡-21"><a href="#收获💡-21" class="headerlink" title="收获💡"></a>收获💡</h4><p>和 jdk 动态代理原理查不多</p><ol><li>回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor</li><li>调用目标时有所改进，见下面代码片段<ol><li>method.invoke 是反射调用，必须调用到足够次数才会进行优化</li><li>methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）</li><li>methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A14Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        </span><br><span class="line">        proxy.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;(MethodInterceptor) (p, m, a, mp) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;proxy before...&quot;</span> + mp.getSignature());</span><br><span class="line">            <span class="comment">// ⬇️调用目标方法(三种)</span></span><br><span class="line"><span class="comment">//            Object result = m.invoke(target, a);  // ⬅️反射调用</span></span><br><span class="line"><span class="comment">//            Object result = mp.invoke(target, a); // ⬅️非反射调用, 结合目标用</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> mp.invokeSuper(p, a);   <span class="comment">// ⬅️非反射调用, 结合代理用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;proxy after...&quot;</span> + mp.getSignature());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️调用代理方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>注意</strong></em></p><ul><li>调用 Object 的方法, 后两种在 jdk &gt;&#x3D; 9 时都有问题, 需要 –add-opens java.base&#x2F;java.lang&#x3D;ALL-UNNAMED</li></ul></blockquote><h3 id="14-cglib-避免反射调用"><a href="#14-cglib-避免反射调用" class="headerlink" title="14) cglib 避免反射调用"></a>14) cglib 避免反射调用</h3><h4 id="演示-cglib-如何避免反射"><a href="#演示-cglib-如何避免反射" class="headerlink" title="演示 - cglib 如何避免反射"></a>演示 - cglib 如何避免反射</h4><h5 id="代码参考-17"><a href="#代码参考-17" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a13.ProxyFastClass</strong>，<strong>com.itheima.a13.TargetFastClass</strong></p><h4 id="收获💡-22"><a href="#收获💡-22" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类<ul><li>ProxyFastClass 配合代理对象一起使用, 避免反射</li><li>TargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)</li></ul></li><li>TargetFastClass 记录了 Target 中方法与编号的对应关系<ul><li>save(long) 编号 2</li><li>save(int) 编号 1</li><li>save() 编号 0</li><li>首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号</li><li>然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射</li></ul></li><li>ProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法<ul><li>saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)</li><li>saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)</li><li>saveSuper() 编号 0，不增强, 仅是调用 super.save()</li><li>查找方式与 TargetFastClass 类似</li></ul></li><li>为什么有这么麻烦的一套东西呢？<ul><li>避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法</li><li>用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死</li></ul></li></ol><h3 id="15-jdk-和-cglib-在-Spring-中的统一"><a href="#15-jdk-和-cglib-在-Spring-中的统一" class="headerlink" title="15) jdk 和 cglib 在 Spring 中的统一"></a>15) jdk 和 cglib 在 Spring 中的统一</h3><p>Spring 中对切点、通知、切面的抽象如下</p><ul><li>切点：接口 Pointcut，典型实现 AspectJExpressionPointcut</li><li>通知：典型接口为 MethodInterceptor 代表环绕通知</li><li>切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">class Advice</span><br><span class="line">class MethodInterceptor</span><br><span class="line">class Advisor</span><br><span class="line">class PointcutAdvisor</span><br><span class="line"></span><br><span class="line">Pointcut &lt;|-- AspectJExpressionPointcut</span><br><span class="line">Advice &lt;|-- MethodInterceptor</span><br><span class="line">Advisor &lt;|-- PointcutAdvisor</span><br><span class="line">PointcutAdvisor o-- &quot;一&quot; Pointcut</span><br><span class="line">PointcutAdvisor o-- &quot;一&quot; Advice</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advice</span><br><span class="line">&lt;&lt;interface&gt;&gt; MethodInterceptor</span><br><span class="line">&lt;&lt;interface&gt;&gt; Pointcut</span><br><span class="line">&lt;&lt;interface&gt;&gt; Advisor</span><br><span class="line">&lt;&lt;interface&gt;&gt; PointcutAdvisor</span><br></pre></td></tr></table></figure><p>代理相关类图</p><ul><li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li><li>AopProxy 通过 getProxy 创建代理对象</li><li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li><li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Advised &lt;|-- ProxyFactory</span><br><span class="line">ProxyFactory o-- Target</span><br><span class="line">ProxyFactory o-- &quot;多&quot; Advisor</span><br><span class="line"></span><br><span class="line">ProxyFactory --&gt; AopProxyFactory : 使用</span><br><span class="line">AopProxyFactory --&gt; AopProxy</span><br><span class="line">Advised &lt;|-- 基于CGLIB的Proxy</span><br><span class="line">基于CGLIB的Proxy &lt;-- ObjenesisCglibAopProxy : 创建</span><br><span class="line">AopProxy &lt;|-- ObjenesisCglibAopProxy</span><br><span class="line">AopProxy &lt;|-- JdkDynamicAopProxy</span><br><span class="line">基于JDK的Proxy &lt;-- JdkDynamicAopProxy : 创建</span><br><span class="line">Advised &lt;|-- 基于JDK的Proxy</span><br><span class="line"></span><br><span class="line">class AopProxy &#123;</span><br><span class="line">   +getProxy() Object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyFactory &#123;</span><br><span class="line">proxyTargetClass : boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ObjenesisCglibAopProxy &#123;</span><br><span class="line">advised : ProxyFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class JdkDynamicAopProxy &#123;</span><br><span class="line">advised : ProxyFactory</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Advised</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxyFactory</span><br><span class="line">&lt;&lt;interface&gt;&gt; AopProxy</span><br></pre></td></tr></table></figure><h4 id="演示-底层切点、通知、切面"><a href="#演示-底层切点、通知、切面" class="headerlink" title="演示 - 底层切点、通知、切面"></a>演示 - 底层切点、通知、切面</h4><h5 id="代码参考-18"><a href="#代码参考-18" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a15.A15</strong></p><h4 id="收获💡-23"><a href="#收获💡-23" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>底层的切点实现</li><li>底层的通知实现</li><li>底层的切面实现</li><li>ProxyFactory 用来创建代理<ul><li>如果指定了接口，且 proxyTargetClass &#x3D; false，使用 JdkDynamicAopProxy</li><li>如果没有指定接口，或者 proxyTargetClass &#x3D; true，使用 ObjenesisCglibAopProxy<ul><li>例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy</li></ul></li></ul></li></ol><blockquote><p><em><strong>注意</strong></em></p><ul><li>要区分本章节提到的 MethodInterceptor，它与之前 cglib 中用的的 MethodInterceptor 是不同的接口</li></ul></blockquote><h3 id="16-切点匹配"><a href="#16-切点匹配" class="headerlink" title="16) 切点匹配"></a>16) 切点匹配</h3><h4 id="演示-切点匹配"><a href="#演示-切点匹配" class="headerlink" title="演示 - 切点匹配"></a>演示 - 切点匹配</h4><h5 id="代码参考-19"><a href="#代码参考-19" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a16.A16</strong></p><h4 id="收获💡-24"><a href="#收获💡-24" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>常见 aspectj 切点用法</li><li>aspectj 切点的局限性，实际的 @Transactional 切点实现</li></ol><h3 id="17-从-Aspect-到-Advisor"><a href="#17-从-Aspect-到-Advisor" class="headerlink" title="17) 从 @Aspect 到 Advisor"></a>17) 从 @Aspect 到 Advisor</h3><h4 id="演示1-代理创建器"><a href="#演示1-代理创建器" class="headerlink" title="演示1 - 代理创建器"></a>演示1 - 代理创建器</h4><h5 id="代码参考-20"><a href="#代码参考-20" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy</strong> 包</p><h4 id="收获💡-25"><a href="#收获💡-25" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>AnnotationAwareAspectJAutoProxyCreator 的作用<ul><li>将高级 @Aspect 切面统一为低级 Advisor 切面</li><li>在合适的时机创建代理</li></ul></li><li>findEligibleAdvisors 找到有【资格】的 Advisors<ul><li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li><li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得</li></ul></li><li>wrapIfNecessary<ul><li>它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理</li><li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li></ul></li></ol><h4 id="演示2-代理创建时机"><a href="#演示2-代理创建时机" class="headerlink" title="演示2 - 代理创建时机"></a>演示2 - 代理创建时机</h4><h5 id="代码参考-21"><a href="#代码参考-21" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy.A17_1</strong></p><h4 id="收获💡-26"><a href="#收获💡-26" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>代理的创建时机<ul><li>初始化之后 (无循环依赖时)</li><li>实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存</li></ul></li><li>依赖注入与初始化不应该被增强, 仍应被施加于原始对象</li></ol><h4 id="演示3-Before-对应的低级通知"><a href="#演示3-Before-对应的低级通知" class="headerlink" title="演示3 - @Before 对应的低级通知"></a>演示3 - @Before 对应的低级通知</h4><h5 id="代码参考-22"><a href="#代码参考-22" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy.A17_2</strong></p><h4 id="收获💡-27"><a href="#收获💡-27" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>@Before 前置通知会被转换为原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息<ol><li>通知代码从哪儿来</li><li>切点是什么(这里为啥要切点, 后面解释)</li><li>通知对象如何创建, 本例共用同一个 Aspect 对象</li></ol></li><li>类似的还有<ol><li>AspectJAroundAdvice (环绕通知)</li><li>AspectJAfterReturningAdvice</li><li>AspectJAfterThrowingAdvice (环绕通知)</li><li>AspectJAfterAdvice (环绕通知)</li></ol></li></ol><h3 id="18-静态通知调用"><a href="#18-静态通知调用" class="headerlink" title="18) 静态通知调用"></a>18) 静态通知调用</h3><p>代理对象调用流程如下（以 JDK 动态代理实现为例）</p><ul><li>从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation，简称 mi</li><li>首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法</li><li>目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强</li><li>环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强</li><li>环绕通知1返回最终的结果</li></ul><p>图中不同颜色对应一次环绕通知或目标的调用起始至终结</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant Proxy</span><br><span class="line">participant ih as InvocationHandler</span><br><span class="line">participant mi as MethodInvocation</span><br><span class="line">participant Factory as ProxyFactory</span><br><span class="line">participant mi1 as MethodInterceptor1</span><br><span class="line">participant mi2 as MethodInterceptor2</span><br><span class="line">participant Target</span><br><span class="line"></span><br><span class="line">Proxy -&gt;&gt; +ih : invoke()</span><br><span class="line">ih -&gt;&gt; +Factory : 获得 Target</span><br><span class="line">Factory --&gt;&gt; -ih : </span><br><span class="line">ih -&gt;&gt; +Factory : 获得 MethodInterceptor 链</span><br><span class="line">Factory --&gt;&gt; -ih : </span><br><span class="line">ih -&gt;&gt; +mi : 创建 mi</span><br><span class="line">mi --&gt;&gt; -ih : </span><br><span class="line">rect rgb(200, 223, 255)</span><br><span class="line">ih -&gt;&gt; +mi : mi.proceed()</span><br><span class="line">mi -&gt;&gt; +mi1 : invoke(mi)</span><br><span class="line">mi1 -&gt;&gt; mi1 : 前增强</span><br><span class="line">rect rgb(200, 190, 255)</span><br><span class="line">mi1 -&gt;&gt; mi : mi.proceed()</span><br><span class="line">mi -&gt;&gt; +mi2 : invoke(mi)</span><br><span class="line">mi2 -&gt;&gt; mi2 : 前增强</span><br><span class="line">rect rgb(150, 190, 155)</span><br><span class="line">mi2 -&gt;&gt; mi : mi.proceed()</span><br><span class="line">mi -&gt;&gt; +Target : mi.invokeJoinPoint()</span><br><span class="line">Target -&gt;&gt; Target : </span><br><span class="line">Target --&gt;&gt; -mi2 : 结果</span><br><span class="line">end</span><br><span class="line">mi2 -&gt;&gt; mi2 : 后增强</span><br><span class="line">mi2 --&gt;&gt; -mi1 : 结果</span><br><span class="line">end</span><br><span class="line">mi1 -&gt;&gt; mi1 : 后增强</span><br><span class="line">mi1 --&gt;&gt; -mi : 结果</span><br><span class="line">mi --&gt;&gt; -ih : </span><br><span class="line">end</span><br><span class="line">ih --&gt;&gt; -Proxy : </span><br></pre></td></tr></table></figure><h4 id="演示1-通知调用过程"><a href="#演示1-通知调用过程" class="headerlink" title="演示1 - 通知调用过程"></a>演示1 - 通知调用过程</h4><h5 id="代码参考-23"><a href="#代码参考-23" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.A18</strong></p><h4 id="收获💡-28"><a href="#收获💡-28" class="headerlink" title="收获💡"></a>收获💡</h4><p>代理方法执行时会做如下工作</p><ol><li>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知<ul><li>MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor</li><li>AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor</li><li>这体现的是适配器设计模式</li></ul></li><li>所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可</li><li>结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用</li></ol><h4 id="演示2-模拟-MethodInvocation"><a href="#演示2-模拟-MethodInvocation" class="headerlink" title="演示2 - 模拟 MethodInvocation"></a>演示2 - 模拟 MethodInvocation</h4><h5 id="代码参考-24"><a href="#代码参考-24" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.A18_1</strong></p><h4 id="收获💡-29"><a href="#收获💡-29" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>proceed() 方法调用链中下一个环绕通知</li><li>每个环绕通知内部继续调用 proceed()</li><li>调用到没有更多通知了, 就调用目标方法</li></ol><p>MethodInvocation 的编程技巧在实现拦截器、过滤器时能用上</p><h3 id="19-动态通知调用"><a href="#19-动态通知调用" class="headerlink" title="19) 动态通知调用"></a>19) 动态通知调用</h3><h4 id="演示-带参数绑定的通知方法调用"><a href="#演示-带参数绑定的通知方法调用" class="headerlink" title="演示 - 带参数绑定的通知方法调用"></a>演示 - 带参数绑定的通知方法调用</h4><h5 id="代码参考-25"><a href="#代码参考-25" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.aop.framework.autoproxy.A19</strong></p><h4 id="收获💡-30"><a href="#收获💡-30" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知</li><li>所谓动态通知，体现在上面方法的 DynamicInterceptionAdvice 部分，这些通知调用时因为要为通知方法绑定参数，还需再次利用切点表达式</li><li>动态通知调用复杂程度高，性能较低</li></ol><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="20-RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter"><a href="#20-RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter" class="headerlink" title="20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter"></a>20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</h3><p>RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter 俩是一对，分别用来</p><ul><li>处理 @RequestMapping 映射</li><li>调用控制器方法、并处理方法参数与方法返回值</li></ul><h4 id="演示1-DispatcherServlet-初始化"><a href="#演示1-DispatcherServlet-初始化" class="headerlink" title="演示1 - DispatcherServlet 初始化"></a>演示1 - DispatcherServlet 初始化</h4><h5 id="代码参考-26"><a href="#代码参考-26" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a20</strong> 包</p><h4 id="收获💡-31"><a href="#收获💡-31" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>DispatcherServlet 是在第一次被访问时执行初始化, 也可以通过配置修改为 Tomcat 启动后就初始化</li><li>在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 HandlerMapping、HandlerAdapter 等，并逐一调用它们的初始化</li><li>RequestMappingHandlerMapping 初始化时，会收集所有 @RequestMapping 映射信息，封装为 Map，其中<ul><li>key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息</li><li>value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象</li><li>有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet</li></ul></li><li>RequestMappingHandlerAdapter 初始化时，会准备 HandlerMethod 调用时需要的各个组件，如：<ul><li>HandlerMethodArgumentResolver 解析控制器方法参数</li><li>HandlerMethodReturnValueHandler 处理控制器方法返回值</li></ul></li></ol><h4 id="演示2-自定义参数与返回值处理器"><a href="#演示2-自定义参数与返回值处理器" class="headerlink" title="演示2 - 自定义参数与返回值处理器"></a>演示2 - 自定义参数与返回值处理器</h4><h5 id="代码参考-27"><a href="#代码参考-27" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a20.TokenArgumentResolver</strong> ，<strong>com.itheima.a20.YmlReturnValueHandler</strong></p><h4 id="收获💡-32"><a href="#收获💡-32" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>体会参数解析器的作用</li><li>体会返回值处理器的作用</li></ol><h3 id="21-参数解析器"><a href="#21-参数解析器" class="headerlink" title="21) 参数解析器"></a>21) 参数解析器</h3><h4 id="演示-常见参数解析器"><a href="#演示-常见参数解析器" class="headerlink" title="演示 - 常见参数解析器"></a>演示 - 常见参数解析器</h4><h5 id="代码参考-28"><a href="#代码参考-28" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a21</strong> 包</p><h4 id="收获💡-33"><a href="#收获💡-33" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>初步了解 RequestMappingHandlerAdapter 的调用过程<ol><li>控制器方法被封装为 HandlerMethod</li><li>准备对象绑定与类型转换</li><li>准备 ModelAndViewContainer 用来存储中间 Model 结果</li><li>解析每个参数值</li></ol></li><li>解析参数依赖的就是各种参数解析器，它们都有两个重要方法<ul><li>supportsParameter 判断是否支持方法参数</li><li>resolveArgument 解析方法参数</li></ul></li><li>常见参数的解析<ul><li>@RequestParam</li><li>省略 @RequestParam</li><li>@RequestParam(defaultValue)</li><li>MultipartFile</li><li>@PathVariable</li><li>@RequestHeader</li><li>@CookieValue</li><li>@Value</li><li>HttpServletRequest 等</li><li>@ModelAttribute</li><li>省略 @ModelAttribute</li><li>@RequestBody</li></ul></li><li>组合模式在 Spring 中的体现</li><li>@RequestParam, @CookieValue 等注解中的参数名、默认值, 都可以写成活的, 即从 ${ } #{ }中获取</li></ol><h3 id="22-参数名解析"><a href="#22-参数名解析" class="headerlink" title="22) 参数名解析"></a>22) 参数名解析</h3><h4 id="演示-两种方法获取参数名"><a href="#演示-两种方法获取参数名" class="headerlink" title="演示 - 两种方法获取参数名"></a>演示 - 两种方法获取参数名</h4><h5 id="代码参考-29"><a href="#代码参考-29" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a22.A22</strong></p><h4 id="收获💡-34"><a href="#收获💡-34" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>如果编译时添加了 -parameters 可以生成参数表, 反射时就可以拿到参数名</li><li>如果编译时添加了 -g 可以生成调试信息, 但分为两种情况<ul><li>普通类, 会包含局部变量表, 用 asm 可以拿到参数名</li><li>接口, 不会包含局部变量表, 无法获得参数名<ul><li>这也是 MyBatis 在实现 Mapper 接口时为何要提供 @Param 注解来辅助获得参数名</li></ul></li></ul></li></ol><h3 id="23-对象绑定与类型转换"><a href="#23-对象绑定与类型转换" class="headerlink" title="23) 对象绑定与类型转换"></a>23) 对象绑定与类型转换</h3><h4 id="底层第一套转换接口与实现"><a href="#底层第一套转换接口与实现" class="headerlink" title="底层第一套转换接口与实现"></a>底层第一套转换接口与实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">Formatter --|&gt; Printer</span><br><span class="line">Formatter --|&gt; Parser</span><br><span class="line"></span><br><span class="line">class Converters &#123;</span><br><span class="line">   Set~GenericConverter~</span><br><span class="line">&#125;</span><br><span class="line">class Converter</span><br><span class="line"></span><br><span class="line">class ConversionService</span><br><span class="line">class FormattingConversionService</span><br><span class="line"></span><br><span class="line">ConversionService &lt;|-- FormattingConversionService</span><br><span class="line">FormattingConversionService o-- Converters</span><br><span class="line"></span><br><span class="line">Printer --&gt; Adapter1</span><br><span class="line">Adapter1 --&gt; Converters</span><br><span class="line">Parser --&gt; Adapter2</span><br><span class="line">Adapter2 --&gt; Converters</span><br><span class="line">Converter --&gt; Adapter3</span><br><span class="line">Adapter3 --&gt; Converters</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; Formatter</span><br><span class="line">&lt;&lt;interface&gt;&gt; Printer</span><br><span class="line">&lt;&lt;interface&gt;&gt; Parser</span><br><span class="line">&lt;&lt;interface&gt;&gt; Converter</span><br><span class="line">&lt;&lt;interface&gt;&gt; ConversionService</span><br></pre></td></tr></table></figure><ul><li>Printer 把其它类型转为 String</li><li>Parser 把 String 转为其它类型</li><li>Formatter 综合 Printer 与 Parser 功能</li><li>Converter 把类型 S 转为类型 T</li><li>Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合</li><li>FormattingConversionService 利用其它们实现转换</li></ul><h4 id="底层第二套转换接口"><a href="#底层第二套转换接口" class="headerlink" title="底层第二套转换接口"></a>底层第二套转换接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">PropertyEditorRegistry o-- &quot;多&quot; PropertyEditor</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditorRegistry</span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditor</span><br></pre></td></tr></table></figure><ul><li>PropertyEditor 把 String 与其它类型相互转换</li><li>PropertyEditorRegistry 可以注册多个 PropertyEditor 对象</li><li>与第一套接口直接可以通过 FormatterPropertyEditorAdapter 来进行适配</li></ul><h4 id="高层接口与实现"><a href="#高层接口与实现" class="headerlink" title="高层接口与实现"></a>高层接口与实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">TypeConverter &lt;|-- SimpleTypeConverter</span><br><span class="line">TypeConverter &lt;|-- BeanWrapperImpl</span><br><span class="line">TypeConverter &lt;|-- DirectFieldAccessor</span><br><span class="line">TypeConverter &lt;|-- ServletRequestDataBinder</span><br><span class="line"></span><br><span class="line">SimpleTypeConverter --&gt; TypeConverterDelegate</span><br><span class="line">BeanWrapperImpl --&gt; TypeConverterDelegate</span><br><span class="line">DirectFieldAccessor --&gt; TypeConverterDelegate</span><br><span class="line">ServletRequestDataBinder --&gt; TypeConverterDelegate</span><br><span class="line"></span><br><span class="line">TypeConverterDelegate --&gt; ConversionService</span><br><span class="line">TypeConverterDelegate --&gt; PropertyEditorRegistry</span><br><span class="line"></span><br><span class="line">&lt;&lt;interface&gt;&gt; TypeConverter</span><br><span class="line">&lt;&lt;interface&gt;&gt; ConversionService</span><br><span class="line">&lt;&lt;interface&gt;&gt; PropertyEditorRegistry</span><br></pre></td></tr></table></figure><ul><li>它们都实现了 TypeConverter 这个高层转换接口，在转换时，会用到 TypeConverter Delegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（Facade 门面模式）<ul><li>首先看是否有自定义转换器, @InitBinder 添加的即属于这种 (用了适配器模式把 Formatter 转为需要的 PropertyEditor)</li><li>再看有没有 ConversionService 转换</li><li>再利用默认的 PropertyEditor 转换</li><li>最后有一些特殊处理</li></ul></li><li>SimpleTypeConverter 仅做类型转换</li><li>BeanWrapperImpl 为 bean 的属性赋值，当需要时做类型转换，走 Property</li><li>DirectFieldAccessor 为 bean 的属性赋值，当需要时做类型转换，走 Field</li><li>ServletRequestDataBinder 为 bean 的属性执行绑定，当需要时做类型转换，根据 directFieldAccess 选择走 Property 还是 Field，具备校验与获取校验结果功能</li></ul><h4 id="演示1-类型转换与数据绑定"><a href="#演示1-类型转换与数据绑定" class="headerlink" title="演示1 - 类型转换与数据绑定"></a>演示1 - 类型转换与数据绑定</h4><h5 id="代码参考-30"><a href="#代码参考-30" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a23</strong> 包</p><h4 id="收获💡-35"><a href="#收获💡-35" class="headerlink" title="收获💡"></a>收获💡</h4><p>基本的类型转换与数据绑定用法</p><ul><li>SimpleTypeConverter</li><li>BeanWrapperImpl</li><li>DirectFieldAccessor</li><li>ServletRequestDataBinder</li></ul><h4 id="演示2-数据绑定工厂"><a href="#演示2-数据绑定工厂" class="headerlink" title="演示2 - 数据绑定工厂"></a>演示2 - 数据绑定工厂</h4><h5 id="代码参考-31"><a href="#代码参考-31" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a23.TestServletDataBinderFactory</strong></p><h4 id="收获💡-36"><a href="#收获💡-36" class="headerlink" title="收获💡"></a>收获💡</h4><p>ServletRequestDataBinderFactory 的用法和扩展点</p><ol><li>可以解析控制器的 @InitBinder 标注方法作为扩展点，添加自定义转换器<ul><li>控制器私有范围</li></ul></li><li>可以通过 ConfigurableWebBindingInitializer 配置 ConversionService 作为扩展点，添加自定义转换器<ul><li>公共范围</li></ul></li><li>同时加了 @InitBinder 和 ConversionService 的转换优先级<ol><li>优先采用 @InitBinder 的转换器</li><li>其次使用 ConversionService 的转换器</li><li>使用默认转换器</li><li>特殊处理（例如有参构造）</li></ol></li></ol><h4 id="演示3-获取泛型参数"><a href="#演示3-获取泛型参数" class="headerlink" title="演示3 - 获取泛型参数"></a>演示3 - 获取泛型参数</h4><h5 id="代码参考-32"><a href="#代码参考-32" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a23.sub</strong> 包</p><h4 id="收获💡-37"><a href="#收获💡-37" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>java api 获取泛型参数</li><li>spring api 获取泛型参数</li></ol><h3 id="24-ControllerAdvice-之-InitBinder"><a href="#24-ControllerAdvice-之-InitBinder" class="headerlink" title="24) @ControllerAdvice 之 @InitBinder"></a>24) @ControllerAdvice 之 @InitBinder</h3><h4 id="演示-准备-InitBinder"><a href="#演示-准备-InitBinder" class="headerlink" title="演示 - 准备 @InitBinder"></a>演示 - 准备 @InitBinder</h4><p><strong>准备 @InitBinder</strong> 在整个 HandlerAdapter 调用过程中所处的位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as HandlerAdapter</span><br><span class="line">participant bf as WebDataBinderFactory</span><br><span class="line">participant mf as ModelFactory</span><br><span class="line">participant ihm as ServletInvocableHandlerMethod</span><br><span class="line">participant ar as ArgumentResolvers </span><br><span class="line">participant rh as ReturnValueHandlers</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line">rect rgb(200, 150, 255)</span><br><span class="line">adapter -&gt;&gt; +bf: 准备 @InitBinder</span><br><span class="line">bf --&gt;&gt; -adapter: </span><br><span class="line">end</span><br><span class="line">adapter -&gt;&gt; +mf: 准备 @ModelAttribute</span><br><span class="line">mf -&gt;&gt; +container: 添加Model数据</span><br><span class="line">container --&gt;&gt; -mf: </span><br><span class="line">mf --&gt;&gt; -adapter: </span><br><span class="line"></span><br><span class="line">adapter -&gt;&gt; +ihm: invokeAndHandle</span><br><span class="line">ihm -&gt;&gt; +ar: 获取 args</span><br><span class="line">ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice</span><br><span class="line">ar -&gt;&gt; container: 有的解析器涉及数据绑定生成Model数据</span><br><span class="line">ar --&gt;&gt; -ihm: args</span><br><span class="line">ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue</span><br><span class="line">ihm -&gt;&gt; +rh: 处理 returnValue</span><br><span class="line">rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice</span><br><span class="line">rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等</span><br><span class="line">container --&gt;&gt; -rh: </span><br><span class="line">rh --&gt;&gt; -ihm: </span><br><span class="line">ihm --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +container: 获取 ModelAndView</span><br><span class="line">container --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><ul><li>RequestMappingHandlerAdapter 在图中缩写为 HandlerAdapter</li><li>HandlerMethodArgumentResolverComposite 在图中缩写为 ArgumentResolvers</li><li>HandlerMethodReturnValueHandlerComposite 在图中缩写为 ReturnValueHandlers</li></ul><h4 id="收获💡-38"><a href="#收获💡-38" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @InitBinder 方法</li><li>RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @InitBinder 方法</li><li>以上两种 @InitBinder 的解析结果都会缓存来避免重复解析</li><li>控制器方法调用时，会综合利用本类的 @InitBinder 方法和 @ControllerAdvice 中的 @InitBinder 方法创建绑定工厂</li></ol><h3 id="25-控制器方法执行流程"><a href="#25-控制器方法执行流程" class="headerlink" title="25) 控制器方法执行流程"></a>25) 控制器方法执行流程</h3><h4 id="图1"><a href="#图1" class="headerlink" title="图1"></a>图1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">class ServletInvocableHandlerMethod &#123;</span><br><span class="line">+invokeAndHandle(ServletWebRequest,ModelAndViewContainer)</span><br><span class="line">&#125;</span><br><span class="line">HandlerMethod &lt;|-- ServletInvocableHandlerMethod</span><br><span class="line">HandlerMethod o-- bean</span><br><span class="line">HandlerMethod o-- method</span><br><span class="line">ServletInvocableHandlerMethod o-- WebDataBinderFactory</span><br><span class="line">ServletInvocableHandlerMethod o-- ParameterNameDiscoverer</span><br><span class="line">ServletInvocableHandlerMethod o-- HandlerMethodArgumentResolverComposite</span><br><span class="line">ServletInvocableHandlerMethod o-- HandlerMethodReturnValueHandlerComposite</span><br></pre></td></tr></table></figure><p>HandlerMethod 需要</p><ul><li>bean 即是哪个 Controller</li><li>method 即是 Controller 中的哪个方法</li></ul><p>ServletInvocableHandlerMethod 需要</p><ul><li>WebDataBinderFactory 负责对象绑定、类型转换</li><li>ParameterNameDiscoverer 负责参数名解析</li><li>HandlerMethodArgumentResolverComposite 负责解析参数</li><li>HandlerMethodReturnValueHandlerComposite 负责处理返回值</li></ul><h4 id="图2"><a href="#图2" class="headerlink" title="图2"></a>图2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as RequestMappingHandlerAdapter</span><br><span class="line">participant bf as WebDataBinderFactory</span><br><span class="line">participant mf as ModelFactory</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line">adapter -&gt;&gt; +bf: 准备 @InitBinder</span><br><span class="line">bf --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +mf: 准备 @ModelAttribute</span><br><span class="line">mf -&gt;&gt; +container: 添加Model数据</span><br><span class="line">container --&gt;&gt; -mf: </span><br><span class="line">mf --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><h4 id="图3"><a href="#图3" class="headerlink" title="图3"></a>图3</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as RequestMappingHandlerAdapter</span><br><span class="line">participant ihm as ServletInvocableHandlerMethod</span><br><span class="line">participant ar as ArgumentResolvers</span><br><span class="line">participant rh as ReturnValueHandlers</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line"></span><br><span class="line">adapter -&gt;&gt; +ihm: invokeAndHandle</span><br><span class="line">ihm -&gt;&gt; +ar: 获取 args</span><br><span class="line">ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice</span><br><span class="line">ar -&gt;&gt; container: 有的解析器涉及数据绑定生成模型数据</span><br><span class="line">container --&gt;&gt; ar: </span><br><span class="line">ar --&gt;&gt; -ihm: args</span><br><span class="line">ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue</span><br><span class="line">ihm -&gt;&gt; +rh: 处理 returnValue</span><br><span class="line">rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice</span><br><span class="line">rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等</span><br><span class="line">container --&gt;&gt; -rh: </span><br><span class="line">rh --&gt;&gt; -ihm: </span><br><span class="line">ihm --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +container: 获取 ModelAndView</span><br><span class="line">container --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><h3 id="26-ControllerAdvice-之-ModelAttribute"><a href="#26-ControllerAdvice-之-ModelAttribute" class="headerlink" title="26) @ControllerAdvice 之 @ModelAttribute"></a>26) @ControllerAdvice 之 @ModelAttribute</h3><h4 id="演示-准备-ModelAttribute"><a href="#演示-准备-ModelAttribute" class="headerlink" title="演示 - 准备 @ModelAttribute"></a>演示 - 准备 @ModelAttribute</h4><h5 id="代码参考-33"><a href="#代码参考-33" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a26</strong> 包</p><p><strong>准备 @ModelAttribute</strong> 在整个 HandlerAdapter 调用过程中所处的位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as HandlerAdapter</span><br><span class="line">participant bf as WebDataBinderFactory</span><br><span class="line">participant mf as ModelFactory</span><br><span class="line">participant ihm as ServletInvocableHandlerMethod</span><br><span class="line">participant ar as ArgumentResolvers </span><br><span class="line">participant rh as ReturnValueHandlers</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line"></span><br><span class="line">adapter -&gt;&gt; +bf: 准备 @InitBinder</span><br><span class="line">bf --&gt;&gt; -adapter: </span><br><span class="line">rect rgb(200, 150, 255)</span><br><span class="line">adapter -&gt;&gt; +mf: 准备 @ModelAttribute</span><br><span class="line">mf -&gt;&gt; +container: 添加Model数据</span><br><span class="line">container --&gt;&gt; -mf: </span><br><span class="line">mf --&gt;&gt; -adapter: </span><br><span class="line">end</span><br><span class="line">adapter -&gt;&gt; +ihm: invokeAndHandle</span><br><span class="line">ihm -&gt;&gt; +ar: 获取 args</span><br><span class="line">ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice</span><br><span class="line">ar -&gt;&gt; container: 有的解析器涉及数据绑定生成Model数据</span><br><span class="line">ar --&gt;&gt; -ihm: args</span><br><span class="line">ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue</span><br><span class="line">ihm -&gt;&gt; +rh: 处理 returnValue</span><br><span class="line">rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice</span><br><span class="line">rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等</span><br><span class="line">container --&gt;&gt; -rh: </span><br><span class="line">rh --&gt;&gt; -ihm: </span><br><span class="line">ihm --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +container: 获取 ModelAndView</span><br><span class="line">container --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><h4 id="收获💡-39"><a href="#收获💡-39" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @ModelAttribute 方法</li><li>RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @ModelAttribute 方法</li><li>以上两种 @ModelAttribute 的解析结果都会缓存来避免重复解析</li><li>控制器方法调用时，会综合利用本类的 @ModelAttribute 方法和 @ControllerAdvice 中的 @ModelAttribute 方法创建模型工厂</li></ol><h3 id="27-返回值处理器"><a href="#27-返回值处理器" class="headerlink" title="27) 返回值处理器"></a>27) 返回值处理器</h3><h4 id="演示-常见返回值处理器"><a href="#演示-常见返回值处理器" class="headerlink" title="演示 - 常见返回值处理器"></a>演示 - 常见返回值处理器</h4><h5 id="代码参考-34"><a href="#代码参考-34" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a27</strong> 包</p><h4 id="收获💡-40"><a href="#收获💡-40" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>常见的返回值处理器<ul><li>ModelAndView，分别获取其模型和视图名，放入 ModelAndViewContainer</li><li>返回值类型为 String 时，把它当做视图名，放入 ModelAndViewContainer</li><li>返回值添加了 @ModelAttribute 注解时，将返回值作为模型，放入 ModelAndViewContainer<ul><li>此时需找到默认视图名</li></ul></li><li>返回值省略 @ModelAttribute 注解且返回非简单类型时，将返回值作为模型，放入 ModelAndViewContainer<ul><li>此时需找到默认视图名</li></ul></li><li>返回值类型为 ResponseEntity 时<ul><li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li></ul></li><li>返回值类型为 HttpHeaders 时<ul><li>会设置 ModelAndViewContainer.requestHandled 为 true</li></ul></li><li>返回值添加了 @ResponseBody 注解时<ul><li>此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true</li></ul></li></ul></li><li>组合模式在 Spring 中的体现 + 1</li></ol><h3 id="28-MessageConverter"><a href="#28-MessageConverter" class="headerlink" title="28) MessageConverter"></a>28) MessageConverter</h3><h4 id="演示-MessageConverter-的作用"><a href="#演示-MessageConverter-的作用" class="headerlink" title="演示 - MessageConverter 的作用"></a>演示 - MessageConverter 的作用</h4><h5 id="代码参考-35"><a href="#代码参考-35" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a28.A28</strong></p><h4 id="收获💡-41"><a href="#收获💡-41" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>MessageConverter 的作用<ul><li>@ResponseBody 是返回值处理器解析的</li><li>但具体转换工作是 MessageConverter 做的</li></ul></li><li>如何选择 MediaType<ul><li>首先看 @RequestMapping 上有没有指定</li><li>其次看 request 的 Accept 头有没有指定</li><li>最后按 MessageConverter 的顺序, 谁能谁先转换</li></ul></li></ol><h3 id="29-ControllerAdvice-之-ResponseBodyAdvice"><a href="#29-ControllerAdvice-之-ResponseBodyAdvice" class="headerlink" title="29) @ControllerAdvice 之 ResponseBodyAdvice"></a>29) @ControllerAdvice 之 ResponseBodyAdvice</h3><h4 id="演示-ResponseBodyAdvice-增强"><a href="#演示-ResponseBodyAdvice-增强" class="headerlink" title="演示 - ResponseBodyAdvice 增强"></a>演示 - ResponseBodyAdvice 增强</h4><h5 id="代码参考-36"><a href="#代码参考-36" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a29</strong> 包</p><p><strong>ResponseBodyAdvice 增强</strong> 在整个 HandlerAdapter 调用过程中所处的位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant adapter as HandlerAdapter</span><br><span class="line">participant bf as WebDataBinderFactory</span><br><span class="line">participant mf as ModelFactory</span><br><span class="line">participant ihm as ServletInvocableHandlerMethod</span><br><span class="line">participant ar as ArgumentResolvers </span><br><span class="line">participant rh as ReturnValueHandlers</span><br><span class="line">participant container as ModelAndViewContainer</span><br><span class="line"></span><br><span class="line">adapter -&gt;&gt; +bf: 准备 @InitBinder</span><br><span class="line">bf --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +mf: 准备 @ModelAttribute</span><br><span class="line">mf -&gt;&gt; +container: 添加Model数据</span><br><span class="line">container --&gt;&gt; -mf: </span><br><span class="line">mf --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +ihm: invokeAndHandle</span><br><span class="line">ihm -&gt;&gt; +ar: 获取 args</span><br><span class="line">ar -&gt;&gt; ar: 有的解析器涉及 RequestBodyAdvice</span><br><span class="line">ar -&gt;&gt; container: 有的解析器涉及数据绑定生成Model数据</span><br><span class="line">ar --&gt;&gt; -ihm: args</span><br><span class="line">ihm -&gt;&gt; ihm: method.invoke(bean,args) 得到 returnValue</span><br><span class="line">ihm -&gt;&gt; +rh: 处理 returnValue</span><br><span class="line">rect rgb(200, 150, 255)</span><br><span class="line">rh -&gt;&gt; rh: 有的处理器涉及 ResponseBodyAdvice</span><br><span class="line">end</span><br><span class="line">rh -&gt;&gt; +container: 添加Model数据,处理视图名,是否渲染等</span><br><span class="line">container --&gt;&gt; -rh: </span><br><span class="line">rh --&gt;&gt; -ihm: </span><br><span class="line">ihm --&gt;&gt; -adapter: </span><br><span class="line">adapter -&gt;&gt; +container: 获取 ModelAndView</span><br><span class="line">container --&gt;&gt; -adapter: </span><br></pre></td></tr></table></figure><h4 id="收获💡-42"><a href="#收获💡-42" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>ResponseBodyAdvice 返回响应体前包装</li></ol><h3 id="30-异常解析器"><a href="#30-异常解析器" class="headerlink" title="30) 异常解析器"></a>30) 异常解析器</h3><h4 id="演示-ExceptionHandlerExceptionResolver"><a href="#演示-ExceptionHandlerExceptionResolver" class="headerlink" title="演示 - ExceptionHandlerExceptionResolver"></a>演示 - ExceptionHandlerExceptionResolver</h4><h5 id="代码参考-37"><a href="#代码参考-37" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a30.A30</strong></p><h4 id="收获💡-43"><a href="#收获💡-43" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>它能够重用参数解析器、返回值处理器，实现组件重用</li><li>它能够支持嵌套异常</li></ol><h3 id="31-ControllerAdvice-之-ExceptionHandler"><a href="#31-ControllerAdvice-之-ExceptionHandler" class="headerlink" title="31) @ControllerAdvice 之 @ExceptionHandler"></a>31) @ControllerAdvice 之 @ExceptionHandler</h3><h4 id="演示-准备-ExceptionHandler"><a href="#演示-准备-ExceptionHandler" class="headerlink" title="演示 - 准备 @ExceptionHandler"></a>演示 - 准备 @ExceptionHandler</h4><h5 id="代码参考-38"><a href="#代码参考-38" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a31</strong> 包</p><h4 id="收获💡-44"><a href="#收获💡-44" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>ExceptionHandlerExceptionResolver 初始化时会解析 @ControllerAdvice 中的 @ExceptionHandler 方法</li><li>ExceptionHandlerExceptionResolver 会以类为单位，在该类首次处理异常时，解析此类的 @ExceptionHandler 方法</li><li>以上两种 @ExceptionHandler 的解析结果都会缓存来避免重复解析</li></ol><h3 id="32-Tomcat-异常处理"><a href="#32-Tomcat-异常处理" class="headerlink" title="32) Tomcat 异常处理"></a>32) Tomcat 异常处理</h3><ul><li><p>我们知道 @ExceptionHandler 只能处理发生在 mvc 流程中的异常，例如控制器内、拦截器内，那么如果是 Filter 出现了异常，如何进行处理呢？</p></li><li><p>在 Spring Boot 中，是这么实现的：</p><ol><li>因为内嵌了 Tomcat 容器，因此可以配置 Tomcat 的错误页面，Filter 与 错误页面之间是通过请求转发跳转的，可以在这里做手脚</li><li>先通过 ErrorPageRegistrarBeanPostProcessor 这个后处理器配置错误页面地址，默认为 <code>/error</code> 也可以通过 <code>$&#123;server.error.path&#125;</code> 进行配置</li><li>当 Filter 发生异常时，不会走 Spring 流程，但会走 Tomcat 的错误处理，于是就希望转发至 <code>/error</code> 这个地址<ul><li>当然，如果没有 @ExceptionHandler，那么最终也会走到 Tomcat 的错误处理</li></ul></li><li>Spring Boot 又提供了一个 BasicErrorController，它就是一个标准 @Controller，@RequestMapping 配置为 <code>/error</code>，所以处理异常的职责就又回到了 Spring</li><li>异常信息由于会被 Tomcat 放入 request 作用域，因此 BasicErrorController 里也能获取到</li><li>具体异常信息会由 DefaultErrorAttributes 封装好</li><li>BasicErrorController 通过 Accept 头判断需要生成哪种 MediaType 的响应<ul><li>如果要的不是 text&#x2F;html，走 MessageConverter 流程</li><li>如果需要 text&#x2F;html，走 mvc 流程，此时又分两种情况<ul><li>配置了 ErrorViewResolver，根据状态码去找 View</li><li>没配置或没找到，用 BeanNameViewResolver 根据一个固定为 error 的名字找到 View，即所谓的 WhitelabelErrorView</li></ul></li></ul></li></ol></li></ul><blockquote><p><em><strong>评价</strong></em></p><ul><li>一个错误处理搞得这么复杂，就问恶心不？</li></ul></blockquote><h4 id="演示1-错误页处理"><a href="#演示1-错误页处理" class="headerlink" title="演示1 - 错误页处理"></a>演示1 - 错误页处理</h4><h5 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️修改了 Tomcat 服务器默认错误地址, 出错时使用请求转发方式跳转</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrar <span class="title function_">errorPageRegistrar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> webServerFactory -&gt; webServerFactory.addErrorPages(<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(<span class="string">&quot;/error&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️TomcatServletWebServerFactory 初始化前用它增强, 注册所有 ErrorPageRegistrar</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrarBeanPostProcessor <span class="title function_">errorPageRegistrarBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorPageRegistrarBeanPostProcessor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-45"><a href="#收获💡-45" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>Tomcat 的错误页处理手段</li></ol><h4 id="演示2-BasicErrorController"><a href="#演示2-BasicErrorController" class="headerlink" title="演示2 - BasicErrorController"></a>演示2 - BasicErrorController</h4><h5 id="关键代码-2"><a href="#关键代码-2" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️ErrorProperties 封装环境键值, ErrorAttributes 控制有哪些错误信息</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ErrorProperties</span> <span class="variable">errorProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>();</span><br><span class="line">    errorProperties.setIncludeException(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>(), errorProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️名称为 error 的视图, 作为 BasicErrorController 的 text/html 响应结果</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">View</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;String, ?&gt; model, </span></span><br><span class="line"><span class="params">            HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response</span></span><br><span class="line"><span class="params">        )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(model);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    &lt;h3&gt;服务器内部错误&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// ⬅️收集容器中所有 View 对象, bean 的名字作为视图名</span></span><br><span class="line"><span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-46"><a href="#收获💡-46" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>Spring Boot 中 BasicErrorController 如何工作</li></ol><h3 id="33-BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter"><a href="#33-BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter" class="headerlink" title="33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter"></a>33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter</h3><h4 id="演示-本组映射器和适配器"><a href="#演示-本组映射器和适配器" class="headerlink" title="演示 - 本组映射器和适配器"></a>演示 - 本组映射器和适配器</h4><h5 id="关键代码-3"><a href="#关键代码-3" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title function_">beanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameUrlHandlerMapping</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/c3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Controller <span class="title function_">controller3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-47"><a href="#收获💡-47" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>BeanNameUrlHandlerMapping，以 &#x2F; 开头的 bean 的名字会被当作映射路径</li><li>这些 bean 本身当作 handler，要求实现 Controller 接口</li><li>SimpleControllerHandlerAdapter，调用 handler</li><li>模拟实现这组映射器和适配器</li></ol><h3 id="34-RouterFunctionMapping-与-HandlerFunctionAdapter"><a href="#34-RouterFunctionMapping-与-HandlerFunctionAdapter" class="headerlink" title="34) RouterFunctionMapping 与 HandlerFunctionAdapter"></a>34) RouterFunctionMapping 与 HandlerFunctionAdapter</h3><h4 id="演示-本组映射器和适配器-1"><a href="#演示-本组映射器和适配器-1" class="headerlink" title="演示 - 本组映射器和适配器"></a>演示 - 本组映射器和适配器</h4><h5 id="关键代码-4"><a href="#关键代码-4" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RouterFunctionMapping <span class="title function_">routerFunctionMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RouterFunctionMapping</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HandlerFunctionAdapter <span class="title function_">handlerFunctionAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerFunctionAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">r1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//           ⬇️映射条件   ⬇️handler</span></span><br><span class="line">    <span class="keyword">return</span> route(GET(<span class="string">&quot;/r1&quot;</span>), request -&gt; ok().body(<span class="string">&quot;this is r1&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-48"><a href="#收获💡-48" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>RouterFunctionMapping, 通过 RequestPredicate 条件映射</li><li>handler 要实现 HandlerFunction 接口</li><li>HandlerFunctionAdapter, 调用 handler</li></ol><h3 id="35-SimpleUrlHandlerMapping-与-HttpRequestHandlerAdapter"><a href="#35-SimpleUrlHandlerMapping-与-HttpRequestHandlerAdapter" class="headerlink" title="35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter"></a>35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter</h3><h4 id="演示1-本组映射器和适配器"><a href="#演示1-本组映射器和适配器" class="headerlink" title="演示1 - 本组映射器和适配器"></a>演示1 - 本组映射器和适配器</h4><h5 id="代码参考-39"><a href="#代码参考-39" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>org.springframework.boot.autoconfigure.web.servlet.A35</strong></p><h5 id="关键代码-5"><a href="#关键代码-5" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title function_">simpleUrlHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">SimpleUrlHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>();</span><br><span class="line">    Map&lt;String, ResourceHttpRequestHandler&gt; map </span><br><span class="line">        = context.getBeansOfType(ResourceHttpRequestHandler.class);</span><br><span class="line">    handlerMapping.setUrlMap(map);</span><br><span class="line">    <span class="keyword">return</span> handlerMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HttpRequestHandlerAdapter <span class="title function_">httpRequestHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRequestHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    handler.setLocations(List.of(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/img/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    handler.setLocations(List.of(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;images/&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-49"><a href="#收获💡-49" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>SimpleUrlHandlerMapping 不会在初始化时收集映射信息，需要手动收集</li><li>SimpleUrlHandlerMapping 映射路径</li><li>ResourceHttpRequestHandler 作为静态资源 handler</li><li>HttpRequestHandlerAdapter, 调用此 handler</li></ol><h4 id="演示2-静态资源解析优化"><a href="#演示2-静态资源解析优化" class="headerlink" title="演示2 - 静态资源解析优化"></a>演示2 - 静态资源解析优化</h4><h5 id="关键代码-6"><a href="#关键代码-6" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    handler.setLocations(List.of(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">    handler.setResourceResolvers(List.of(</span><br><span class="line">        <span class="comment">// ⬇️缓存优化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CachingResourceResolver</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentMapCache</span>(<span class="string">&quot;cache1&quot;</span>)),</span><br><span class="line">        <span class="comment">// ⬇️压缩优化</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EncodedResourceResolver</span>(),</span><br><span class="line">        <span class="comment">// ⬇️原始资源解析</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathResourceResolver</span>()</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-50"><a href="#收获💡-50" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>责任链模式体现</li><li>压缩文件需要手动生成</li></ol><h4 id="演示3-欢迎页"><a href="#演示3-欢迎页" class="headerlink" title="演示3 - 欢迎页"></a>演示3 - 欢迎页</h4><h5 id="关键代码-7"><a href="#关键代码-7" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> context.getResource(<span class="string">&quot;classpath:static/index.html&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(<span class="literal">null</span>, context, resource, <span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-51"><a href="#收获💡-51" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>欢迎页支持静态欢迎页与动态欢迎页</li><li>WelcomePageHandlerMapping 映射欢迎页（即只映射 ‘&#x2F;‘）<ul><li>它内置的 handler ParameterizableViewController 作用是不执行逻辑，仅根据视图名找视图</li><li>视图名固定为 forward:index.html</li></ul></li><li>SimpleControllerHandlerAdapter, 调用 handler<ul><li>转发至 &#x2F;index.html</li><li>处理 &#x2F;index.html 又会走上面的静态资源处理流程</li></ul></li></ol><h4 id="映射器与适配器小结"><a href="#映射器与适配器小结" class="headerlink" title="映射器与适配器小结"></a>映射器与适配器小结</h4><ol><li>HandlerMapping 负责建立请求与控制器之间的映射关系<ul><li>RequestMappingHandlerMapping (与 @RequestMapping 匹配)</li><li>WelcomePageHandlerMapping    (&#x2F;)</li><li>BeanNameUrlHandlerMapping    (与 bean 的名字匹配 以 &#x2F; 开头)</li><li>RouterFunctionMapping        (函数式 RequestPredicate, HandlerFunction)</li><li>SimpleUrlHandlerMapping      (静态资源 通配符 &#x2F;** &#x2F;img&#x2F;**)</li><li>之间也会有顺序问题, boot 中默认顺序如上</li></ul></li><li>HandlerAdapter 负责实现对各种各样的 handler 的适配调用<ul><li>RequestMappingHandlerAdapter 处理：@RequestMapping 方法<ul><li>参数解析器、返回值处理器体现了组合模式</li></ul></li><li>SimpleControllerHandlerAdapter 处理：Controller 接口</li><li>HandlerFunctionAdapter 处理：HandlerFunction 函数式接口</li><li>HttpRequestHandlerAdapter 处理：HttpRequestHandler 接口 (静态资源处理)</li><li>这也是典型适配器模式体现</li></ul></li></ol><h3 id="36-mvc-处理流程"><a href="#36-mvc-处理流程" class="headerlink" title="36) mvc 处理流程"></a>36) mvc 处理流程</h3><p>当浏览器发送一个请求 <code>http://localhost:8080/hello</code> 后，请求到达服务器，其处理流程是：</p><ol><li><p>服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术</p><ul><li>路径：默认映射路径为 <code>/</code>，即会匹配到所有请求 URL，可作为请求的统一入口，也被称之为<strong>前控制器</strong><ul><li>jsp 不会匹配到 DispatcherServlet</li><li>其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet</li></ul></li><li>创建：在 Boot 中，由 DispatcherServletAutoConfiguration 这个自动配置类提供 DispatcherServlet 的 bean</li><li>初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量<ul><li>HandlerMapping，初始化时记录映射关系</li><li>HandlerAdapter，初始化时准备参数解析器、返回值处理器、消息转换器</li><li>HandlerExceptionResolver，初始化时准备参数解析器、返回值处理器、消息转换器</li><li>ViewResolver</li></ul></li></ul></li><li><p>DispatcherServlet 会利用 RequestMappingHandlerMapping 查找控制器方法</p><ul><li><p>例如根据 &#x2F;hello 路径找到 @RequestMapping(“&#x2F;hello”) 对应的控制器方法</p></li><li><p>控制器方法会被封装为 HandlerMethod 对象，并结合匹配到的拦截器一起返回给 DispatcherServlet </p></li><li><p>HandlerMethod 和拦截器合在一起称为 HandlerExecutionChain（调用链）对象</p></li></ul></li><li><p>DispatcherServlet 接下来会：</p><ol><li>调用拦截器的 preHandle 方法</li><li>RequestMappingHandlerAdapter 调用 handle 方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod<ul><li>@ControllerAdvice 全局增强点1️⃣：补充模型数据</li><li>@ControllerAdvice 全局增强点2️⃣：补充自定义类型转换器</li><li>使用 HandlerMethodArgumentResolver 准备参数<ul><li>@ControllerAdvice 全局增强点3️⃣：RequestBody 增强</li></ul></li><li>调用 ServletInvocableHandlerMethod </li><li>使用 HandlerMethodReturnValueHandler 处理返回值<ul><li>@ControllerAdvice 全局增强点4️⃣：ResponseBody 增强</li></ul></li><li>根据 ModelAndViewContainer 获取 ModelAndView<ul><li>如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程<ul><li>例如，有的返回值处理器调用了 HttpMessageConverter 来将结果转换为 JSON，这时 ModelAndView 就为 null</li></ul></li><li>如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程</li></ul></li></ul></li><li>调用拦截器的 postHandle 方法</li><li>处理异常或视图渲染<ul><li>如果 1~3 出现异常，走 ExceptionHandlerExceptionResolver 处理异常流程<ul><li>@ControllerAdvice 全局增强点5️⃣：@ExceptionHandler 异常处理</li></ul></li><li>正常，走视图解析及渲染流程</li></ul></li><li>调用拦截器的 afterCompletion 方法</li></ol></li></ol><h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><h3 id="37-Boot-骨架项目"><a href="#37-Boot-骨架项目" class="headerlink" title="37) Boot 骨架项目"></a>37) Boot 骨架项目</h3><p>如果是 linux 环境，用以下命令即可获取 spring boot 的骨架 pom.xml</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -G https://start.spring.io/pom.xml -d dependencies=web,mysql,mybatis -o pom.xml</span><br></pre></td></tr></table></figure><p>也可以使用 Postman 等工具实现</p><p>若想获取更多用法，请参考</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://start.spring.io</span><br></pre></td></tr></table></figure><h3 id="38-Boot-War项目"><a href="#38-Boot-War项目" class="headerlink" title="38) Boot War项目"></a>38) Boot War项目</h3><p>步骤1：创建模块，区别在于打包方式选择 war</p><img src="/2022/09/27/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20211021160145072.png" alt="image-20211021160145072" style="zoom: 50%;"><p>接下来勾选 Spring Web 支持</p><img src="/2022/09/27/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20211021162416525.png" alt="image-20211021162416525" style="zoom:50%;"><p>步骤2：编写控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">abc</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入了控制器&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤3：编写 jsp 视图，新建 webapp 目录和一个 hello.jsp 文件，注意文件名与控制器方法返回的视图逻辑名一致</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|- main</span><br><span class="line">|- java</span><br><span class="line">|- resources</span><br><span class="line">|- webapp</span><br><span class="line">|- hello.jsp</span><br></pre></td></tr></table></figure><p>步骤4：配置视图路径，打开 application.properties 文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.mvc.view.prefix</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></span><br></pre></td></tr></table></figure><blockquote><p>将来 prefix + 控制器方法返回值 + suffix 即为视图完整路径</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>如果用 mvn 插件 <code>mvn spring-boot:run</code> 或 main 方法测试</p><ul><li>必须添加如下依赖，因为此时用的还是内嵌 tomcat，而内嵌 tomcat 默认不带 jasper（用来解析 jsp）</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用 Idea 配置 tomcat 来测试，此时用的是外置 tomcat</p><ul><li>骨架生成的代码中，多了一个 ServletInitializer，它的作用就是配置外置 Tomcat 使用的，在外置 Tomcat 启动后，去调用它创建和运行 SpringApplication</li></ul><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>对于 jar 项目，若要支持 jsp，也可以在加入 jasper 依赖的前提下，把 jsp 文件置入 <code>META-INF/resources</code> </p><h3 id="39-Boot-启动过程"><a href="#39-Boot-启动过程" class="headerlink" title="39) Boot 启动过程"></a>39) Boot 启动过程</h3><p>阶段一：SpringApplication 构造</p><ol><li>记录 BeanDefinition 源</li><li>推断应用类型</li><li>记录 ApplicationContext 初始化器</li><li>记录监听器</li><li>推断主启动类</li></ol><p>阶段二：执行 run 方法</p><ol><li><p>得到 SpringApplicationRunListeners，名字取得不好，实际是事件发布器</p><ul><li>发布 application starting 事件1️⃣</li></ul></li><li><p>封装启动 args</p></li><li><p>准备 Environment 添加命令行参数（*）</p></li><li><p>ConfigurationPropertySources 处理（*）</p><ul><li>发布 application environment 已准备事件2️⃣</li></ul></li><li><p>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）</p><ul><li>application.properties，由 StandardConfigDataLocationResolver 解析</li><li>spring.application.json</li></ul></li><li><p>绑定 spring.main 到 SpringApplication 对象（*）</p></li><li><p>打印 banner（*）</p></li><li><p>创建容器</p></li><li><p>准备容器</p><ul><li>发布 application context 已初始化事件3️⃣</li></ul></li><li><p>加载 bean 定义</p><ul><li>发布 application prepared 事件4️⃣</li></ul></li><li><p>refresh 容器</p><ul><li>发布 application started 事件5️⃣</li></ul></li><li><p>执行 runner</p><ul><li><p>发布 application ready 事件6️⃣</p></li><li><p>这其中有异常，发布 application failed 事件7️⃣</p></li></ul></li></ol><blockquote><p>带 * 的有独立的示例</p></blockquote><h4 id="演示-启动过程"><a href="#演示-启动过程" class="headerlink" title="演示 - 启动过程"></a>演示 - 启动过程</h4><p><strong>com.itheima.a39.A39_1</strong> 对应 SpringApplication 构造</p><p><strong>com.itheima.a39.A39_2</strong> 对应第1步，并演示 7 个事件</p><p><strong>com.itheima.a39.A39_3</strong> 对应第2、8到12步</p><p><strong>org.springframework.boot.Step3</strong></p><p><strong>org.springframework.boot.Step4</strong></p><p><strong>org.springframework.boot.Step5</strong></p><p><strong>org.springframework.boot.Step6</strong></p><p><strong>org.springframework.boot.Step7</strong></p><h4 id="收获💡-52"><a href="#收获💡-52" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>SpringApplication 构造方法中所做的操作<ul><li>可以有多种源用来加载 bean 定义</li><li>应用类型推断</li><li>添加容器初始化器</li><li>添加监听器</li><li>演示主类推断</li></ul></li><li>如何读取 spring.factories 中的配置</li><li>从配置中获取重要的事件发布器：SpringApplicationRunListeners</li><li>容器的创建、初始化器增强、加载 bean 定义等</li><li>CommandLineRunner、ApplicationRunner 的作用</li><li>环境对象<ol><li>命令行 PropertySource</li><li>ConfigurationPropertySources 规范环境键名称</li><li>EnvironmentPostProcessor 后处理增强<ul><li>由 EventPublishingRunListener 通过监听事件2️⃣来调用</li></ul></li><li>绑定 spring.main 前缀的 key value 至 SpringApplication</li></ol></li><li>Banner</li></ol><h3 id="40-Tomcat-内嵌容器"><a href="#40-Tomcat-内嵌容器" class="headerlink" title="40) Tomcat 内嵌容器"></a>40) Tomcat 内嵌容器</h3><p>Tomcat 基本结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server</span><br><span class="line">└───Service</span><br><span class="line">    ├───Connector (协议, 端口)</span><br><span class="line">    └───Engine</span><br><span class="line">        └───Host(虚拟主机 localhost)</span><br><span class="line">            ├───Context1 (应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase )</span><br><span class="line">            │   │   index.html</span><br><span class="line">            │   └───WEB-INF</span><br><span class="line">            │       │   web.xml (servlet, filter, listener) 3.0</span><br><span class="line">            │       ├───classes (servlet, controller, service ...)</span><br><span class="line">            │       ├───jsp</span><br><span class="line">            │       └───lib (第三方 jar 包)</span><br><span class="line">            └───Context2 (应用2)</span><br><span class="line">                │   index.html</span><br><span class="line">                └───WEB-INF</span><br><span class="line">                        web.xml</span><br></pre></td></tr></table></figure><h4 id="演示1-Tomcat-内嵌容器"><a href="#演示1-Tomcat-内嵌容器" class="headerlink" title="演示1 - Tomcat 内嵌容器"></a>演示1 - Tomcat 内嵌容器</h4><h5 id="关键代码-8"><a href="#关键代码-8" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException, IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建 Tomcat 对象</span></span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setBaseDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建项目文件夹, 即 docBase 文件夹</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">&quot;boot.&quot;</span>).toFile();</span><br><span class="line">    docBase.deleteOnExit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(<span class="string">&quot;&quot;</span>, docBase.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">            <span class="type">HelloServlet</span> <span class="variable">helloServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">            ctx.addServlet(<span class="string">&quot;aaa&quot;</span>, helloServlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.启动 Tomcat</span></span><br><span class="line">    tomcat.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.创建连接器, 设置监听端口</span></span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="keyword">new</span> <span class="title class_">Http11Nio2Protocol</span>());</span><br><span class="line">    connector.setPort(<span class="number">8080</span>);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="演示2-集成-Spring-容器"><a href="#演示2-集成-Spring-容器" class="headerlink" title="演示2 - 集成 Spring 容器"></a>演示2 - 集成 Spring 容器</h4><h5 id="关键代码-9"><a href="#关键代码-9" class="headerlink" title="关键代码"></a>关键代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.编程添加 Servlet</span></span><br><span class="line">context.addServletContainerInitializer(<span class="keyword">new</span> <span class="title class_">ServletContainerInitializer</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// ⬇️通过 ServletRegistrationBean 添加 DispatcherServlet 等</span></span><br><span class="line">        <span class="keyword">for</span> (ServletRegistrationBean registrationBean : </span><br><span class="line">             springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123;</span><br><span class="line">            registrationBean.onStartup(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, Collections.emptySet());</span><br></pre></td></tr></table></figure><h3 id="41-Boot-自动配置"><a href="#41-Boot-自动配置" class="headerlink" title="41) Boot 自动配置"></a>41) Boot 自动配置</h3><h4 id="AopAutoConfiguration"><a href="#AopAutoConfiguration" class="headerlink" title="AopAutoConfiguration"></a>AopAutoConfiguration</h4><p>Spring Boot 是利用了自动配置类来简化了 aop 相关配置</p><ul><li>AOP 自动配置类为 <code>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</code></li><li>可以通过 <code>spring.aop.auto=false</code> 禁用 aop 自动配置</li><li>AOP 自动配置的本质是通过 <code>@EnableAspectJAutoProxy</code> 来开启了自动代理，如果在引导类上自己添加了 <code>@EnableAspectJAutoProxy</code> 那么以自己添加的为准</li><li><code>@EnableAspectJAutoProxy</code> 的本质是向容器中添加了 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个 bean 后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 bean 的初始化阶段完成的</li></ul><h4 id="DataSourceAutoConfiguration"><a href="#DataSourceAutoConfiguration" class="headerlink" title="DataSourceAutoConfiguration"></a>DataSourceAutoConfiguration</h4><ul><li>对应的自动配置类为：org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</li><li>它内部采用了条件装配，通过检查容器的 bean，以及类路径下的 class，来决定该 @Bean 是否生效</li></ul><p>简单说明一下，Spring Boot 支持两大类数据源：</p><ul><li>EmbeddedDatabase - 内嵌数据库连接池</li><li>PooledDataSource - 非内嵌数据库连接池</li></ul><p>PooledDataSource 又支持如下数据源</p><ul><li>hikari 提供的 HikariDataSource</li><li>tomcat-jdbc 提供的 DataSource</li><li>dbcp2 提供的 BasicDataSource</li><li>oracle 提供的 PoolDataSourceImpl</li></ul><p>如果知道数据源的实现类类型，即指定了 <code>spring.datasource.type</code>，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）</p><h4 id="MybatisAutoConfiguration"><a href="#MybatisAutoConfiguration" class="headerlink" title="MybatisAutoConfiguration"></a>MybatisAutoConfiguration</h4><ul><li>MyBatis 自动配置类为 <code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code></li><li>它主要配置了两个 bean<ul><li>SqlSessionFactory - MyBatis 核心对象，用来创建 SqlSession</li><li>SqlSessionTemplate - SqlSession 的实现，此实现会与当前线程绑定</li><li>用 ImportBeanDefinitionRegistrar 的方式扫描所有标注了 @Mapper 注解的接口</li><li>用 AutoConfigurationPackages 来确定扫描的包</li></ul></li><li>还有一个相关的 bean：MybatisProperties，它会读取配置文件中带 <code>mybatis.</code> 前缀的配置项进行定制配置</li></ul><p>@MapperScan 注解的作用与 MybatisAutoConfiguration 类似，会注册 MapperScannerConfigurer 有如下区别</p><ul><li>@MapperScan 扫描具体包（当然也可以配置关注哪个注解）</li><li>@MapperScan 如果不指定扫描具体包，则会把引导类范围内，所有接口当做 Mapper 接口</li><li>MybatisAutoConfiguration 关注的是所有标注 @Mapper 注解的接口，会忽略掉非 @Mapper 标注的接口</li></ul><p>这里有同学有疑问，之前介绍的都是将具体类交给 Spring 管理，怎么到了 MyBatis 这儿，接口就可以被管理呢？</p><ul><li>其实并非将接口交给 Spring 管理，而是每个接口会对应一个 MapperFactoryBean，是后者被 Spring 所管理，接口只是作为 MapperFactoryBean 的一个属性来配置</li></ul><h4 id="TransactionAutoConfiguration"><a href="#TransactionAutoConfiguration" class="headerlink" title="TransactionAutoConfiguration"></a>TransactionAutoConfiguration</h4><ul><li><p>事务自动配置类有两个：</p><ul><li><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code></li><li><code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></li></ul></li><li><p>前者配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作</p></li><li><p>后者功能上对标 @EnableTransactionManagement，包含以下三个 bean</p><ul><li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类，包含通知和切点</li><li>TransactionInterceptor 事务通知类，由它在目标方法调用前后加入事务操作</li><li>AnnotationTransactionAttributeSource 会解析 @Transactional 及事务属性，也包含了切点功能</li></ul></li><li><p>如果自己配置了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自己配置的为准</p></li></ul><h4 id="ServletWebServerFactoryAutoConfiguration"><a href="#ServletWebServerFactoryAutoConfiguration" class="headerlink" title="ServletWebServerFactoryAutoConfiguration"></a>ServletWebServerFactoryAutoConfiguration</h4><ul><li>提供 ServletWebServerFactory</li></ul><h4 id="DispatcherServletAutoConfiguration"><a href="#DispatcherServletAutoConfiguration" class="headerlink" title="DispatcherServletAutoConfiguration"></a>DispatcherServletAutoConfiguration</h4><ul><li>提供 DispatcherServlet</li><li>提供 DispatcherServletRegistrationBean</li></ul><h4 id="WebMvcAutoConfiguration"><a href="#WebMvcAutoConfiguration" class="headerlink" title="WebMvcAutoConfiguration"></a>WebMvcAutoConfiguration</h4><ul><li>配置 DispatcherServlet 的各项组件，提供的 bean 见过的有<ul><li>多项 HandlerMapping</li><li>多项 HandlerAdapter</li><li>HandlerExceptionResolver</li></ul></li></ul><h4 id="ErrorMvcAutoConfiguration"><a href="#ErrorMvcAutoConfiguration" class="headerlink" title="ErrorMvcAutoConfiguration"></a>ErrorMvcAutoConfiguration</h4><ul><li>提供的 bean 有 BasicErrorController</li></ul><h4 id="MultipartAutoConfiguration"><a href="#MultipartAutoConfiguration" class="headerlink" title="MultipartAutoConfiguration"></a>MultipartAutoConfiguration</h4><ul><li>它提供了 org.springframework.web.multipart.support.StandardServletMultipartResolver</li><li>该 bean 用来解析 multipart&#x2F;form-data 格式的数据</li></ul><h4 id="HttpEncodingAutoConfiguration"><a href="#HttpEncodingAutoConfiguration" class="headerlink" title="HttpEncodingAutoConfiguration"></a>HttpEncodingAutoConfiguration</h4><ul><li>POST 请求参数如果有中文，无需特殊设置，这是因为 Spring Boot 已经配置了 org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter</li><li>对应配置 server.servlet.encoding.charset&#x3D;UTF-8，默认就是 UTF-8</li><li>当然，它只影响非 json 格式的数据</li></ul><h4 id="演示-自动配置类原理"><a href="#演示-自动配置类原理" class="headerlink" title="演示 - 自动配置类原理"></a>演示 - 自动配置类原理</h4><h5 id="关键代码-10"><a href="#关键代码-10" class="headerlink" title="关键代码"></a>关键代码</h5><p>假设已有第三方的两个自动配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️第三方的配置类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个配置文件 META-INF&#x2F;spring.factories，key 为导入器类名，值为多个自动配置类名，用逗号分隔</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">MyImportSelector</span>=<span class="string">\</span></span><br><span class="line"><span class="string">AutoConfiguration1,\</span></span><br><span class="line"><span class="string">AutoConfiguration2</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>注意</strong></em></p><ul><li>上述配置文件中 MyImportSelector 与 AutoConfiguration1，AutoConfiguration2 为简洁均省略了包名，自己测试时请将包名根据情况补全</li></ul></blockquote><p>引入自动配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// ⬅️本项目的配置类</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="comment">// ⬇️该方法从 META-INF/spring.factories 读取自动配置类名，返回的 String[] 即为要导入的配置类</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> SpringFactoriesLoader</span><br><span class="line">            .loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>).toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="收获💡-53"><a href="#收获💡-53" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>自动配置类本质上就是一个配置类而已，只是用 META-INF&#x2F;spring.factories 管理，与应用配置类解耦</li><li>@Enable 打头的注解本质是利用了 @Import</li><li>@Import 配合 DeferredImportSelector 即可实现导入，selectImports 方法的返回值即为要导入的配置类名</li><li>DeferredImportSelector 的导入会在最后执行，为的是让其它配置优先解析</li></ol><h3 id="42-条件装配底层"><a href="#42-条件装配底层" class="headerlink" title="42) 条件装配底层"></a>42) 条件装配底层</h3><p>条件装配的底层是本质上是 @Conditional 与 Condition，这两个注解。引入自动配置类时，期望满足一定条件才能被 Spring 管理，不满足则不管理，怎么做呢？</p><p>比如条件是【类路径下必须有 dataSource】这个 bean ，怎么做呢？</p><p>首先编写条件判断类，它实现 Condition 接口，编写条件判断逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition1</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123; </span><br><span class="line">    <span class="comment">// ⬇️如果存在 Druid 依赖，条件成立</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，在要导入的自动配置类上添加 <code>@Conditional(MyCondition1.class)</code>，将来此类被导入时就会做条件检查</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 第三方的配置类</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition1.class)</span> <span class="comment">// ⬅️加入条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别测试加入和去除 druid 依赖，观察 bean1 是否存在于容器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="收获💡-54"><a href="#收获💡-54" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>学习一种特殊的 if - else</li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="43-FactoryBean"><a href="#43-FactoryBean" class="headerlink" title="43) FactoryBean"></a>43) FactoryBean</h3><h4 id="演示-FactoryBean"><a href="#演示-FactoryBean" class="headerlink" title="演示 - FactoryBean"></a>演示 - FactoryBean</h4><h5 id="代码参考-40"><a href="#代码参考-40" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a43</strong> 包</p><h4 id="收获💡-55"><a href="#收获💡-55" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能</li><li>使用上较为古怪, 一不留神就会用错<ol><li>被 FactoryBean 创建的产品<ul><li>会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走</li><li>唯有后初始化的流程会走, 也就是产品可以被代理增强</li><li>单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中</li></ul></li><li>按名字去获取时, 拿到的是产品对象, 名字前面加 &amp; 获取的是工厂对象</li></ol></li></ol><h3 id="44-Indexed-原理"><a href="#44-Indexed-原理" class="headerlink" title="44) @Indexed 原理"></a>44) @Indexed 原理</h3><p>真实项目中，只需要加入以下依赖即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="演示-Indexed"><a href="#演示-Indexed" class="headerlink" title="演示 - @Indexed"></a>演示 - @Indexed</h4><h5 id="代码参考-41"><a href="#代码参考-41" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a44</strong> 包</p><h4 id="收获💡-56"><a href="#收获💡-56" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>在编译时就根据 @Indexed 生成 META-INF&#x2F;spring.components 文件</li><li>扫描时<ul><li>如果发现 META-INF&#x2F;spring.components 存在, 以它为准加载 bean definition</li><li>否则, 会遍历包下所有 class 资源 (包括 jar 内的)</li></ul></li><li>解决的问题，在编译期就找到 @Component 组件，节省运行期间扫描 @Component 的时间</li></ol><h3 id="45-代理进一步理解"><a href="#45-代理进一步理解" class="headerlink" title="45) 代理进一步理解"></a>45) 代理进一步理解</h3><h4 id="演示-代理"><a href="#演示-代理" class="headerlink" title="演示 - 代理"></a>演示 - 代理</h4><h5 id="代码参考-42"><a href="#代码参考-42" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a45</strong> 包</p><h4 id="收获💡-57"><a href="#收获💡-57" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li><p>spring 代理的设计特点</p><ul><li><p>依赖注入和初始化影响的是原始对象</p><ul><li>因此 cglib 不能用 MethodProxy.invokeSuper()</li></ul></li><li><p>代理与目标是两个对象，二者成员变量并不共用数据</p></li></ul></li><li><p>static 方法、final 方法、private 方法均无法增强</p><ul><li>进一步理解代理增强基于方法重写</li></ul></li></ol><h3 id="46-Value-装配底层"><a href="#46-Value-装配底层" class="headerlink" title="46) @Value 装配底层"></a>46) @Value 装配底层</h3><h4 id="按类型装配的步骤"><a href="#按类型装配的步骤" class="headerlink" title="按类型装配的步骤"></a>按类型装配的步骤</h4><ol><li>查看需要的类型是否为 Optional，是，则进行封装（非延迟），否则向下走</li><li>查看需要的类型是否为 ObjectFactory 或 ObjectProvider，是，则进行封装（延迟），否则向下走</li><li>查看需要的类型（成员或参数）上是否用 @Lazy 修饰，是，则返回代理，否则向下走</li><li>解析 @Value 的值<ol><li>如果需要的值是字符串，先解析 ${ }，再解析 #{ }</li><li>不是字符串，需要用 TypeConverter 转换</li></ol></li><li>看需要的类型是否为 Stream、Array、Collection、Map，是，则按集合处理，否则向下走</li><li>在 BeanFactory 的 resolvableDependencies 中找有没有类型合适的对象注入，没有向下走</li><li>在 BeanFactory 及父工厂中找类型匹配的 bean 进行筛选，筛选时会考虑 @Qualifier 及泛型</li><li>结果个数为 0 抛出 NoSuchBeanDefinitionException 异常 </li><li>如果结果 &gt; 1，再根据 @Primary 进行筛选</li><li>如果结果仍 &gt; 1，再根据成员名或变量名进行筛选</li><li>结果仍 &gt; 1，抛出 NoUniqueBeanDefinitionException 异常</li></ol><h4 id="演示-Value-装配过程"><a href="#演示-Value-装配过程" class="headerlink" title="演示 - @Value 装配过程"></a>演示 - @Value 装配过程</h4><h5 id="代码参考-43"><a href="#代码参考-43" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a46</strong> 包</p><h4 id="收获💡-58"><a href="#收获💡-58" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>ContextAnnotationAutowireCandidateResolver 作用之一，获取 @Value 的值</li><li>了解 ${ } 对应的解析器</li><li>了解 #{ } 对应的解析器</li><li>TypeConvert 的一项体现</li></ol><h3 id="47-Autowired-装配底层"><a href="#47-Autowired-装配底层" class="headerlink" title="47) @Autowired 装配底层"></a>47) @Autowired 装配底层</h3><h4 id="演示-Autowired-装配过程"><a href="#演示-Autowired-装配过程" class="headerlink" title="演示 - @Autowired 装配过程"></a>演示 - @Autowired 装配过程</h4><h5 id="代码参考-44"><a href="#代码参考-44" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a47</strong> 包</p><h4 id="收获💡-59"><a href="#收获💡-59" class="headerlink" title="收获💡"></a>收获💡</h4><ol><li>@Autowired 本质上是根据成员变量或方法参数的类型进行装配</li><li>如果待装配类型是 Optional，需要根据 Optional 泛型找到 bean，再封装为 Optional 对象装配</li><li>如果待装配的类型是 ObjectFactory，需要根据 ObjectFactory 泛型创建 ObjectFactory 对象装配<ul><li>此方法可以延迟 bean 的获取</li></ul></li><li>如果待装配的成员变量或方法参数上用 @Lazy 标注，会创建代理对象装配<ul><li>此方法可以延迟真实 bean 的获取</li><li>被装配的代理不作为 bean</li></ul></li><li>如果待装配类型是数组，需要获取数组元素类型，根据此类型找到多个 bean 进行装配</li><li>如果待装配类型是 Collection 或其子接口，需要获取 Collection 泛型，根据此类型找到多个 bean</li><li>如果待装配类型是 ApplicationContext 等特殊类型<ul><li>会在 BeanFactory 的 resolvableDependencies 成员按类型查找装配</li><li>resolvableDependencies 是 map 集合，key 是特殊类型，value 是其对应对象</li><li>不能直接根据 key 进行查找，而是用 isAssignableFrom 逐一尝试右边类型是否可以被赋值给左边的 key 类型</li></ul></li><li>如果待装配类型有泛型参数<ul><li>需要利用 ContextAnnotationAutowireCandidateResolver 按泛型参数类型筛选</li></ul></li><li>如果待装配类型有 @Qualifier<ul><li>需要利用 ContextAnnotationAutowireCandidateResolver 按注解提供的 bean 名称筛选</li></ul></li><li>有 @Primary 标注的 @Component 或 @Bean 的处理</li><li>与成员变量名或方法参数名同名 bean 的处理</li></ol><h3 id="48-事件监听器"><a href="#48-事件监听器" class="headerlink" title="48) 事件监听器"></a>48) 事件监听器</h3><h4 id="演示-事件监听器"><a href="#演示-事件监听器" class="headerlink" title="演示 - 事件监听器"></a>演示 - 事件监听器</h4><h5 id="代码参考-45"><a href="#代码参考-45" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a48</strong> 包</p><h4 id="收获💡-60"><a href="#收获💡-60" class="headerlink" title="收获💡"></a>收获💡</h4><p>事件监听器的两种方式</p><ol><li>实现 ApplicationListener 接口<ul><li>根据接口泛型确定事件类型</li></ul></li><li>@EventListener 标注监听方法<ul><li>根据监听器方法参数确定事件类型</li><li>解析时机：在 SmartInitializingSingleton（所有单例初始化完成后），解析每个单例 bean</li></ul></li></ol><h3 id="49-事件发布器"><a href="#49-事件发布器" class="headerlink" title="49) 事件发布器"></a>49) 事件发布器</h3><h4 id="演示-事件发布器"><a href="#演示-事件发布器" class="headerlink" title="演示 - 事件发布器"></a>演示 - 事件发布器</h4><h5 id="代码参考-46"><a href="#代码参考-46" class="headerlink" title="代码参考"></a>代码参考</h5><p><strong>com.itheima.a49</strong> 包</p><h4 id="收获💡-61"><a href="#收获💡-61" class="headerlink" title="收获💡"></a>收获💡</h4><p>事件发布器模拟实现</p><ol><li>addApplicationListenerBean 负责收集容器中的监听器<ul><li>监听器会统一转换为 GenericApplicationListener 对象，以支持判断事件类型</li></ul></li><li>multicastEvent 遍历监听器集合，发布事件<ul><li>发布前先通过 GenericApplicationListener.supportsEventType 判断支持该事件类型才发事件</li><li>可以利用线程池进行异步发事件优化</li></ul></li><li>如果发送的事件对象不是 ApplicationEvent 类型，Spring 会把它包装为 PayloadApplicationEvent 并用泛型技术解析事件对象的原始类型<ul><li>视频中未讲解</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch DSL常用语句</title>
      <link href="/2022/09/26/ES%20-DSL%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/26/ES%20-DSL%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>学习目标</p><ul><li>ES 实体类FiledType</li><li>基于DSL语句实现各种 ES查询</li><li>基于JAVA代码实各种 ES查询</li></ul><h2 id="ES-实体类型"><a href="#ES-实体类型" class="headerlink" title="ES 实体类型"></a>ES 实体类型</h2><p>元数据类型 官网参考:<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html</a></p><p>Field 自定义字段数据类型参考官网: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</a></p><p>Mapping 作用参考 :<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html</a></p><p>字符串</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>自动</td></tr><tr><td>text</td><td>取代string类型，表示文本，可以最大程度分词器拆分</td></tr><tr><td>keyword</td><td>表示该字段内容是一个文本并作为一个整体不可分，keyword类型的字段只能通过精确值搜索到</td></tr></tbody></table><p>数值型</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>long</td><td>整型long</td></tr><tr><td>integer</td><td>整型int</td></tr><tr><td>short</td><td>-32,768至32768</td></tr><tr><td>byte</td><td>-128至127</td></tr><tr><td>double</td><td>64位双精度IEEE 754浮点类型</td></tr><tr><td>float</td><td>32位单精度IEEE 754浮点类型</td></tr><tr><td>half_float</td><td>16位半精度IEEE 754浮点类型</td></tr><tr><td>scaled_float</td><td>缩放类型的的浮点数（比如价格只需要精确到分，price为57.34的字段缩放因子为100，存起来就是5734）</td></tr></tbody></table><p>日期型</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>date</td><td>日期格式的字符串：e.g. “2015-01-01” or “2015&#x2F;01&#x2F;01 12:10:30” long类型的毫秒数( milliseconds-since-the-epoch) integer的秒数(seconds-since-the-epoch)</td></tr></tbody></table><p>范围型</p><p>布尔型</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>boolean</td><td>用于true、false</td></tr></tbody></table><p>Object对象</p><p>特殊类型</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>ip</td><td>用于存储IPV4或者IPV6的地址</td></tr><tr><td>netsed</td><td>object中的一个特例</td></tr><tr><td>token_coun</td><td>用于统计词频</td></tr><tr><td>geo_point</td><td>经纬度</td></tr></tbody></table><h3 id="常用的-索引库操作-文档操作如下"><a href="#常用的-索引库操作-文档操作如下" class="headerlink" title="常用的 索引库操作 , 文档操作如下"></a>常用的 索引库操作 , 文档操作如下</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;中国人&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;how are you&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;中国人&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;中国人&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;传智播客的黑马程序员学习java太棒了,奥利给!&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建索引库</span><br><span class="line">PUT /demo</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;info&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;email&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;firstName&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;lastName&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看索引库</span><br><span class="line">GET /hotel</span><br><span class="line"></span><br><span class="line">#删除索引库</span><br><span class="line">DELETE /hotel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#给索引库新增字段</span><br><span class="line">PUT /hotel/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;:&#123;</span><br><span class="line">    &quot;age&quot;:&#123;</span><br><span class="line">      &quot;type&quot;:&quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 添加文档</span><br><span class="line">POST /hotel/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;info&quot;:&quot;我是info内容&quot;,</span><br><span class="line">  &quot;email&quot;:&quot;zhaoyun@itcast.cn&quot;,</span><br><span class="line">  &quot;name&quot;:&#123;</span><br><span class="line">    &quot;firstName&quot;:&quot;zhao&quot;,</span><br><span class="line">    &quot;lastName&quot;:&quot;yun&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 根据id查询文档</span><br><span class="line">GET /hotel/_doc/1</span><br><span class="line"></span><br><span class="line"># 根据id删除文档</span><br><span class="line">DELETE /heima/_doc/1</span><br><span class="line"></span><br><span class="line"># 修改文档(增量修改)</span><br><span class="line">POST /hotel/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;email&quot;:&quot;zy@itcast.cn&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建酒店数据索引库</span><br><span class="line">PUT /hotel</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;all&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;address&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;score&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brand&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;all&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;city&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;starName&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;business&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;all&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;pic&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;location&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;all&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#更新索引库,设置自定义拼音分词器。</span><br><span class="line"></span><br><span class="line"># 查询酒店索引库</span><br><span class="line">GET /hotel</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">DELETE /hotel</span><br><span class="line"></span><br><span class="line"># 查询文档</span><br><span class="line">GET /hotel/_doc/36934</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /hotel/_doc/309208</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 无条件查询(默认返回前10条数据)</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="深入搜索和查询"><a href="#深入搜索和查询" class="headerlink" title="深入搜索和查询"></a>深入搜索和查询</h3><p>结构化搜索:对于 结构化字段(日期、时间和数字)对这些格式进行 逻辑搜索，结构化不用关心相关度或评分， 得到的结果 非是记否。</p><p>参考官网教程: <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-in-depth.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/search-in-depth.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#精确值查找：通常跟 过滤器配合使用</span><br><span class="line"></span><br><span class="line">#需求:【精确查询数字 】查询价格为336的酒店 ，就term精确值当做 过滤器的条件执行</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;price&quot;: 336</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#需求:精确查询文本: hotel 品牌是 7天酒店</span><br><span class="line">#SELECT docment FROM  hotle WHERE brand = &#x27;7天酒店&#x27;</span><br><span class="line"></span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;term&quot;: &#123; </span><br><span class="line">                  &quot;brand&quot;:&quot;7天酒店&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#分析使用:组合过滤器: 布尔过滤器 + 精确搜索</span><br><span class="line">#需求 查询 价格 = 336 和 city = 深圳  , 和 星级数 不可以是二钻</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:[&#123;</span><br><span class="line">              &quot;term&quot;: &#123;</span><br><span class="line">                &quot;price&quot;:336</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            ,&#123;&quot;term&quot;: </span><br><span class="line">              &#123;</span><br><span class="line">                &quot;city&quot;:&quot;深圳&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;must_not&quot;:</span><br><span class="line">            [&#123;</span><br><span class="line">              &quot;term&quot;:&#123;</span><br><span class="line">                &quot;starName&quot;:&quot;二钻&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询-地理查询</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;geo_distance&quot;:&#123;</span><br><span class="line">      &quot;location&quot; : &quot;31.047235, 121.46234&quot;,</span><br><span class="line">      &quot;distance&quot;:&quot;15km&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询-全文检索查询</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;all&quot;: &quot;外滩&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查询-复合查询 - 函数算分查询</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;all&quot;: &quot;外滩&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;brand&quot;: &quot;如家&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;:10</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;boost_mode&quot;: &quot;sum&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查询-复合查询 - 布尔查询</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;如家&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;price&quot;: &#123;</span><br><span class="line">              &quot;gt&quot;: 400</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;geo_distance&quot;: &#123;</span><br><span class="line">            &quot;distance&quot;: &quot;10km&quot;,</span><br><span class="line">            &quot;location&quot;:&quot;31.21,121.5&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#结果处理- 排序 </span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#结果处理- 排序 (简写语法)</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#结果处理- 排序 (多字段排序)</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &quot;asc&quot;,</span><br><span class="line">      &quot;score&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#结果处理- 排序 (距离排序)</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_geo_distance&quot;: &#123;</span><br><span class="line">        &quot;location&quot;: &quot;22.642729, 114.202899&quot;,</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;,</span><br><span class="line">        &quot;unit&quot;: &quot;km&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#结果处理- 分页</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 2,</span><br><span class="line">  &quot;size&quot;: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 10000,</span><br><span class="line">  &quot;size&quot;: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查询结果处理-高亮</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;如家&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,</span><br><span class="line">        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查询结果处理-高亮</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;all&quot;: &quot;外滩&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,</span><br><span class="line">        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot;,</span><br><span class="line">        &quot;require_field_match&quot;: &quot;false&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;city&quot;: &quot;北京&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,</span><br><span class="line">        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot;,</span><br><span class="line">        &quot;require_field_match&quot;: &quot;false&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#高亮显示</span><br><span class="line">POST /hotel/_update/36934</span><br><span class="line">&#123;</span><br><span class="line">&quot;doc&quot;:&#123;</span><br><span class="line">&quot;isAD&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /hotel/_update/38609</span><br><span class="line">&#123;</span><br><span class="line">&quot;doc&quot;:&#123;</span><br><span class="line">&quot;isAD&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全文搜索:</p><ul><li>针对有analyzer分词器 的字段进行搜索, 有相关性（Relevance）和分析性(Analysis)</li><li>所有查询会或多或少的执行相关度计算，但不是所有查询都有分析阶段</li></ul><p>text 文本查询可以划分两大家族:</p><ol><li>基于词项的查询(少用)</li><li>基于全文的查询</li></ol><ul><li>如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。</li><li>如果查询一个（ not_analyzed ）未分析的精确值字符串字段，它们会将整个查询字符串作为单个词项对待。</li><li>但如果要查询一个（ analyzed ）已分析的全文字段，它们会先将查询字符串传递到一个合适的<strong>分析器</strong>，然后生成一个供查询的词项<strong>列表集合</strong>。</li><li>一旦组成了词项列表，这个查询会对每个词项<strong>逐一执行底层的查询</strong>，然后<strong>结果合并</strong>，最终为每个文档生成一个最终的相关匹配度评分</li></ul><p>match 查询 是一个高级的单字段全文查询 ，这表示它既能处理全文字段，又能处理精确字段。<br>mult_match查询:多字段全文查询,任意一个词符合条件就算符合查询条件</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#需求 全文搜索带有 如家 一词的全部酒店信息</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;match&quot;:&#123;</span><br><span class="line">      &quot;name&quot;:&quot;如家&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#需求 全文搜索 某些字段 带有&quot;如家&quot;的酒店信息</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;如家&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;name&quot;,&quot;brand&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基于JAVA实现ES查询"><a href="#基于JAVA实现ES查询" class="headerlink" title="基于JAVA实现ES查询"></a>基于JAVA实现ES查询</h3><blockquote><p>涉及到的类和流程</p></blockquote><ol><li>通过RestHighLevelClient 创建 RestClient</li><li>创建Request 接口(SearchRequest, IndexRequest….)</li><li>通过request.source() 获取 sourceBuilder 对象</li><li>调用sourceBuilder对象的各种查询</li><li>QueryBuilder 封装了各种查询的搜索方法</li></ol><p>无条件查询 match_all</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>match、multi_math、term、range查询</p><p>bool查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">排序、分页</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">解析响应结果</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">高亮</span><br></pre></td></tr></table></figure><h2 id="ES高阶"><a href="#ES高阶" class="headerlink" title="ES高阶"></a>ES高阶</h2><h3 id="数据聚合-统计，最大最小值、分析"><a href="#数据聚合-统计，最大最小值、分析" class="headerlink" title="数据聚合(统计，最大最小值、分析)"></a>数据聚合(统计，最大最小值、分析)</h3><p>数据聚合是对 ES 的文档、搜索结果集、进行统计、分析、相当于SQL 的聚合函数。<br>聚合的官网介绍:<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html</a></p><p>!!! : 参与聚合的字段类型必须是 <strong>keyword , 数值,日期,布尔</strong></p><blockquote><p>桶聚合(Bucket aggregations) 是对文档数据做分组，相当于SQL的 group by。<br>  Metric 聚合:<br>  Pipeline 管道聚合: 以其他聚合的结果集进行二次聚合</p></blockquote><h4 id="基本的聚合DSL语句"><a href="#基本的聚合DSL语句" class="headerlink" title="基本的聚合DSL语句"></a>基本的聚合DSL语句</h4><pre><code>#需求: 统计所有数据的酒店品牌有几种#使用 aggsGET /hotel/_search&#123;  &quot;size&quot;: 0,  // 设置size为0，结果中不包含文档，只包含聚合结果  &quot;aggs&quot;: &#123; // 定义聚合    &quot;brandAgg&quot;: &#123; //给聚合起个名字      &quot;terms&quot;: &#123; // 聚合的类型，按照品牌值聚合，所以选择term        &quot;field&quot;: &quot;brand&quot;, // 参与聚合的字段        &quot;size&quot;: 20 // 希望获取的聚合结果数量      &#125;    &#125;  &#125;&#125;&#123;% asset_img image-20210723171948228.png 结果集 %&#125;#### 基于RestClient Java实现数据### 自动补全的是西安### 数据同步### 索引库集群</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2022/09/21/SpringSecurity%E5%92%8C%20JWT%20%E8%B5%84%E6%BA%90%E9%89%B4%E6%9D%83/"/>
      <url>/2022/09/21/SpringSecurity%E5%92%8C%20JWT%20%E8%B5%84%E6%BA%90%E9%89%B4%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>SpringSecurity的应用场景 认证和授权</li></ul><h2 id="认证授权原理和”替换思维”"><a href="#认证授权原理和”替换思维”" class="headerlink" title="认证授权原理和”替换思维”"></a>认证授权原理和”替换思维”</h2><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>实现两个功能的思路：</p><p>登录</p><ol><li>在Controller层代码自定义登录接口<br> 调用ProvideManager的方法进行认证, 如果认证成功生成jwt<br> 把用户信息存入Redis</li><li>自定义UserDetailsService<br> 实现类从数据库读取用户的信息,而不是使用默认的SprngSecurity去内存中去读取用户信息。</li></ol><p>校验</p><ol><li>定义jwt认证过滤器<br> 获取token<br> 解析token其中的userId<br> 从Redis获取用户信息<br> 更新Redis内容,SecurityContextHolder中给其他过滤器&#x2F;资源使用</li></ol><p>准备工作：</p><ul><li><p>添加依赖包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!----&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.76&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>设置redis 参数属性</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务(上)</title>
      <link href="/2022/09/18/SpringCloud-1/"/>
      <url>/2022/09/18/SpringCloud-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="微服务是什么"><a href="#微服务是什么" class="headerlink" title="微服务是什么?"></a>微服务是什么?</h2><h3 id="微服务的关键技术"><a href="#微服务的关键技术" class="headerlink" title="微服务的关键技术"></a>微服务的关键技术</h3><p>服务集群:<br>注册中心:<br>配置中心:<br>服务网关:<br>分布式缓存：<br>分布式搜索：支持复杂条件查询,使用ES集群实现搜索<br>消息队列：使用异步通信,提高系统吞吐量<br>分布式日志服务中心：服务异常日志记录<br>系统监控链路追踪：报警信息，异常通知<br>自动化部署：Jenkins- Docker ,K8S,Rancher</p><h3 id="主流的微服务技术"><a href="#主流的微服务技术" class="headerlink" title="主流的微服务技术"></a>主流的微服务技术</h3><table><thead><tr><th></th><th>Dubbo</th><th>SpringCloud</th><th>SpringCloudAlibaba</th></tr></thead><tbody><tr><td>注册中心</td><td>无注册中心,借用Zookeeper,Redis</td><td>Eureka、Consul</td><td>Nacos、Eureka</td></tr><tr><td>服务远程调用</td><td>Dubbo协议</td><td>Feign（http协议）</td><td>Dubbo、Feign</td></tr><tr><td>配置中心</td><td>无</td><td>SpringCloudConfig</td><td>SpringCloudConfig、Nacos</td></tr><tr><td>服务网管</td><td>无</td><td>SpringCloudGateway,Zuul</td><td>SpringCloudGateway,Zuul</td></tr><tr><td>服务监控和保护</td><td>dubbo-admin,功能弱</td><td>Hystrix</td><td>Sentinel</td></tr></tbody></table><h3 id="主流的企业技术要求"><a href="#主流的企业技术要求" class="headerlink" title="主流的企业技术要求"></a>主流的企业技术要求</h3><p>SpringCloud+Feign<br>SpringCloudAlibaba+Feign<br>SpringCloudAlibaba+Dubbo</p><h3 id="SpringCloud-的背景"><a href="#SpringCloud-的背景" class="headerlink" title="SpringCloud 的背景"></a>SpringCloud 的背景</h3><p>1)单体应用的缺点: 1)部分模块出现问题影响整个应用。 2)功能的修改或删除,需要重新发布和部署,成本提高 3)技术栈受限,要求应用必须使用相同的开发语言<br>2)由于 JAVAEE 的分布式系统模式搭建 复杂，初学者难以学习。SpringCloud提供了简单易用的编程模型,<br>帮助开发者快速构建有弹性,可靠的分布式应用。在SpringBoot的基础上构建的，提供了以下架构的工具：</p><ol><li>配置管理</li><li>服务发现</li><li>断路器</li><li>智能路由</li><li>微代理</li><li>控制总线</li><li>一次性令牌</li><li>全局锁定</li><li>分布式会话</li><li>集群状态<br>….</li></ol><h3 id="SpringCloud版本"><a href="#SpringCloud版本" class="headerlink" title="SpringCloud版本"></a>SpringCloud版本</h3><p>SpringCloud 版本以英国地铁站名字 和 根据字母表排序(A~Z)进行命名: Dalston , Edgware , Finchley, Greenwich,Hoxton….</p><p>Tips:Greenwich版本是基于SpringBoot 2.1.x版本构建的，不适用于1.5.x版本。随着2019年8月SpringBoot 1.5.x版本停止维护，Edgware版本也将停止维护。<br>推荐使用 Greenwich.SR2 版本及以上</p><p><strong>重点</strong>以字母（A-Z）排序,有以下常见的组件:</p><table><thead><tr><th>Component</th><th>简介</th><th>学习程度</th></tr></thead><tbody><tr><td>spring-cloud-bus</td><td></td><td>熟练使用</td></tr><tr><td>spring-cloud-commons</td><td></td><td></td></tr><tr><td>spring-cloud-config</td><td>集中配置管理工具,管理分布式系统所有的外部配置,默认使用Git存储配置</td><td></td></tr><tr><td>spring-cloud-netflix</td><td>Netfilx OSS开源组件集成:Eureka、Hystrix、Ribbon、Feign、Zuul</td><td>重点掌握</td></tr><tr><td>spring-cloud-security</td><td>安装工具包,支持Zuul代理的负载均衡OAuth2客户端及登录认证</td><td>熟练使用</td></tr><tr><td>spring-cloud-stream</td><td>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ</td><td>重点掌握</td></tr><tr><td>spring-cloud-zookeeper</td><td>基于Apache Zookeeper的服务治理组件</td><td>重点掌握</td></tr><tr><td>spring-boot</td><td></td><td></td></tr><tr><td>spring-cloud-task</td><td></td><td></td></tr><tr><td>spring-cloud-gateway</td><td>API网关组件，对请求提供路由及过滤功能</td><td>重点掌握</td></tr></tbody></table><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="/2022/09/18/SpringCloud-1/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="/2022/09/18/SpringCloud-1/image-20210713210800950.png" alt="image-20210713210800950"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务cloud-demo为例，其结构如下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713211009593.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露Restful的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入Sql语句"><a href="#2-2-1-导入Sql语句" class="headerlink" title="2.2.1.导入Sql语句"></a>2.2.1.导入Sql语句</h3><p>首先，创建2个mysql数据库（<strong>cloud_order、cloud_user</strong>，注意：数据库名称中为<strong>下划线</strong>），然后将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user表中初始数据如下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order表中初始数据如下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order表中持有cloud-user表中的id字段。</p><h3 id="2-2-2-导入demo工程"><a href="#2-2-2-导入demo工程" class="headerlink" title="2.2.2.导入demo工程"></a>2.2.2.导入demo工程</h3><p>用IDEA导入课前资料提供的Demo：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713211814094.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在IDEA右下角出现弹窗：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713212349272.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的JDK：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在order-service服务中，有一个根据id查询订单的接口：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据id查询订单，返回值是Order对象，如图：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的user为null</p><p>在user-service中有一个根据id查询用户的接口：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在order-service中 向user-service发起一个http的请求，调用<a href="http://localhost:8081/user/%7BuserId%7D%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个RestTemplate的实例到Spring容器</li><li>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</li><li>将查询的User填充到Order对象，一起返回</li></ul><h3 id="2-3-2-注册RestTemplate"><a href="#2-3-2-注册RestTemplate" class="headerlink" title="2.3.2.注册RestTemplate"></a>2.3.2.注册RestTemplate</h3><p>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713213959569.png" alt="image-20210713213959569"></p><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</p><ul><li>对于A调用B的业务而言：A是服务消费者，B是服务提供者</li><li>对于B调用C的业务而言：B是服务消费者，C是服务提供者</li></ul><p>因此，服务B既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka注册中心"><a href="#3-Eureka注册中心" class="headerlink" title="3.Eureka注册中心"></a>3.Eureka注册中心</h1><p>假如我们的服务提供者user-service部署了多个实例，如图：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</li><li>有多个user-service实例地址，order-service调用时该如何选择？</li><li>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka的结构和作用"><a href="#3-1-Eureka的结构和作用" class="headerlink" title="3.1.Eureka的结构和作用"></a>3.1.Eureka的结构和作用</h2><p>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题1：order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建eureka-server"><a href="#3-2-搭建eureka-server" class="headerlink" title="3.2.搭建eureka-server"></a>3.2.搭建eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建eureka-server服务"><a href="#3-2-1-创建eureka-server服务" class="headerlink" title="3.2.1.创建eureka-server服务"></a>3.2.1.创建eureka-server服务</h3><p>在cloud-demo父工程下，创建一个子模块：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713220857396.png" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713221339022.png" alt="image-20210713221339022"></p><h3 id="3-2-2-引入eureka依赖"><a href="#3-2-2-引入eureka依赖" class="headerlink" title="3.2.2.引入eureka依赖"></a>3.2.2.引入eureka依赖</h3><p>引入SpringCloud为eureka提供的starter依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意点：&#x3D;&#x3D;</p><ul><li>不加 eureka.client.service-url-defaultZone 配置：启动时会寻找注册中心（用默认端口）</li><li>加上 eureka.client.service-url-defaultZone 配置：启动时会寻找注册中心（10086端口）</li><li>fetch-registry: false #关闭作为客户端时从eureka server获取服务信息</li><li>register-with-eureka: false #不再将自己同时作为客户端进行注册（作为一个纯的eureka server，关闭eureka client）</li></ul><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086/">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将user-service注册到eureka-server中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在user-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）启动多个user-service实例"><a href="#3）启动多个user-service实例" class="headerlink" title="3）启动多个user-service实例"></a>3）启动多个user-service实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</p><p>首先，复制原来的user-service启动配置：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713222757702.png" alt="image-20210713222757702"></p><p>现在，SpringBoot窗口会出现两个user-service启动配置：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是8081端口，第二个是8082端口。</p><p>启动两个user-service实例：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713224245731.png" alt="image-20210713224245731"></p><p>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><h1 id="4-Ribbon负载均衡"><a href="#4-Ribbon负载均衡" class="headerlink" title="4.Ribbon负载均衡"></a>4.Ribbon负载均衡</h1><p>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是<a href="http://userservice/user/1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E4%BA%86http://localhost:8081%E7%9A%84%E5%91%A2%EF%BC%9F">http://userservice/user/1，怎么变成了http://localhost:8081的呢？</a></p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="/2022/09/18/SpringCloud-1/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入execute方法：</p><p><img src="/2022/09/18/SpringCloud-1/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081：</p><p> <img src="/2022/09/18/SpringCloud-1/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略IRule"><a href="#3）负载均衡策略IRule" class="headerlink" title="3）负载均衡策略IRule"></a>3）负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p> <img src="/2022/09/18/SpringCloud-1/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="/2022/09/18/SpringCloud-1/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p> <img src="/2022/09/18/SpringCloud-1/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="/2022/09/18/SpringCloud-1/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="/2022/09/18/SpringCloud-1/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</clientConfigNameSpace></clientName></td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure><h1 id="5-Nacos注册中心"><a href="#5-Nacos注册中心" class="headerlink" title="5.Nacos注册中心"></a>5.Nacos注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</p><h2 id="5-1-认识和安装Nacos"><a href="#5-1-认识和安装Nacos" class="headerlink" title="5.1.认识和安装Nacos"></a>5.1.认识和安装Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713230444308.png" alt="image-20210713230444308"></p><p>安装方式可以参考课前资料《Nacos安装指南.md》</p><h2 id="5-2-服务注册到nacos"><a href="#5-2-服务注册到nacos" class="headerlink" title="5.2.服务注册到nacos"></a>5.2.服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote><h3 id="2）配置nacos地址"><a href="#2）配置nacos地址" class="headerlink" title="2）配置nacos地址"></a>2）配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="/2022/09/18/SpringCloud-1/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="5-5-2-给微服务配置namespace"><a href="#5-5-2-给微服务配置namespace" class="headerlink" title="5.5.2.给微服务配置namespace"></a>5.5.2.给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos与Eureka的区别"><a href="#5-6-Nacos与Eureka的区别" class="headerlink" title="5.6.Nacos与Eureka的区别"></a>5.6.Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="/2022/09/18/SpringCloud-1/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SrpingCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringWebSocket的使用</title>
      <link href="/2022/09/17/Spring%E6%95%B4%E5%90%88WebSocket/"/>
      <url>/2022/09/17/Spring%E6%95%B4%E5%90%88WebSocket/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="/2022/09/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>复杂度分析</li><li></li></ul><h3 id="大O复杂度表示法-记住四个原则"><a href="#大O复杂度表示法-记住四个原则" class="headerlink" title="大O复杂度表示法 记住四个原则"></a>大O复杂度表示法 记住四个原则</h3><p>首先要清楚基础概念,在CPU上运行的角度上看, 每一条语句执行类似的操作:”读数据 - 运算 - 写数据”。因此在CPU上的每一次操作都是原子性操作，譬如 i &#x3D; 1;  代表 cpu 将1写入到 i 变量就是一次原子性操作。</p><h4 id="原则1-一段代码的总执行时间-T-n-等于-每一条语句总执行次数-累加数-成正比"><a href="#原则1-一段代码的总执行时间-T-n-等于-每一条语句总执行次数-累加数-成正比" class="headerlink" title="原则1 一段代码的总执行时间 T(n)等于 每一条语句总执行次数(累加数) 成正比"></a>原则1 一段代码的总执行时间 T(n)等于 每一条语句总执行次数(累加数) 成正比</h4><p>把CPU 的一次原子性操作当做一个unit_time。分析如下代码的T(n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cal(int n)&#123;</span><br><span class="line">   int sum = 0; //原子性操作执行1次,CPU 将 10 写入到sum 的工作内存地址中  </span><br><span class="line">   int i = 1;   //原子性操作执行1次,CPU 将 1 写入到 变量 i 的工作内存地址中</span><br><span class="line">   for (int i = 0; i &lt; n; ++i)&#123;  // 这行代码执行n 次</span><br><span class="line">       sum = sum + i;    // 这行代码执行n 次 </span><br><span class="line">   &#125;</span><br><span class="line">   return sum; // 执行1次,返回存储在 sum 内存地址的值</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>分析得出上述 T(n) &#x3D; (2n+3) * unit_time</p><h4 id="原则2-时间复杂度公式中的-低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。"><a href="#原则2-时间复杂度公式中的-低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。" class="headerlink" title="原则2 时间复杂度公式中的 低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。"></a>原则2 时间复杂度公式中的 低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。</h4><p>由上述 得出 T(n) &#x3D; (2n+3)*unit_time  &#x3D; O(f(n)) &#x2F;&#x2F; f(n)表示每一条代码语句执行次数的累加和<br>unit_time 不变, 系数为2 , 常量为3 。因此用大O表示法简写为： <strong>O(n)</strong></p><h4 id="原则3-加法法则-代码总复杂度等于量级最大的那段代码的复杂度。"><a href="#原则3-加法法则-代码总复杂度等于量级最大的那段代码的复杂度。" class="headerlink" title="原则3 加法法则:代码总复杂度等于量级最大的那段代码的复杂度。"></a>原则3 加法法则:代码总复杂度等于量级最大的那段代码的复杂度。</h4><p>通常会忽略公式中的常量,低阶和系数,只记录最大量级的基础上，我们也只需要关注 循环执行次数最多的那段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cal(int n)&#123;</span><br><span class="line">    int sum = 0; //原子性操作执行1次,CPU 将 10 写入到sum 的工作内存地址中  </span><br><span class="line">    int i = 1;   //原子性操作执行1次,CPU 将 1 写入到 变量 i 的工作内存地址中</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)&#123;  // 这行代码执行n 次</span><br><span class="line">        sum = sum + i;    // 这行代码执行n 次 </span><br><span class="line">    &#125;</span><br><span class="line">    return sum; // 执行1次,返回存储在 sum 内存地址的值</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>上述代码 , 循环执行次数最多的那段代码在 3,4行 ,因此 重点关注。</p><h4 id="原则4-乘法法则-嵌套代码的复杂度等于-嵌套内外代码复杂度的乘积"><a href="#原则4-乘法法则-嵌套代码的复杂度等于-嵌套内外代码复杂度的乘积" class="headerlink" title="原则4 乘法法则:嵌套代码的复杂度等于 嵌套内外代码复杂度的乘积"></a>原则4 乘法法则:嵌套代码的复杂度等于 嵌套内外代码复杂度的乘积</h4><p>根据乘法法则分析以下代码的时间复杂度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cal(int)&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 1;</span><br><span class="line">    int j = 1;</span><br><span class="line">    for(int i=0;i&lt;= n;++i)&#123;   // ++i 执行了 n次</span><br><span class="line">        j=1;   //执行 了n次 </span><br><span class="line">        for(int j=0;j&lt;=n;++j)&#123;  // ++j 执行了 n次</span><br><span class="line">            sum = sum + i * j;   // 执行了 n 次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析得出 T1(n) </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus技術详解</title>
      <link href="/2022/09/11/MybatisPlus/"/>
      <url>/2022/09/11/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="一、MyBatisPlus简介"><a href="#一、MyBatisPlus简介" class="headerlink" title="一、MyBatisPlus简介"></a>一、MyBatisPlus简介</h2><h3 id="1-入门案例"><a href="#1-入门案例" class="headerlink" title="1. 入门案例"></a>1. 入门案例</h3><h4 id="问题导入"><a href="#问题导入" class="headerlink" title="问题导入"></a>问题导入</h4><p>MyBatisPlus环境搭建的步骤？</p><h4 id="SpringBoot整合MyBatisPlus入门程序"><a href="#SpringBoot整合MyBatisPlus入门程序" class="headerlink" title="SpringBoot整合MyBatisPlus入门程序"></a>SpringBoot整合MyBatisPlus入门程序</h4><h5 id="1-创建新模块，maven模块"><a href="#1-创建新模块，maven模块" class="headerlink" title="1. 创建新模块，maven模块"></a>1. 创建新模块，maven模块</h5><img src="/2022/09/11/MybatisPlus/image-20220530180049323.png" alt="image-20220530180049323" style="zoom:80%;"> <h5 id="2-添加相关的起步依赖"><a href="#2-添加相关的起步依赖" class="headerlink" title="2. 添加相关的起步依赖"></a>2. 添加相关的起步依赖</h5><p>pom.xml文件如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springboot--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- spring整合test --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mybatis-plus的驱动包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mysql要选择正确版本的驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意事项：如果使用Druid数据源，需要导入对应坐标</strong></p><p>底层依赖了mybatis的包</p><p><img src="/2022/09/11/MybatisPlus/image-20220617085047328.png" alt="image-20220617085047328"> </p><h5 id="3-创建启动类"><a href="#3-创建启动类" class="headerlink" title="3. 创建启动类"></a>3. 创建启动类</h5><p> <img src="/2022/09/11/MybatisPlus/image-20220601221700885.png" alt="image-20220601221700885"> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MpApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-制作实体类与表结构"><a href="#4-制作实体类与表结构" class="headerlink" title="4. 制作实体类与表结构"></a>4. 制作实体类与表结构</h5><p>目前：类名与表名对应，属性名与字段名对应</p><p>SQL脚本</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> mybatisplus_db <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br><span class="line">USE mybatisplus_db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">            id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">            `name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">            gender <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">            `password`  <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">            age <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">            tel <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;Rose&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">15</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;NewBoy&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;Kate&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;张晓&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;张大炮&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="number">16</span>,<span class="string">&#x27;12345678910&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/MybatisPlus/image-20211113151449428.png" alt="image-20211113151449428"> </p><p>在domain目录下创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String tel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-设置Jdbc参数（application-yml）"><a href="#5-设置Jdbc参数（application-yml）" class="headerlink" title="5. 设置Jdbc参数（application.yml）"></a>5. 设置Jdbc参数（<strong>application.yml</strong>）</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据源的配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql:///mybatisplus_db?useSSL=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示SQL语句</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h5 id="6-定义数据接口，继承BaseMapper"><a href="#6-定义数据接口，继承BaseMapper" class="headerlink" title="6. 定义数据接口，继承BaseMapper"></a>6. 定义数据接口，继承<strong>BaseMapper</strong></h5><p>接口上要添加@Mapper注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-测试类中注入dao接口，测试功能"><a href="#7-测试类中注入dao接口，测试功能" class="headerlink" title="7. 测试类中注入dao接口，测试功能"></a>7. 测试类中注入dao接口，测试功能</h5><ol><li>测试类上添加@SpringBootTest注解</li><li>注入UserMapper</li><li>selectList查询所有用户，参数为null</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-MyBatisPlus概述"><a href="#2-MyBatisPlus概述" class="headerlink" title="2. MyBatisPlus概述"></a>2. MyBatisPlus概述</h3><h4 id="问题导入-1"><a href="#问题导入-1" class="headerlink" title="问题导入"></a>问题导入</h4><p>通过入门案例制作，MyBatisPlus的优点有哪些？</p><h4 id="1-MyBatis介绍"><a href="#1-MyBatis介绍" class="headerlink" title="1. MyBatis介绍"></a>1. MyBatis介绍</h4><ul><li><p>MyBatisPlus（简称MP）是基于MyBatis框架基础上开发的增强型工具，旨在简化开发、提高效率</p></li><li><p>官网：<a href="https://mp.baomidou.com/">https://mp.baomidou.com</a><a href="https://mp.baomidou.com/">&#x2F;</a></p></li></ul><h4 id="2-MyBatisPlus特性"><a href="#2-MyBatisPlus特性" class="headerlink" title="2. MyBatisPlus特性"></a>2. MyBatisPlus特性</h4><ul><li>无侵入：只做增强不做改变，不会对现有工程产生影响</li><li>强大的 CRUD 操作：内置通用 Mapper，少量配置即可实现单表CRUD 操作</li><li>支持 Lambda：编写查询条件无需担心字段写错</li><li>支持主键自动生成</li><li>内置分页插件</li><li>……</li></ul><h2 id="二、标准数据层开发"><a href="#二、标准数据层开发" class="headerlink" title="二、标准数据层开发"></a>二、标准数据层开发</h2><h3 id="1-MyBatisPlus的CRUD操作"><a href="#1-MyBatisPlus的CRUD操作" class="headerlink" title="1. MyBatisPlus的CRUD操作"></a>1. MyBatisPlus的CRUD操作</h3><p><img src="/2022/09/11/MybatisPlus/image-20210815150629727.png" alt="image-20210815150629727"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo1StandardTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;itheima&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">12</span>);</span><br><span class="line">        user.setTel(<span class="string">&quot;4006184000&quot;</span>);</span><br><span class="line">        user.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改：只有字段有值的才会生成update中的set语句代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">2L</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Tom888&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;tom888&quot;</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过id查询用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">2L</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(userList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-MyBatisPlus分页功能"><a href="#2-MyBatisPlus分页功能" class="headerlink" title="2. MyBatisPlus分页功能"></a>2. MyBatisPlus分页功能</h3><h4 id="问题导入-2"><a href="#问题导入-2" class="headerlink" title="问题导入"></a>问题导入</h4><p>思考一下Mybatis分页插件是如何用的？</p><h4 id="1-分页功能接口"><a href="#1-分页功能接口" class="headerlink" title="1 分页功能接口"></a>1 分页功能接口</h4><p><img src="/2022/09/11/MybatisPlus/image-20210801180723261.png" alt="image-20210801180723261"></p><h4 id="2-MyBatisPlus分页使用"><a href="#2-MyBatisPlus分页使用" class="headerlink" title="2 MyBatisPlus分页使用"></a>2 MyBatisPlus分页使用</h4><p><strong>①：设置分页拦截器作为Spring管理的bean</strong></p><ol><li>在config包下创建一个配置类：MybatisPlusConfig</li><li>在类上添加@Configuration</li><li>编写方法<ol><li>方法上使用@Bean注解：添加<code>MybatisPlusInterceptor</code>对象到容器中</li><li>创建MybatisPlusInterceptor拦截器对象</li><li>添加内部分页拦截器：创建PaginationInnerInterceptor</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建MybatisPlusInterceptor拦截器对象</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2 添加内部分页拦截器</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②：在测试类中执行分页查询</strong></p><ol><li>创建分页对象，前面是接口IPage，后面是实现类Page(第几页，每页大小)</li><li>调用selectPage方法，传入page对象，无需接收返回值</li><li>获取分页结果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1 创建IPage分页对象,设置分页参数(第几页，每页大小)</span></span><br><span class="line">    IPage&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//2 执行分页查询，无需接收返回值</span></span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//3 获取分页结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前页码值：&quot;</span>+page.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示数：&quot;</span>+page.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+page.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页数据：&quot;</span>+page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、DQL编程控制"><a href="#三、DQL编程控制" class="headerlink" title="三、DQL编程控制"></a>三、DQL编程控制</h2><h3 id="1-条件查询方式"><a href="#1-条件查询方式" class="headerlink" title="1. 条件查询方式"></a>1. 条件查询方式</h3><ul><li>MyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合</li></ul><img src="/2022/09/11/MybatisPlus/image-20210801181232962.png" alt="image-20210801181232962" style="zoom:80%;"> <h4 id="1-1-条件查询"><a href="#1-1-条件查询" class="headerlink" title="1.1 条件查询"></a>1.1 条件查询</h4><p>创建新的测试类：Demo2ConditionTest</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2ConditionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-1-方式一：按条件查询"><a href="#1-1-1-方式一：按条件查询" class="headerlink" title="1.1.1 方式一：按条件查询"></a>1.1.1 方式一：按条件查询</h5><p>查询年龄大于18岁的用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建查询条件封装对象，可以指定泛型</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    <span class="comment">//2.字段age大于18</span></span><br><span class="line">    wrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">//3.执行查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-2-方式二：lambda格式按条件查询（推荐）"><a href="#1-1-2-方式二：lambda格式按条件查询（推荐）" class="headerlink" title="1.1.2 方式二：lambda格式按条件查询（推荐）"></a>1.1.2 方式二：lambda格式按条件查询（推荐）</h5><p>查询年龄小于10的用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建lambda查询包装器，支持泛型</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>();</span><br><span class="line">    <span class="comment">//2. 使用lambda参数，相当于调用 user -&gt; user.getAge()方法，获取列名</span></span><br><span class="line">    wrapper.le(User::getAge, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//3.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-组合条件"><a href="#1-2-组合条件" class="headerlink" title="1.2 组合条件"></a>1.2 组合条件</h4><h5 id="1-2-1-并且关系（and）"><a href="#1-2-1-并且关系（and）" class="headerlink" title="1.2.1 并且关系（and）"></a>1.2.1 并且关系（and）</h5><p>查询年龄小于30岁，而且大于10岁的用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAnd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//并且关系</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//支持链式写法</span></span><br><span class="line">    wrapper.lt(User::getAge, <span class="number">30</span>).gt(User::getAge, <span class="number">10</span>);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,password,age,tel FROM user WHERE (age &lt; ? AND age &gt; ?)</span><br></pre></td></tr></table></figure><h5 id="1-2-2-或者关系（or）"><a href="#1-2-2-或者关系（or）" class="headerlink" title="1.2.2 或者关系（or）"></a>1.2.2 或者关系（or）</h5><p>查询年龄小于10岁或者大于30岁的用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOr</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//或者关系：小于10岁或者大于30岁</span></span><br><span class="line">    wrapper.lt(User::getAge, <span class="number">10</span>).or().gt(User::getAge, <span class="number">30</span>);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,password,age,tel FROM user WHERE (age &lt; ? OR age &gt; ?)</span><br></pre></td></tr></table></figure><h4 id="1-3-NULL值处理"><a href="#1-3-NULL值处理" class="headerlink" title="1.3 NULL值处理"></a>1.3 NULL值处理</h4><h5 id="问题导入-3"><a href="#问题导入-3" class="headerlink" title="问题导入"></a>问题导入</h5><p>如下搜索场景，在多条件查询中，有条件的值为空应该怎么解决？</p><p><img src="/2022/09/11/MybatisPlus/image-20210801182004226.png" alt="image-20210801182004226"></p><h5 id="1-3-1-if语句控制条件追加"><a href="#1-3-1-if语句控制条件追加" class="headerlink" title="1.3.1 if语句控制条件追加"></a>1.3.1 if语句控制条件追加</h5><ul><li>如果最小年龄不为空，则查询大于这个年龄的用户</li><li>如果最大年龄不为空，则查询小于这个年龄的用户</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testNullValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minAge</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//将来有用户传递进来,此处简化成直接定义变量了</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxAge</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//将来有用户传递进来,此处简化成直接定义变量了</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (minAge != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.gt(User::getAge, minAge);  <span class="comment">//大于</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxAge != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.lt(User::getAge, maxAge);  <span class="comment">//小于</span></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-2-条件参数控制"><a href="#1-3-2-条件参数控制" class="headerlink" title="1.3.2 条件参数控制"></a>1.3.2 条件参数控制</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    Integer minAge=<span class="number">10</span>;  <span class="comment">//将来有用户传递进来,此处简化成直接定义变量了</span></span><br><span class="line">    Integer maxAge=<span class="literal">null</span>;  <span class="comment">//将来有用户传递进来,此处简化成直接定义变量了</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//参数1：如果表达式为true，那么查询才使用该条件，也支持链式编程</span></span><br><span class="line">    wrapper.gt(minAge != <span class="literal">null</span>, User::getAge, minAge);</span><br><span class="line">    wrapper.lt(maxAge != <span class="literal">null</span>, User::getAge, maxAge);</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查询投影-设置【查询字段、分组、分页】"><a href="#2-查询投影-设置【查询字段、分组、分页】" class="headerlink" title="2. 查询投影-设置【查询字段、分组、分页】"></a>2. 查询投影-设置【查询字段、分组、分页】</h3><p>创建新的测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询投影</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3ProjectionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-查询结果包含模型类中部分属性"><a href="#1-查询结果包含模型类中部分属性" class="headerlink" title="1 查询结果包含模型类中部分属性"></a>1 查询结果包含模型类中部分属性</h4><p>查询所有用户，只显示id, name, age三个属性，不是全部列。</p><p>使用<code>select(列名...)</code>方法，查询的结果如果封装成实体类，则只有这三个属性有值，其它属性为NULL</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSameColumn</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询所有用户，只显示id, name, age三个属性，不是全部列</span></span><br><span class="line">    wrapper.select(User::getId, User::getName, User::getAge);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,age FROM user</span><br></pre></td></tr></table></figure><h4 id="2-查询结果包含模型类中未定义的属性"><a href="#2-查询结果包含模型类中未定义的属性" class="headerlink" title="2 查询结果包含模型类中未定义的属性"></a>2 查询结果包含模型类中未定义的属性</h4><p>如果查询结果包含模型类中未定义的属性，则将每个元素封装成Map对象。</p><p>需求：按性别进行分组，统计每组的人数。只显示统计的人数和性别这两个字段</p><p>使用<strong>QueryWrapper</strong>包装对象的select方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCountGender</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用QueryWrapper包装对象</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询2列：人数, 性别。 将聚合函数定义别名做为Map中的键</span></span><br><span class="line">    wrapper.select(<span class="string">&quot;count(*) as count, gender&quot;</span>);</span><br><span class="line">    <span class="comment">//按sex分组</span></span><br><span class="line">    wrapper.groupBy(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">    <span class="comment">//这里的查询方法使用selectMaps</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = userMapper.selectMaps(wrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-查询条件"><a href="#3-查询条件" class="headerlink" title="3. 查询条件"></a>3. 查询条件</h3><h4 id="问题导入-4"><a href="#问题导入-4" class="headerlink" title="问题导入"></a>问题导入</h4><p>多条件查询有哪些组合？</p><ul><li>范围匹配（&gt; 、 &#x3D; 、between）</li><li>模糊匹配（like）</li><li>空判定（null）</li><li>包含性匹配（in）</li><li>分组（group）</li><li>排序（order）</li><li>……</li></ul><h4 id="3-1-查询条件"><a href="#3-1-查询条件" class="headerlink" title="3.1 查询条件"></a>3.1 查询条件</h4><ul><li>购物设定价格区间、户籍设定年龄区间（le ge匹配 或 between匹配）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBetween</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">    <span class="comment">//范围查询 lt le gt ge eq between</span></span><br><span class="line">    wrapper.between(User::getAge, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,gender,password,age,tel FROM user WHERE (age BETWEEN ? AND ?)</span><br><span class="line">==&gt; Parameters: 20(Integer), 30(Integer)</span><br></pre></td></tr></table></figure><ul><li>查信息，搜索新闻（非全文检索版：like匹配）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLike</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//模糊匹配like, %在右边</span></span><br><span class="line">    wrapper.likeRight(User::getName, <span class="string">&quot;N&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,gender,password,age,tel FROM user WHERE (name LIKE ?)</span><br><span class="line">==&gt; Parameters: N%(String)</span><br></pre></td></tr></table></figure><ul><li>统计报表（按性别分组，查询平均年龄）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAggregate</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.select(<span class="string">&quot;avg(age) 平均年龄, gender 性别&quot;</span>).groupBy(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; users = userMapper.selectMaps(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT avg(age) 平均年龄, gender 性别 FROM user GROUP BY gender</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: 平均年龄, 性别</span><br><span class="line">&lt;==        Row: 20.6667, 女</span><br><span class="line">&lt;==        Row: 14.5000, 男</span><br><span class="line">&lt;==      Total: 2</span><br><span class="line"></span><br><span class="line">&#123;平均年龄=20.6667, 性别=女&#125;</span><br><span class="line">&#123;平均年龄=14.5000, 性别=男&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-排序和limit"><a href="#3-2-排序和limit" class="headerlink" title="3.2 排序和limit"></a>3.2 排序和limit</h4><p>题目：显示年龄最大的5个用户</p><ul><li><p>说明：</p><p>  ①：提示：对年龄进行降序排序</p><p>  ②：仅获取前5条数据（提示：使用分页功能控制数据显示数量）</p></li><li><p>last()方法的说明：</p><p>  无视优化规则直接拼接到 sql 的最后(有sql注入的风险,请谨慎使用)，注意只能调用一次,多次调用以最后一次为准</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testFindMaxAge</span><span class="params">()</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//按年龄降序排序，并且显示前面5个</span></span><br><span class="line">    wrapper.orderByDesc(User::getAge).last(<span class="string">&quot;limit 5&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的SQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,password,age,tel FROM user ORDER BY age DESC limit 5</span><br></pre></td></tr></table></figure><h3 id="4-字段映射与表名映射问题导入"><a href="#4-字段映射与表名映射问题导入" class="headerlink" title="4. 字段映射与表名映射问题导入"></a>4. 字段映射与表名映射问题导入</h3><p>思考表的字段和实体类的属性不对应，查询会怎么样？</p><h4 id="4-1-问题一：表字段与编码属性设计不同步"><a href="#4-1-问题一：表字段与编码属性设计不同步" class="headerlink" title="4.1 问题一：表字段与编码属性设计不同步"></a>4.1 问题一：表字段与编码属性设计不同步</h4><ul><li>在模型类属性上方，使用**@TableField<strong>属性注解，通过</strong>value**属性，设置当前属性对应的数据库表中的字段关系。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改表的列名</span><br><span class="line">ALTER TABLE `user` CHANGE `password` `pwd` VARCHAR(20);</span><br></pre></td></tr></table></figure><p>再次查询出现异常，报不知道的列password</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column &#x27;password&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure><p>解决方法：</p><p><img src="/2022/09/11/MybatisPlus/image-20210801182722773.png" alt="image-20210801182722773"></p><p>生成的SQL语句，自动给pwd这一列定义了别名为password</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,pwd AS password,age,tel FROM user</span><br></pre></td></tr></table></figure><h4 id="4-2-问题二：编码中添加了数据库中未定义的属性"><a href="#4-2-问题二：编码中添加了数据库中未定义的属性" class="headerlink" title="4.2 问题二：编码中添加了数据库中未定义的属性"></a>4.2 问题二：编码中添加了数据库中未定义的属性</h4><p>在User实体类中添加新的属性<code>Integer online</code></p><p>查询报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Unknown column &#x27;online&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li>在模型类属性上方，使用**@TableField<strong>注解，通过</strong>&#x3D;&#x3D;exist&#x3D;&#x3D;**属性，设置属性在数据库表字段中是否存在，默认为true。此属性无法与value同时使用。</li></ul><p><img src="/2022/09/11/MybatisPlus/image-20210801182809131.png" alt="image-20210801182809131"></p><p>再次查询结果，没有报错，但online的属性值为空</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User(id=4, name=NewBoy, gender=男, password=123456, age=19, tel=12345678910, online=null)</span><br></pre></td></tr></table></figure><h4 id="4-3-问题三：某些字段和属性不参与查询"><a href="#4-3-问题三：某些字段和属性不参与查询" class="headerlink" title="4.3 问题三：某些字段和属性不参与查询"></a>4.3 问题三：某些字段和属性不参与查询</h4><p>需求：password这个字段不查询</p><ul><li>在模型类属性上方，使用**@TableField<strong>注解，通过</strong>select**属性：设置该属性是否参与查询。此属性与select()映射配置不冲突。</li></ul><p><img src="/2022/09/11/MybatisPlus/image-20210801220534494.png" alt="image-20210801220534494"> </p><p>查询的SQL语句中不包含pwd字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,age,tel FROM user WHERE id=?</span><br></pre></td></tr></table></figure><p>实体类的password属性中没有值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User(id=<span class="number">4</span>, name=NewBoy, gender=男, password=<span class="literal">null</span>, age=<span class="number">19</span>, tel=<span class="number">12345678910</span>, online=<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h4 id="4-4-问题四：表名与实体类名不同"><a href="#4-4-问题四：表名与实体类名不同" class="headerlink" title="4.4 问题四：表名与实体类名不同"></a>4.4 问题四：表名与实体类名不同</h4><p>修改表名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改表的名字</span><br><span class="line">ALTER TABLE `user` RENAME TO tbl_user;</span><br></pre></td></tr></table></figure><p>运行出现异常：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Table &#x27;mybatisplus_db.user&#x27; doesn&#x27;t exist</span><br></pre></td></tr></table></figure><p>解决方法：</p><ul><li>在<u><strong>模型类</strong></u>上方，使用**@TableName<strong>注解，通过</strong>&#x3D;&#x3D;value&#x3D;&#x3D;**属性，设置当前类对应的数据库表名称。</li></ul><p><img src="/2022/09/11/MybatisPlus/image-20210801220807882.png" alt="image-20210801220807882"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tbl_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询生成的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,age,tel FROM tbl_user WHERE id=?</span><br></pre></td></tr></table></figure><h2 id="四、DML编程控制"><a href="#四、DML编程控制" class="headerlink" title="四、DML编程控制"></a>四、DML编程控制</h2><h3 id="1-id生成策略控制（Insert）"><a href="#1-id生成策略控制（Insert）" class="headerlink" title="1. id生成策略控制（Insert）"></a>1. id生成策略控制（Insert）</h3><h4 id="问题导入-5"><a href="#问题导入-5" class="headerlink" title="问题导入"></a>问题导入</h4><p>主键生成的策略有哪几种方式？</p><p>不同的表应用不同的id生成策略</p><ul><li>日志：自增（1,2,3,4，……）</li><li>购物订单：特殊规则（FQ23948AK3843）</li><li>外卖单：关联地区日期等信息（10 04 20200314 34 91）</li><li>关系表：可省略id</li><li>……</li></ul><h4 id="1-1-id生成策略控制（-TableId注解）"><a href="#1-1-id生成策略控制（-TableId注解）" class="headerlink" title="1.1 id生成策略控制（@TableId注解）"></a>1.1 id生成策略控制（@TableId注解）</h4><ul><li><p>名称：@TableId</p></li><li><p>类型：<strong>属性注解</strong></p></li><li><p>位置：模型类中用于表示主键的属性定义上方</p></li><li><p>作用：设置当前类中主键属性的生成策略</p></li><li><p>相关属性</p><p>  ​<strong>type</strong>：设置主键属性的生成策略，值参照IdType枚举值</p><p>  <img src="/2022/09/11/MybatisPlus/image-20210801192449901.png" alt="image-20210801192449901"></p></li></ul><blockquote><p>针对每个公司，随着服务化演进，单个服务越来越多，数据库分的越来越细，有的时候一个业务需要分成好几个库，这时候自增主键或者序列之类的主键id生成方式已经不再满足需求，分布式系统中需要的是一个全局唯一的id生成规则。</p><p>具体的算法和代码，参见资料文件夹。</p></blockquote><p>添加无参和有参的构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tbl_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Long id, String name, String gender, String password, Integer age, String tel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用雪花算法</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@TableField(&quot;pwd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String tel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>,<span class="string">&quot;孙悟天&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;12345&quot;</span>,<span class="number">8</span>,<span class="string">&quot;15022334455&quot;</span>);</span><br><span class="line">    UserMapper.insert(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的SQL语句</p><p><img src="/2022/09/11/MybatisPlus/image-20211022231735174.png" alt="image-20211022231735174"></p><h4 id="1-2-全局策略配置"><a href="#1-2-全局策略配置" class="headerlink" title="1.2 全局策略配置"></a>1.2 全局策略配置</h4><p>也可以在application.yml中进行全局的配置</p><ol><li>id-type 让所有表主键生成策略相同</li><li>table-prefix 在每个实体类的前面添加相同的前缀</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">assign_id</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br></pre></td></tr></table></figure><h5 id="id生成策略全局配置"><a href="#id生成策略全局配置" class="headerlink" title="id生成策略全局配置"></a>id生成策略全局配置</h5><p><img src="/2022/09/11/MybatisPlus/image-20210801183128266.png" alt="image-20210801183128266"></p><h5 id="表名前缀全局配置"><a href="#表名前缀全局配置" class="headerlink" title="表名前缀全局配置"></a>表名前缀全局配置</h5><p><img src="/2022/09/11/MybatisPlus/image-20210801183157694.png" alt="image-20210801183157694"></p><p>实体类：去了@TableName注解和@TableId，使用全局配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Long id, String name, String gender, String password, Integer age, String tel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="meta">@TableField(&quot;pwd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String tel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试结果</p><p><img src="/2022/09/11/MybatisPlus/image-20211022232307169.png" alt="image-20211022232307169"> </p><h3 id="2-多记录操作（批量Delete-x2F-Select）"><a href="#2-多记录操作（批量Delete-x2F-Select）" class="headerlink" title="2. 多记录操作（批量Delete&#x2F;Select）"></a>2. 多记录操作（批量Delete&#x2F;Select）</h3><h4 id="问题导入-6"><a href="#问题导入-6" class="headerlink" title="问题导入"></a>问题导入</h4><p>MyBatisPlus是否支持批量操作？</p><p><img src="/2022/09/11/MybatisPlus/image-20210801183334584.png" alt="image-20210801183334584"> </p><h4 id="2-1-按照主键删除多条记录"><a href="#2-1-按照主键删除多条记录" class="headerlink" title="2.1 按照主键删除多条记录"></a>2.1 按照主键删除多条记录</h4><p>使用方法：<code>deleteBatchIds()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定多条数据</span></span><br><span class="line">List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1402551342481838081L</span>);</span><br><span class="line">list.add(<span class="number">1402553134049501186L</span>);</span><br><span class="line">list.add(<span class="number">1402553619611430913L</span>);</span><br><span class="line"></span><br><span class="line">userMapper.deleteBatchIds(list);</span><br></pre></td></tr></table></figure><p>生成的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM tbl_user WHERE id IN ( ? , ? , ? )</span><br></pre></td></tr></table></figure><h4 id="2-2-根据主键查询多条记录"><a href="#2-2-根据主键查询多条记录" class="headerlink" title="2.2 根据主键查询多条记录"></a>2.2 根据主键查询多条记录</h4><p>使用方法：<code>selectBatchIds()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询指定多条数据</span></span><br><span class="line">List&lt;Long&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1L</span>);</span><br><span class="line">list.add(<span class="number">3L</span>);</span><br><span class="line">list.add(<span class="number">4L</span>);</span><br><span class="line">userMapper.selectBatchIds(list);</span><br></pre></td></tr></table></figure><p>生成的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,name,gender,pwd AS password,age,tel FROM tbl_user WHERE id IN ( ? , ? , ? )</span><br></pre></td></tr></table></figure><h3 id="3-逻辑删除（Delete-x2F-Update）"><a href="#3-逻辑删除（Delete-x2F-Update）" class="headerlink" title="3. 逻辑删除（Delete&#x2F;Update）"></a>3. 逻辑删除（Delete&#x2F;Update）</h3><h4 id="问题导入-7"><a href="#问题导入-7" class="headerlink" title="问题导入"></a>问题导入</h4><p>在实际环境中，如果想删除一条数据，是否会真的从数据库中删除该条数据？</p><ul><li><p>删除操作业务问题：业务数据从数据库中丢弃</p></li><li><p>逻辑删除：为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中</p></li></ul><p><img src="/2022/09/11/MybatisPlus/image-20210801183459750.png" alt="image-20210801183459750"> </p><h4 id="3-1-逻辑删除案例"><a href="#3-1-逻辑删除案例" class="headerlink" title="3.1 逻辑删除案例"></a>3.1 逻辑删除案例</h4><p>修改表结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加一列deleted，注意设置默认值为0</span><br><span class="line">ALTER TABLE tbl_user ADD COLUMN deleted INT(1) DEFAULT 0;</span><br><span class="line"></span><br><span class="line">-- 查看结构</span><br><span class="line">DESC tbl_user;</span><br></pre></td></tr></table></figure><h5 id="①：数据库表中添加逻辑删除标记字段"><a href="#①：数据库表中添加逻辑删除标记字段" class="headerlink" title="①：数据库表中添加逻辑删除标记字段"></a>①：数据库表中添加逻辑删除标记字段</h5><p><img src="/2022/09/11/MybatisPlus/image-20210801183545635.png" alt="image-20210801183545635"> </p><h5 id="②：实体类中添加对应字段，并设定当前字段为逻辑删除标记字段"><a href="#②：实体类中添加对应字段，并设定当前字段为逻辑删除标记字段" class="headerlink" title="②：实体类中添加对应字段，并设定当前字段为逻辑删除标记字段"></a>②：实体类中添加对应字段，并设定当前字段为逻辑删除标记字段</h5><p>@TableLogic包含以下属性</p><ul><li><p>value：未删除时的值</p></li><li><p>delval：删除了的值</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逻辑删除字段，标记当前记录是否被删除</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③：配置逻辑删除字面值"><a href="#③：配置逻辑删除字面值" class="headerlink" title="③：配置逻辑删除字面值"></a>③：配置逻辑删除字面值</h5><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="comment"># 逻辑删除字段名</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line">      <span class="comment"># 逻辑删除字面值：未删除为0</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment"># 逻辑删除字面值：删除为1</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>逻辑删除本质：逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLogicDeleted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> UserMapper.deleteById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(row + <span class="string">&quot;条记录被逻辑删除&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/MybatisPlus/image-20210801223228871.png" alt="image-20210801223228871"> </p><h3 id="4-乐观锁（Update）"><a href="#4-乐观锁（Update）" class="headerlink" title="4. 乐观锁（Update）"></a>4. 乐观锁（Update）</h3><h4 id="4-1-问题导入"><a href="#4-1-问题导入" class="headerlink" title="4.1 问题导入"></a>4.1 问题导入</h4><p>乐观锁主张的思想是什么？</p><ul><li>业务并发现象带来的问题：秒杀</li></ul><p><img src="/2022/09/11/MybatisPlus/image-20210801183851887.png" alt="image-20210801183851887"> </p><h4 id="4-2-什么是悲观锁和乐观锁"><a href="#4-2-什么是悲观锁和乐观锁" class="headerlink" title="4.2 什么是悲观锁和乐观锁"></a>4.2 什么是悲观锁和乐观锁</h4><h5 id="悲观锁-Pessimistic-Lock"><a href="#悲观锁-Pessimistic-Lock" class="headerlink" title="悲观锁(Pessimistic Lock)"></a>悲观锁(Pessimistic Lock)</h5><p>当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观锁。</p><p>之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。</p><h5 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁(Optimistic Locking)"></a>乐观锁(Optimistic Locking)</h5><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。</p><p>乐观锁采取了更加宽松的加锁机制。也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。</p><h5 id="乐观锁的实现"><a href="#乐观锁的实现" class="headerlink" title="乐观锁的实现"></a>乐观锁的实现</h5><ol><li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。</li><li>版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</li></ol><h4 id="4-3-乐观锁案例"><a href="#4-3-乐观锁案例" class="headerlink" title="4.3 乐观锁案例"></a>4.3 乐观锁案例</h4><h5 id="①：数据库表中添加锁标记字段"><a href="#①：数据库表中添加锁标记字段" class="headerlink" title="①：数据库表中添加锁标记字段"></a>①：数据库表中添加锁标记字段</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_user ADD COLUMN `version` INT DEFAULT 0;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/MybatisPlus/image-20210801183929041.png" alt="image-20210801183929041"> </p><h5 id="②：实体类中添加对应字段，并设定当前字段为版本控制字段"><a href="#②：实体类中添加对应字段，并设定当前字段为版本控制字段" class="headerlink" title="②：实体类中添加对应字段，并设定当前字段为版本控制字段"></a>②：实体类中添加对应字段，并设定当前字段为版本控制字段</h5><p>@Version注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="③：配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装"><a href="#③：配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装" class="headerlink" title="③：配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装"></a>③：配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义Mp拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mpInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加乐观锁拦截器</span></span><br><span class="line">        mpInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mpInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="④：使用乐观锁机制在修改前必须先获取到对应数据的version方可正常进行"><a href="#④：使用乐观锁机制在修改前必须先获取到对应数据的version方可正常进行" class="headerlink" title="④：使用乐观锁机制在修改前必须先获取到对应数据的version方可正常进行"></a>④：使用乐观锁机制在修改前必须先获取到对应数据的version方可正常进行</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.先通过要修改的数据id将当前数据查询出来</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">2L</span>);</span><br><span class="line">    <span class="comment">//2.将要修改的属性逐一设置进去</span></span><br><span class="line">    user.setName(<span class="string">&quot;Jock888&quot;</span>);</span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/MybatisPlus/image-20210801223855681.png" alt="image-20210801223855681"> </p><p>模拟多条记录同时更新</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateTwo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先通过要修改的数据id将当前数据查询出来</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">2L</span>);     <span class="comment">//version=2</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">2L</span>);    <span class="comment">//version=2</span></span><br><span class="line">    user1.setName(<span class="string">&quot;Jack aaa&quot;</span>);</span><br><span class="line">    userMapper.updateById(user1);              <span class="comment">//version=&gt;3</span></span><br><span class="line">    user2.setName(<span class="string">&quot;Jack bbb&quot;</span>);</span><br><span class="line">    userMapper.updateById(user2);               <span class="comment">//verion=2 更新失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二条记录更新失败</p><p><img src="/2022/09/11/MybatisPlus/image-20211024222106864.png" alt="image-20211024222106864"></p><h2 id="五、代码生成器"><a href="#五、代码生成器" class="headerlink" title="五、代码生成器"></a>五、代码生成器</h2><h3 id="1-问题导入"><a href="#1-问题导入" class="headerlink" title="1. 问题导入"></a>1. 问题导入</h3><p>如果只给一张表的字段信息，能够推演出domain、dao层的代码吗？</p><h3 id="2-工程搭建和基本代码编写"><a href="#2-工程搭建和基本代码编写" class="headerlink" title="2. 工程搭建和基本代码编写"></a>2. 工程搭建和基本代码编写</h3><p>第1步：创建新的SpringBoot工程</p><p>第2步：创建SpringBoot工程，添加代码生成器相关依赖，其他依赖自行添加，pom.xml 完整依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>day51-02-generate-code<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 父模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--velocity模板引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--spring-boot-web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- spring整合test --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 导入mp的包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mp 的代码生成器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mysql要选择正确版本的驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第3步：编写启动器类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpGeneratorApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MpGeneratorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4步：编写代码生成器类</p><p>在com.itheima包下</p><p><img src="/2022/09/11/MybatisPlus/image-20220617165828601.png" alt="image-20220617165828601"> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建代码生成器对象，执行生成代码操作</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">autoGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 数据源相关配置：读取数据库中的信息，根据数据库表结构生成代码</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSource.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        autoGenerator.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//3. 执行生成操作</span></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-开发者自定义配置"><a href="#3-开发者自定义配置" class="headerlink" title="3. 开发者自定义配置"></a>3. 开发者自定义配置</h3><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ul><li>设置全局配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置全局配置</span></span><br><span class="line"><span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>)+<span class="string">&quot;/模块目录/src/main/java&quot;</span>);    </span><br><span class="line"><span class="comment">//设置代码生成位置</span></span><br><span class="line">globalConfig.setOpen(<span class="literal">false</span>);    <span class="comment">//设置生成完毕后是否打开生成代码所在的目录</span></span><br><span class="line">globalConfig.setAuthor(<span class="string">&quot;NewBoy&quot;</span>);    <span class="comment">//设置作者</span></span><br><span class="line">globalConfig.setFileOverride(<span class="literal">true</span>);     <span class="comment">//设置是否覆盖原始生成的文件</span></span><br><span class="line">globalConfig.setMapperName(<span class="string">&quot;%sMapper&quot;</span>);    <span class="comment">//设置数据层接口名，%s为占位符，指代模块名称</span></span><br><span class="line">globalConfig.setIdType(IdType.ASSIGN_ID);   <span class="comment">//设置Id生成策略</span></span><br><span class="line">autoGenerator.setGlobalConfig(globalConfig);</span><br></pre></td></tr></table></figure><ul><li>设置包名相关配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置包名相关配置</span></span><br><span class="line"><span class="type">PackageConfig</span> <span class="variable">packageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">packageInfo.setParent(<span class="string">&quot;com.itheima.&quot;</span>);   <span class="comment">//设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径</span></span><br><span class="line">packageInfo.setEntity(<span class="string">&quot;domain&quot;</span>);    <span class="comment">//设置实体类包名</span></span><br><span class="line">packageInfo.setMapper(<span class="string">&quot;dao&quot;</span>);   <span class="comment">//设置数据层包名</span></span><br><span class="line">autoGenerator.setPackageInfo(packageInfo);</span><br></pre></td></tr></table></figure><ul><li>策略设置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//策略设置</span></span><br><span class="line"><span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">strategyConfig.setInclude(<span class="string">&quot;tbl_user&quot;</span>);  <span class="comment">//设置当前参与生成的表名，参数为可变参数，可以指定多个</span></span><br><span class="line">strategyConfig.setTablePrefix(<span class="string">&quot;tbl_&quot;</span>);  <span class="comment">//设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_</span></span><br><span class="line">strategyConfig.setRestControllerStyle(<span class="literal">true</span>);    <span class="comment">//设置是否启用Rest风格</span></span><br><span class="line">strategyConfig.setVersionFieldName(<span class="string">&quot;version&quot;</span>);  <span class="comment">//设置乐观锁字段名</span></span><br><span class="line">strategyConfig.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);  <span class="comment">//设置逻辑删除字段名</span></span><br><span class="line">strategyConfig.setEntityLombokModel(<span class="literal">true</span>);  <span class="comment">//设置是否启用lombok</span></span><br><span class="line">autoGenerator.setStrategy(strategyConfig);</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p><strong>注：要修改模块所在的目录名</strong></p><p>在模块目录上右键</p><p><img src="/2022/09/11/MybatisPlus/image-20211115093241579.png" alt="image-20211115093241579"> </p><p>修改代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>)+<span class="string">&quot;/mybatis-plus-02-code-generator/src/main/java&quot;</span>);    <span class="comment">//设置代码生成位置</span></span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取代码生成器的对象</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">autoGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置数据库相关配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dataSource.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        autoGenerator.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        globalConfig.setOutputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/模块名/src/main/java&quot;</span>);    <span class="comment">//设置代码生成位置</span></span><br><span class="line">        globalConfig.setOpen(<span class="literal">true</span>);    <span class="comment">//设置生成完毕后是否打开生成代码所在的目录</span></span><br><span class="line">        globalConfig.setAuthor(<span class="string">&quot;NewBoy&quot;</span>);    <span class="comment">//设置作者</span></span><br><span class="line">        globalConfig.setFileOverride(<span class="literal">true</span>);     <span class="comment">//设置是否覆盖原始生成的文件</span></span><br><span class="line">        globalConfig.setMapperName(<span class="string">&quot;%sMapper&quot;</span>);    <span class="comment">//设置数据层接口名，%s为占位符，指代模块名称</span></span><br><span class="line">        globalConfig.setIdType(IdType.ASSIGN_ID);   <span class="comment">//设置Id生成策略</span></span><br><span class="line">        autoGenerator.setGlobalConfig(globalConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置包名相关配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        packageInfo.setParent(<span class="string">&quot;com.itheima&quot;</span>);   <span class="comment">//设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径</span></span><br><span class="line">        packageInfo.setEntity(<span class="string">&quot;domain&quot;</span>);    <span class="comment">//设置实体类包名</span></span><br><span class="line">        packageInfo.setMapper(<span class="string">&quot;dao&quot;</span>);   <span class="comment">//设置数据层包名</span></span><br><span class="line">        autoGenerator.setPackageInfo(packageInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//策略设置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategyConfig.setInclude(<span class="string">&quot;tbl_user&quot;</span>);  <span class="comment">//设置当前参与生成的表名，参数为可变参数。如果有多张表则在这里指定多个字符串</span></span><br><span class="line">        strategyConfig.setTablePrefix(<span class="string">&quot;tbl_&quot;</span>);  <span class="comment">//设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名  例如： User = tbl_user - tbl_</span></span><br><span class="line">        strategyConfig.setRestControllerStyle(<span class="literal">true</span>);    <span class="comment">//设置是否启用Rest风格</span></span><br><span class="line">        strategyConfig.setVersionFieldName(<span class="string">&quot;version&quot;</span>);  <span class="comment">//设置乐观锁字段名</span></span><br><span class="line">        strategyConfig.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);  <span class="comment">//设置逻辑删除字段名</span></span><br><span class="line">        strategyConfig.setEntityLombokModel(<span class="literal">true</span>);  <span class="comment">//设置是否启用lombok</span></span><br><span class="line">        autoGenerator.setStrategy(strategyConfig);</span><br><span class="line">        <span class="comment">//2.执行生成操作</span></span><br><span class="line">        autoGenerator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成的结构如图"><a href="#生成的结构如图" class="headerlink" title="生成的结构如图"></a>生成的结构如图</h4><p><img src="/2022/09/11/MybatisPlus/image-20211125162848531.png" alt="image-20211125162848531"> </p><p>注：这里映射文件所在的目录名为mapper.xml，后期需要将mapper.xml文件移到resources目录下，视情况<strong>改目录名</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目产品分析</title>
      <link href="/2022/09/10/%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B9%A6/"/>
      <url>/2022/09/10/%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li><p>需求业务分析</p></li><li><p>概要设计分析</p></li><li><p>代码详细设计分析</p></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="项目背景和介绍"><a href="#项目背景和介绍" class="headerlink" title="项目背景和介绍"></a>项目背景和介绍</h3><p>随着时代的发展，越来越多的国内企业开始采用CRM客户关系管理系统，近年来CRM不仅受到大型企业的青睐，也是中小企业快速成长的催化剂。市场、客户信息、产品、业务人员、渠道等各类信息流的不断增长，传统方式对于管理全渠道信息流成本越来越高，所以需要一个软件产品来解决这些问题。</p><p>互联网+的出现，改变了很多行业同样很多行业的理念也在转变，伴随着电子商务、智能手机的不断应用，使企业更加简单的接触消费者，直接与消费者互动收集消费者反馈成为可能。那原本以产品以企业为核心的理念逐渐在转变，转变以“客户为中心”，及时服务客户，提高客户满意程度，从而提高企业营收。依托强大的信息技术，企业可以借助CRM系统不断把客户跟进，服务，成交，售后打通，而且不断依托CRM工具来优化这个流程，来适应整个市场的不断变化。</p><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>操作系统：Web平台<br>数据库系统：Mysql<br>运行环境：JRE<br>开发语言：JAVA<br>开发代码模式：多模块Maven模式<br>架构模式：MVC 三层架构模式</p><h3 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h3><p>常用的后台系统角色有：<br>运营人员：根据客户业务数据，统计当前系统及业务痛点，提出需求进行更新优化。<br>财务专员：负责系统财务结算审批或财务开销<br>销售专员：负责梳理客户资料，优化销售流程。借助软件提高销售成功率<br>销售主管：梳理工作内容，调整销售方案，提高销售业绩<br>客户管理人员：使用后台服务<br>市场专员：根据前端意向用户，跟进线索转换为意向客户<br>管理员：负责系统日常的运行和维护。</p><h3 id="系统架构图-和业务架构图"><a href="#系统架构图-和业务架构图" class="headerlink" title="系统架构图 和业务架构图"></a>系统架构图 和业务架构图</h3><h2 id="概要设计分析"><a href="#概要设计分析" class="headerlink" title="概要设计分析"></a>概要设计分析</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>服务器系统:Linux Centos7<br>客户端:Internet,Chorme<br>应用服务器:Tomcat<br>数据库:Mysql</p><p>开发工具:</p><table><thead><tr><th>工具</th><th>版本号</th></tr></thead><tbody><tr><td>IDEA</td><td>开发IDE</td></tr><tr><td>MobaXterm</td><td>Linux远程连接工具</td></tr><tr><td>Navicat</td><td>数据库连接工具</td></tr><tr><td>Another Redis Desktop Manager</td><td>Redis 客户端</td></tr><tr><td>PostMan</td><td>接口调试工具</td></tr><tr><td>代码管理</td><td>Git and Gitee</td></tr><tr><td>CHINER元数建模</td><td>数据库设计工具</td></tr><tr><td>Xminder</td><td>思维导图工具</td></tr></tbody></table><p>开发环境:</p><table><thead><tr><th>工具</th><th>版本号</th></tr></thead><tbody><tr><td>JDK</td><td>1.8</td></tr><tr><td>Mysql</td><td>5.7.24</td></tr><tr><td>Redis</td><td></td></tr><tr><td>SpringBoot</td><td>2.2.13.RELEASE</td></tr><tr><td>其他依赖包版本</td><td>参考项目parent模块</td></tr></tbody></table><h3 id="主要模块介绍"><a href="#主要模块介绍" class="headerlink" title="主要模块介绍"></a>主要模块介绍</h3><ul><li>首页功能(常用于数据展示)</li><li>活动管理</li><li>统计分析</li><li>系统管理</li><li>CRM管理</li></ul><h3 id="数据结构表设计-只列出核心字段-其他普通字段不做分析"><a href="#数据结构表设计-只列出核心字段-其他普通字段不做分析" class="headerlink" title="数据结构表设计(只列出核心字段,其他普通字段不做分析)"></a>数据结构表设计(只列出核心字段,其他普通字段不做分析)</h3><p>线索表tb_clue:</p><table><thead><tr><th>字段名</th><th>姓名</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>线索id</td><td>id 是tb_clue_track_record的外键</td></tr><tr><td>activity_id</td><td>活动id</td><td></td></tr><tr><td>type</td><td>0代表线索,1代表商机</td><td></td></tr><tr><td>lastest</td><td>代表最终归属人</td><td></td></tr></tbody></table><p>线索跟进记录表tb_clue_track_record:</p><table><thead><tr><th>字段名</th><th>姓名</th><th>备注</th></tr></thead><tbody><tr><td>分配记录表tb_assign_record:</td><td></td><td></td></tr><tr><td>字段名</td><td>姓名</td><td>备注</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><p>商机表:tb_business</p><table><thead><tr><th>字段名</th><th>姓名</th><th>备注</th></tr></thead><tbody><tr><td>商机跟进记录表:tb_business_track_record</td><td></td><td></td></tr><tr><td>字段名</td><td>姓名</td><td>备注</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>合同表:tb_contract</td><td></td><td></td></tr><tr><td>字段名</td><td>姓名</td><td>备注</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><h4 id="用户、角色、权限数据库设计"><a href="#用户、角色、权限数据库设计" class="headerlink" title="用户、角色、权限数据库设计"></a>用户、角色、权限数据库设计</h4><p>用户表:sys_user</p><table><thead><tr><th>字段名</th><th>代表</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>用户id</td><td></td></tr></tbody></table><p>用户角色中间表 sys_user_role<br>|字段名|代表|备注|<br>|user_id|用户id||<br>|role_id|该用户的角色id||</p><p>角色表 sys_role<br>|role_id|角色id||</p><p>角色和权限菜单目录表 sys_role_menu<br>|role_id|角色id||<br>|menu_id|菜单id||</p><p>权限目录表 sys_menu<br>|menu_id|目录菜单id|</p><h2 id="代码详细设计分析"><a href="#代码详细设计分析" class="headerlink" title="代码详细设计分析"></a>代码详细设计分析</h2><p>由于本项目是由<strong>Maven多模块</strong>实现现,简单介绍下项目各模块技术:</p><h3 id="源码模块分析"><a href="#源码模块分析" class="headerlink" title="源码模块分析"></a>源码模块分析</h3><p>parent基本模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>容器+MVC框架</td></tr><tr><td>Druid</td><td>阿里云数据库连接池</td></tr><tr><td>eu.bitwalker</td><td>解析客户端操作系统、浏览器等</td></tr><tr><td>pageHelper</td><td>分页插件</td></tr><tr><td>oshi</td><td>获取系统信息</td></tr><tr><td>jna</td><td>Java工具类用于在运行期间动态访问系统本地库</td></tr><tr><td>commons-io</td><td>io常用工具类</td></tr><tr><td>commons-fileupload</td><td>文件上传工具类</td></tr><tr><td>commons-colletions</td><td>collectons工具类</td></tr><tr><td>poi</td><td>常用excel工具</td></tr><tr><td>velocity</td><td>velocity代码生成模板器</td></tr><tr><td>fastjson</td><td>阿里Json解析器</td></tr><tr><td>kaptcha</td><td>验证码</td></tr><tr><td>lombok</td><td>lombok管理</td></tr><tr><td>minio</td><td>io工具类</td></tr><tr><td>okHttp</td><td>Http工具类</td></tr></tbody></table><p>framework核心框架技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot-Web</td><td>Web容器</td></tr><tr><td>SpringBoot-AOP</td><td>AOP拦截器</td></tr></tbody></table><p>admin模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>mysql-connector-java</td><td>mysql驱动包</td></tr><tr><td>mybatis</td><td>mybatis ORM框架</td></tr></tbody></table><p>bussiness模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>showfun公共模块</td></tr><tr><td>showfun-system</td><td>showfun项目系统模块</td></tr><tr><td>showfun-clues</td><td>项目clues模块</td></tr></tbody></table><p>clues模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>showfun公共模块</td></tr><tr><td>showfun-system</td><td>showfun项目系统模块</td></tr></tbody></table><p>common模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Spring-context-support</td><td>Spring上下文核心工具</td></tr><tr><td>Spring-web</td><td>SpringWeb模块</td></tr><tr><td>Spring-security</td><td>Spring安全认证模块</td></tr><tr><td>PageHelper</td><td>分页插件</td></tr><tr><td>Validation-api</td><td>自定义验证注解</td></tr><tr><td>commons-lang</td><td>常用工具类</td></tr><tr><td>jackson-databind</td><td>Jackson工具类</td></tr><tr><td>snakeyaml</td><td>YAML解析器</td></tr><tr><td>jjwt</td><td>Token生成与解析器</td></tr><tr><td>redis</td><td>redis 缓存</td></tr><tr><td>EasyExcel</td><td>easyExcel 工具类</td></tr></tbody></table><p>contract合同模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>mysql-connector-java</td><td>mysql驱动工具类</td></tr><tr><td>showfun-common</td><td>项目公共模块</td></tr><tr><td>showfun-bussiness</td><td>项目业务模块</td></tr></tbody></table><p>report模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-contract</td><td>项目合同模块</td></tr></tbody></table><p>task模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>项目公共模块</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的并发编程</title>
      <link href="/2022/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="多线程编程-上"><a href="#多线程编程-上" class="headerlink" title="多线程编程(上)"></a>多线程编程(上)</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>进程和线程的基本概念</li><li>多线程并发出现问题的根源</li><li>Java如何解决并发问题</li><li>线程安全的实现方式</li></ul><h3 id="多线程的一些名词"><a href="#多线程的一些名词" class="headerlink" title="多线程的一些名词"></a>多线程的一些名词</h3><ul><li>四核八处理器：指的是拥有四个CPU ，可以同时处理8个进程，且CPU之间可以切换运行不同的进程。</li><li>进程: 进程指的是运行中的应用程序,通常操作系统会分配 CPU, 内存, 磁盘,网络资源给该进程使用，进程有各自的内存单元相互独立。</li><li>线程：指一个进程（应用程序）内的线性程序功能，共享内存。一般的软件都是支持多线程的，指<strong>同一时刻内</strong>可以同时执行多个线程任务，实现高并发。</li><li>并发：指的是单个CPU <strong>同一个时刻</strong> 可以切换多个线程任务交替执行,减少<strong>等待</strong>并提高<strong>性能</strong>的技术,如果优化的目的不是为了减少等待的时间,切记不要使用并发，可以选择优化算法等实现。<br>我们的大脑就是简单的单个CPU处理多种复杂事情的并发。但由于并发是不断切换执行任务，容易出现“问题”，要谨慎处理。</li><li>并行：指的是 多个CPU 在<strong>同一时刻同时执行任务</strong>  。类似于马拉松选手在同一时刻同时出发的场景。</li></ul><h4 id="多线程并发编程的好处和坏处"><a href="#多线程并发编程的好处和坏处" class="headerlink" title="多线程并发编程的好处和坏处"></a>多线程并发编程的好处和坏处</h4><p>好处：由于CPU，内存，IO读写设备的速度是有极大的差异的，为了合理利用CPU的高性能和平衡三者的差异，<br>经常做一些优化的设计：</p><ol><li>CPU 增强了缓存，均衡了与内存的速度差异 </li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异</li><li>编译程序优化代码指令执行次序，使得缓存能够得到更加合理地利用</li></ol><p>缺点:</p><ol><li>CPU 增加缓存机制, 导致了可见性问题。</li><li>操作系统的操作 导致了原子性问题。</li><li>编译程序的操作 导致了有序性问题。</li></ol><h3 id="并发出现问题的根源-可见性问题-原子性问题-有效性问题"><a href="#并发出现问题的根源-可见性问题-原子性问题-有效性问题" class="headerlink" title="并发出现问题的根源: 可见性问题, 原子性问题,有效性问题"></a>并发出现问题的根源: 可见性问题, 原子性问题,有效性问题</h3><p>可见性问题：常出现在读写过程中。 指的是一个对象A(对象包括数据库事务，CPU…等等)在写入数据过程中，但未完全写入到内存或数据被临时存储(譬如缓存),另一对象B读取（查询）还是同一共享数据的值，则无法正确获取修改后的值，这就是可见性问题。</p><p>原子性问题：操作系统分时复用导致</p><p>即一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>在Java中，对<strong>基本数据类型的变量的读取和赋值操作</strong>默认是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设有两个线程执行以下代码:</span><br><span class="line">int i = 1;  //原子性操作</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">假设CPU执行下面这段代码使用线程1实际上 进行了**三个原子性**操作: </span><br><span class="line">1)将变量i从内存读取到CPU寄存器  </span><br><span class="line">2)CPU寄存器中执行 i+1 运算</span><br><span class="line">3)将结果2写入到内存中(缓存机制导致可能写入的是CPU缓存而不是内存)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">i += 1;  //这不是原子性操作,只有单一的读取和赋值才是原子性操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于CPU有分时复用(线程切换)到线程2执行这个代码,当时变量i在内存还是1,因此最终线程2执行完成的结果比线程1更快结束,导致写入内存的值是 2, 再切换到线程1执行后续操作 而不是预期结果 3 </span><br><span class="line">出现原子性问题</span><br><span class="line">*/</span><br><span class="line">i +=1;</span><br></pre></td></tr></table></figure><p>有效性问题: 由编译器重排序引起的<br>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型:(从先到后)</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 </li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 </li><li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ol><h4 id="Java如何解决并发的问题"><a href="#Java如何解决并发的问题" class="headerlink" title="Java如何解决并发的问题?"></a>Java如何解决并发的问题?</h4><p>JAVA 提供了JMM（Java Memory Model）规范JVM 如何提供按需禁用缓存和编译的方法和JMM保证了基本读取和赋值是原子性操作，且必须是将数字赋值给某个变量。</p><p>提供了以下一些功能保证并发不出现问题：</p><ul><li>3个关键字 volatile synchronized 和 final </li><li>Happens-Before规范规则</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分析如下的语句哪些操作是原子性操作</span><br><span class="line">x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br><span class="line">y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br><span class="line">x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br><span class="line">x = x + 1;     //语句4： 同语句3</span><br></pre></td></tr></table></figure><p>因此JAVA提供了synchronized 和 java.util.concurrent.locks.Lock 锁接口 ,synchronized 适用于变量，方法和类，代表该代码块是同步且锁定的，作用有:</p><ol><li>可以保证任一时刻只有一个线程执行同步代码块,释放锁之前对变量的修改刷新到主存中。</li><li>保证了数据读取和写入的原子性。</li><li>保证了共享变量的内存可见性</li></ol><p>JAVA 提供了volatitle关键字：本质上就是告知JVM 当前变量在CPU寄存器中的值是不确定，需要重新到内存取值。<br>有以下作用：</p><ol><li>保证了共享变量被修改的值立刻被更新到主存中,方便其他线程读取新的值。</li><li>应用于变量中，保证了其他线程对共享变量的可见性。</li></ol><p>常见面试题:<br>synchronized 和 volatitle 的区别<br>1)synchronized适用于 变量,方法和类上, volatitle 适用于变量,用volatitle 修饰的变量,本质上是告诉JVM此变量在寄存器(工作内存)中的值是不确定的,告知JVM自己重新到内存读取准确的值再运行代码。synchronized 则是锁定当前变量,只有当前线程可以访问该变量,其他线程会被阻塞<br>2)synchronized使用后会阻塞线程，volatitle 不会阻塞线程<br>3)synchronized能够保证变量的修改可见性和原子性。volatitle只能保证变量的修改可见性。</p><h3 id="如何使用并发编程"><a href="#如何使用并发编程" class="headerlink" title="如何使用并发编程"></a>如何使用并发编程</h3><p>由于并发编程涉及CPU，主存，操作系统等协同工作，因此要遵守四个原则：</p><ol><li>不要使用并发。如果可以使用其他方式提高程序速度，尽量不要使用并发。如果非要用并发，那么也要使用知名的库譬如Java提供的JUC 工具包， 少写自己的代码</li><li>一切都不可信，一切都很重要</li><li>能运行并不代表没有问题</li><li>终究要理解并发</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-BeanFactory详解</title>
      <link href="/2022/09/07/Spring-beans/"/>
      <url>/2022/09/07/Spring-beans/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring-IOC-容器-和-Beans"><a href="#Spring-IOC-容器-和-Beans" class="headerlink" title="Spring IOC 容器 和 Beans"></a>Spring IOC 容器 和 Beans</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>Spring是什么</li><li>Spring IOC &#x2F; DI</li><li>Spring-beans 模块</li><li>Spring AOP</li><li>BeanFacotry是自动创建一个Bean对象的流程</li></ul><h3 id="Spring-是什么"><a href="#Spring-是什么" class="headerlink" title="Spring 是什么"></a>Spring 是什么</h3><p>Spring 是一个减轻传统 JAVAEE应用 EJB 管理,和复杂配置的轻量级框架, 其底层模块有 core ,content , beans , AOP ,SpEL表达式 ,Spring-JDBC, ORM模块。<br>也是一个生态，基于Spring Framework 已经衍生出各种 Spring 优秀框架 ，譬如Spring MVC， Spring Boot ，Spring JPA ， Spring Cloud， Spring Cloud Alibaba 。<br>Spring Framework 包含了两个核心理念，Spring - IOC 和Spring AOP 理念。</p><h3 id="Spring-IOC-理念"><a href="#Spring-IOC-理念" class="headerlink" title="Spring IOC 理念"></a>Spring IOC 理念</h3><p>Inversion of Control 控制反转原理，也叫做DI ，在DI过程中，支持构造器注入，setter方法注入和返回值。 Spring的Bean容器具有Ioc 的能力，Spring提供了两种配置方式 可以注入到 BeanFactory 容器中，从而创建 Bean 对象和初始化对象属性。</p><h4 id="配置一：通过外部XML-文件定义BD信息。"><a href="#配置一：通过外部XML-文件定义BD信息。" class="headerlink" title="配置一：通过外部XML 文件定义BD信息。"></a>配置一：通过外部XML 文件定义BD信息。</h4><p>通过外部XML文件生成BeanDefinition 信息的基本流程是:<br>XML文件 ——  IO流  ——  dom4j (DocmentForJava) —— 获取Docment 对象 —— 获取父子节点Node —— 通过Node 节点 得到各节点的属性 —— 封装到RootBeanDefination&#x2F;ChildDefinition</p><h4 id="配置二：通过注解-Annoation-定义BD信息。"><a href="#配置二：通过注解-Annoation-定义BD信息。" class="headerlink" title="配置二：通过注解@Annoation 定义BD信息。"></a>配置二：通过注解@Annoation 定义BD信息。</h4><p>注解类 生成BeanDefinition 的基本流程是<br>@Annotaion类 - 获取该注释类Class对象 - AnnotationBeanDefinition </p><h3 id="Spring-beans-模块解析"><a href="#Spring-beans-模块解析" class="headerlink" title="Spring-beans 模块解析"></a>Spring-beans 模块解析</h3><h4 id="BeanDefinitionReader-和-BeanDefinition-接口"><a href="#BeanDefinitionReader-和-BeanDefinition-接口" class="headerlink" title="BeanDefinitionReader 和 BeanDefinition 接口"></a>BeanDefinitionReader 和 BeanDefinition 接口</h4><p><strong>BeanDefinitionReader</strong> 本接口不用实现, 仅仅为了规范和约束 BeanDefinition的标准命名格式。</p><blockquote><p>Simple interface for bean definition readers. Specifies load methods with Resource and String location parameters.<br>Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format.<br>Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions</p></blockquote><p><strong>BeanDefinition</strong></p><blockquote><p>官方注释： A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations.<br>This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor to introspect and modify property values and other bean metadata </p></blockquote><p>一个BeanDefinition 对应一个Bean实例 ,包含<strong>Bean属性值, 构造器 和 bean之间的关系</strong> ,这个接口的主要目的就是</p><ol><li>接收符合BeanDefinition的配置信息。</li><li>允许 BeanFactoryPostProcessor 去修改属性值和bean的数据模型。</li></ol><h4 id="BeanPostProcessor-Bean后置处理器"><a href="#BeanPostProcessor-Bean后置处理器" class="headerlink" title="BeanPostProcessor Bean后置处理器"></a>BeanPostProcessor Bean后置处理器</h4><p>由于 BeanDefinition 只负责将Bean的配置存储,并不负责数据的转换。譬如jdbc.properties 的jdbc.username 存入的XML文件时 是${jdbc.username},在BD 时依然还是jdbc.username,Spring 使用 Wrapper模式,执行PostProcess后置处理器可以将${jdbc.username}替换成 root </p><h4 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h4><h4 id="BeanFactoryPostProcess-Bean工厂后置处理器"><a href="#BeanFactoryPostProcess-Bean工厂后置处理器" class="headerlink" title="BeanFactoryPostProcess Bean工厂后置处理器"></a>BeanFactoryPostProcess Bean工厂后置处理器</h4><p>对BeanFacotry 进行增强处理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 技术详解</title>
      <link href="/2022/09/06/Redis/"/>
      <url>/2022/09/06/Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Redis中间件技术"><a href="#Redis中间件技术" class="headerlink" title="Redis中间件技术"></a>Redis中间件技术</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>了解Redis技术的背景和功能</li><li>Redis 的原理机制 和优缺点</li><li>Redis环境搭建。</li><li>Java Redis API 的初级应用</li><li>Spring-cache + Redis 的应用</li><li>项目调试中常出现的问题</li></ul><h2 id="了解Redis技术的背景和作用"><a href="#了解Redis技术的背景和作用" class="headerlink" title="了解Redis技术的背景和作用"></a>了解Redis技术的背景和作用</h2><p>Redis 是一位 Salvatore Sanfilippo 意大利程序员写的， 是一个 <strong>key-vlaue</strong> 存储系统的 非关系型数据库。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言（<strong>包括JAVA</strong>）的 API。</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets) 、sorted set（有序set）</p><p>作用：</p><p>为了解决用户 过度请求频繁访问数据亏库，导致数据库访问压力大，系统性能下降，用户体验差等问题的一种缓存型中间技术。</p><p>！！！！人人都说官网就是最好的教程。必须学会看</p><p>如下是翻译，如果有不对。可以自己去官网看<a href="https://redis.io/docs/about/">Redis官网</a></p><p>其主要功能：</p><ol><li><p>提供<strong>5种数据结构</strong>（字符串(String)、哈希(Hash)、列表(list)、集合(sets) 、sorted set（有序set）支持范围查询 ，bitmaps，基数估计算法，地址空间索引 和 流式化的操作</p></li><li><p>Redis 已内置主从复制，Lua脚本，LRU 回收，事务、在磁盘上不同级别的持久性、通过Redis Sentinel和Redis Cluster(集群)自动分区提供高可用性</p></li><li><p>为了达到最好的性能，Redis使用 一个内存的数据集，两种方式实现缓存。</p><blockquote><p>Redis可以将数据定期将数据集转储到磁盘（Redis DB），将redis存储的数据生成快照存储到磁盘上。</p></blockquote><p>  将每个命令附加到基于磁盘的日志来持久化数据（Append Only File）先记录日志，下次启动再加载此类文件。</p><p>  两个可以一起使用，但如果您只需要一个功能丰富的、联网的、内存中的缓存，您也可以禁用持久性（ARF）。</p></li></ol><blockquote><p>To achieve top performance, Redis works with an  <strong>in-memory dataset</strong> . Depending on your use case, Redis can persist your data either by periodically <a href="https://redis.io/topics/persistence#snapshotting">dumping the dataset to disk</a> or by <a href="https://redis.io/topics/persistence#append-only-file">appending each command to a disk-based log</a>. You can also disable persistence if you just need a feature-rich, networked, in-memory cache.</p><p>Redis supports <a href="https://redis.io/topics/replication">asynchronous replication</a>, with fast non-blocking synchronization and auto-reconnection with partial resynchronization on net split.</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p>image.png​</p><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并<strong>发</strong></h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p>image.png</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a><strong>缓存和数据库双写一致性问题</strong></h4><p>一致性的问题很常见，因为加入了缓存之后，请求是先从 redis中查询，如果 redis 中存在数据就不会走数据库了，如果不能保证缓存跟数据库的一致性就会导致请求获取到的数据不是最新的数据。</p><p>解决方案：</p><p>1、编写删除缓存的接口，在更新数据库的同时，调用删除缓存</p><p>的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。</p><p>2、消息队列：ActiveMQ，消息通知。</p><h4 id="缓存的并发竞争问题"><a href="#缓存的并发竞争问题" class="headerlink" title="缓存的并发竞争问题"></a><strong>缓存的并发竞争问题</strong></h4><p>并发竞争，指的是同时有多个子系统去 set 同一个 key 值。</p><p>解决方案：</p><p>1、最简单的方式就是准备一个分布式锁，大家去抢锁，抢到</p><p>锁就做 set 操作即可</p><h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a><strong><strong><strong>缓存</strong></strong>雪崩问题</strong></h4><p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波</p><p>请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p>解决方案：</p><p>1、给缓存的失效时间，加上一个随机值，避免集体失效。</p><p>2、使用互斥锁，但是该方案吞吐量明显下降了。</p><p>3、搭建 redis 集群。</p><h4 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a><strong><strong><strong>缓存</strong></strong>击穿问题</strong></h4><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p>解决方案：</p><p>1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，</p><p>再去请求数据库。没得到锁，则休眠一段时间重试</p><p>2、采用异步更新策略，无论 key 是否取到值，都直接返回，</p><p>value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程</p><p>去读数据库，更新缓存。</p><h3 id="1-2-使用Redis能做什么角色"><a href="#1-2-使用Redis能做什么角色" class="headerlink" title="1.2 使用Redis能做什么角色"></a>1.2 使用Redis能做什么角色</h3><ul><li>数据缓存</li><li>消息队列</li><li>注册中心</li><li>发布订阅</li></ul><h2 id="2-Redis入门"><a href="#2-Redis入门" class="headerlink" title="2. Redis入门"></a>2. Redis入门</h2><h3 id="2-1-Redis简介"><a href="#2-1-Redis简介" class="headerlink" title="2.1 Redis简介"></a>2.1 Redis简介</h3><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. 翻译为：Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p><p>官网：<a href="https://redis.io/">https://redis.io</a></p><p>Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。它存储的value类型比较丰富，也被称为结构化的NoSql数据库。</p><p>NoSql（Not Only SQL），不仅仅是SQL，泛指<strong>非关系型数据库</strong>。NoSql数据库并不是要取代关系型数据库，而是关系型数据库的补充。</p><p>关系型数据库(RDBMS)：</p><ul><li>Mysql</li><li>Oracle</li><li>DB2</li><li>SQLServer</li></ul><p>非关系型数据库(NoSql)：</p><ul><li>Redis</li><li>Mongo db</li><li>MemCached</li></ul><h3 id="2-2-Redis下载与安装"><a href="#2-2-Redis下载与安装" class="headerlink" title="2.2 Redis下载与安装"></a>2.2 Redis下载与安装</h3><h4 id="2-2-1-Redis下载"><a href="#2-2-1-Redis下载" class="headerlink" title="2.2.1 Redis下载"></a>2.2.1 Redis下载</h4><p>Redis安装包分为windows版和Linux版：</p><ul><li>Windows版下载地址：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></li><li>Linux版下载地址： <a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></li></ul><p>下载后得到下面安装包：</p><p><img src="/2022/09/06/Redis/image-20210927092053283.png" alt="image-20210927092053283"></p><h4 id="2-2-2-Redis安装"><a href="#2-2-2-Redis安装" class="headerlink" title="2.2.2 Redis安装"></a>2.2.2 Redis安装</h4><p><strong>1）在Linux中安装Redis</strong></p><h5 id="在Linux系统安装Redis步骤："><a href="#在Linux系统安装Redis步骤：" class="headerlink" title="在Linux系统安装Redis步骤："></a>在Linux系统安装Redis步骤：</h5><ol><li><p>将Redis安装包上传到Linux到soft目录</p></li><li><p>解压安装包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /soft</span><br><span class="line">tar -xvf redis-4.0.0.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></li><li><p>因为已经自带了，可以不安装(安装Redis的依赖环境gcc，命令：yum install gcc-c++)</p><p><img src="/2022/09/06/Redis/image-20220608095520016.png" alt="image-20220608095520016"> </p></li><li><p>进入&#x2F;usr&#x2F;local&#x2F;redis-4.0.0，进行编译，命令：make</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/redis-4.0.0</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>进入redis的src目录进行安装，命令：make install</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Redis/image-20220608095725881.png" alt="image-20220608095725881"> </p></li><li><p>进入&#x2F;usr&#x2F;local&#x2F;redis-4.0.0 ,把redis.conf文件拷贝到src目录中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现在src目录下：</span><br><span class="line"># 复制上一级的文件到当前目录下</span><br><span class="line">cp ../redis.conf .</span><br></pre></td></tr></table></figure><p><img src="/2022/09/06/Redis/image-20220608100018640.png" alt="image-20220608100018640"></p></li></ol><h5 id="运行Redis"><a href="#运行Redis" class="headerlink" title="运行Redis"></a>运行Redis</h5><p>在src目录下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure><p>按ctrl+c退出redis服务器</p><h5 id="以后台的方式执行Redis"><a href="#以后台的方式执行Redis" class="headerlink" title="以后台的方式执行Redis"></a>以后台的方式执行Redis</h5><ol><li><p>修改redis.conf文件，让其在后台启动不要霸屏的方式启动，将配置文件中的daemonize配置项改为yes，默认值为no。用其它的文本编辑器也可以，修改redis.conf文件，136行，将no改成yes</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize yes </span><br></pre></td></tr></table></figure></li><li><p>redis默认是没有密码的，如果你需要有密码，将配置文件中的 # requirepass foobared 配置项取消注释，默认为注释状态。foobared为密码，可以根据情况自己指定。<strong>（选做）</strong></p></li><li><p>关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure></li><li><p>redis的服务默认只是允许本机连接，其他机器默认情况是不被允许连接，如果允许其他机器也能连接linux的reids服务，那么需要修改bind 127.0.0.1  你自己的linux机器的ip地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">69行</span><br><span class="line">bind 127.0.0.1 192.168.174.148</span><br></pre></td></tr></table></figure></li><li><p>启动redis的服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"># 显示进程</span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure></li><li><p>启动客户端去连接服务端测试： 启动客户端的方式：</p><ol><li>方式一(没有密码方式):  在src目录中  .&#x2F;redis-cli</li></ol></li></ol><p><img src="/2022/09/06/Redis/1637889067641.png" alt="1637889067641"> </p><p>​2. 方式二（如果存在密码情况）： 在src目录中：  .&#x2F;redis-cli  -h 127.0.0.1   -p 端口号  -a 密码</p><p><img src="/2022/09/06/Redis/1637889281595.png" alt="1637889281595"></p><ol start="7"><li>退出Redis</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 退出</span><br><span class="line">./redis-cli shutdown</span><br><span class="line"># 查看进程</span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p><strong>2）在Windows中安装Redis</strong></p><p>Redis的Windows版属于绿色软件，直接解压即可使用，解压后目录结构如下：</p><p><img src="/2022/09/06/Redis/image-20210927093112281.png" alt="image-20210927093112281"></p><h3 id="2-3-Redis服务启动与停止"><a href="#2-3-Redis服务启动与停止" class="headerlink" title="2.3 Redis服务启动与停止"></a>2.3 Redis服务启动与停止</h3><p><strong>1）Linux系统中启动和停止Redis</strong></p><p>执行Redis服务启动脚本文件redis-server：</p><p><img src="/2022/09/06/Redis/image-20210927094452556.png" alt="image-20210927094452556"></p><p>通过启动日志可以看到，Redis默认端口号为6379。</p><p>Ctrl + C停止Redis服务</p><p>通过redis-cli可以连接到本地的Redis服务，默认情况下不需要认证即可连接成功。</p><p>退出客户端可以输入exit或者quit命令。</p><p><strong>2）Windows系统中启动和停止Redis</strong></p><p>在控制台执行redis-server redis.</p><p><img src="/2022/09/06/Redis/image-20210927100421213.png" alt="image-20210927100421213"></p><p>Ctrl + C停止Redis服务</p><p>双击redis-cli.exe即可启动Redis客户端，默认连接的是本地的Redis服务，而且不需要认证即可连接成功。</p><p><img src="/2022/09/06/Redis/image-20210927100319016.png" alt="image-20210927100319016"></p><p>退出客户端可以输入exit或者quit命令。</p><blockquote></blockquote><h3 id="2-5-redis客户端程序"><a href="#2-5-redis客户端程序" class="headerlink" title="2.5 redis客户端程序"></a>2.5 redis客户端程序</h3><p>在今天的资料里面有redis的图形化界面工具，只需要双击不断下一步即可</p><p><img src="/2022/09/06/Redis/1637890382110.png" alt="1637890382110"></p><p>连接redis服务器</p><p><img src="/2022/09/06/Redis/1637844412099.png" alt="1637844412099"></p><h2 id="3-Redis数据类型"><a href="#3-Redis数据类型" class="headerlink" title="3. Redis数据类型"></a>3. Redis数据类型</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set &#x2F; zset</li></ul><h3 id="3-2-Redis-5种常用数据类型"><a href="#3-2-Redis-5种常用数据类型" class="headerlink" title="3.2 Redis 5种常用数据类型"></a>3.2 Redis 5种常用数据类型</h3><p><img src="/2022/09/06/Redis/image-20210927111819871.png" alt="image-20210927111819871"></p><p><strong>解释说明：</strong></p><blockquote><p>字符串(string)：普通字符串，常用</p><p>哈希(hash)：适合存储对象</p><p>列表(list)：按照插入顺序排序，可以有重复元素</p><p>集合(set)：无序集合，没有重复元素</p><p>有序集合(sorted set &#x2F; zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</p></blockquote><h2 id="4-Redis常用命令"><a href="#4-Redis常用命令" class="headerlink" title="4. Redis常用命令"></a>4. Redis常用命令</h2><h3 id="4-1-字符串string操作命令"><a href="#4-1-字符串string操作命令" class="headerlink" title="4.1 字符串string操作命令"></a>4.1 字符串string操作命令</h3><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value 只有在 key    不存在时设置 key 的值</li></ul><p><img src="/2022/09/06/Redis/1637765702570.png" alt="1637765702570"> </p><p>更多命令可以参考Redis中文网：<a href="https://www.redis.net.cn/">https://www.redis.net.cn</a></p><h3 id="4-2-哈希hash操作命令"><a href="#4-2-哈希hash操作命令" class="headerlink" title="4.2 哈希hash操作命令"></a>4.2 哈希hash操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li><li><strong>HGETALL</strong> key                         获取在哈希表中指定 key 的所有字段和值</li></ul><p><img src="/2022/09/06/Redis/image-20210927113014567.png" alt="image-20210927113014567"></p><h4 id="命令演示"><a href="#命令演示" class="headerlink" title="命令演示"></a>命令演示</h4><p><img src="/2022/09/06/Redis/image-20220605181818936.png" alt="image-20220605181818936"> </p><ol><li>创建hash类型的键为user，并且添加一个字段为username，值为newboy</li><li>向user中添加字段为age，值为18</li><li>分别得到user中的username和age的字段值</li><li>向user中同时添加多个字段和值，birthday 2018-01-01 sex male</li><li>同时取得多个字段：age 和 sex</li><li>得到user中所有的字段和值</li><li>删除user中的生日和性别字段</li></ol><h3 id="4-3-列表list操作命令"><a href="#4-3-列表list操作命令" class="headerlink" title="4.3 列表list操作命令"></a>4.3 列表list操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</li></ul><p><img src="/2022/09/06/Redis/image-20220605181806534.png" alt="image-20220605181806534">  </p><p>操作效果</p><p><img src="/2022/09/06/Redis/image-20220605181505952.png" alt="image-20220605181505952"> </p><h3 id="4-4-集合set操作命令"><a href="#4-4-集合set操作命令" class="headerlink" title="4.4 集合set操作命令"></a>4.4 集合set操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SDIFF</strong> key1 [key2]                                      返回给定所有集合的差集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><img src="/2022/09/06/Redis/image-20220605181738231.png" alt="image-20220605181738231" style="zoom:80%;"> <h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>创建两个集合：city和cities</p><p><img src="/2022/09/06/Redis/image-20220605183008357.png" alt="image-20220605183008357"> </p><h3 id="4-5-有序集合sorted-set操作命令"><a href="#4-5-有序集合sorted-set操作命令" class="headerlink" title="4.5 有序集合sorted set操作命令"></a>4.5 有序集合sorted set操作命令</h3><p>Redis sorted set 有序集合是 string 类型元素的集合，且不允许重复的成员。每个元素都会关联一个double类型的分数(score) 。redis正是通过分数来为集合中的成员进行从小到大排序。有序集合的成员是唯一的，但分数却可以重复。</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员，或者更新已存在成员的 分数</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><p><img src="/2022/09/06/Redis/image-20220605181725655.png" alt="image-20220605181725655"> </p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li>添加键country，分数是10，值是Japan</li><li>添加键country，分数是5，值是USA，添加键country，分数是50，值是Russian</li><li>添加键country，分数是1，值是China，分数是120，值是Korea</li><li>查询country中所有的元素</li><li>查询Japan的索引号(从0开始)</li><li>删除值为USA的元素</li><li>查询country中还有多少个元素</li><li>显示Russian的分数值</li></ol><h3 id="4-6-通用命令"><a href="#4-6-通用命令" class="headerlink" title="4.6 通用命令"></a>4.6 通用命令</h3><p>Redis中的通用命令，主要是针对key进行操作的相关命令：</p><ul><li><strong>KEYS</strong> pattern  查找所有符合给定模式( pattern)的 key </li><li><strong>EXISTS</strong> key  检查给定 key 是否存在</li><li><strong>TYPE</strong> key  返回 key 所储存的值的类型</li><li><strong>TTL</strong> key  返回给定 key 的剩余生存时间(TTL, time to live)，以秒为单位</li><li><strong>DEL</strong> key  该命令用于在 key 存在是删除 key</li></ul><h4 id="命令演示-1"><a href="#命令演示-1" class="headerlink" title="命令演示"></a>命令演示</h4><ol><li><p>显示所有的键</p></li><li><p>添加字符串man的值为Jack</p></li><li><p>从左边添加list的键是women，值是：Rose Mary Kate</p></li><li><p>添加一个字符串：person NewBoy</p></li><li><p>显示所有的键</p></li><li><p>一次删除women和man这两个键</p></li><li><p>分别判断person和women是否存在</p></li><li><p>分别判断person user myset mylist分别是什么类型</p></li></ol><h2 id="5-在Java中操作Redis"><a href="#5-在Java中操作Redis" class="headerlink" title="5. 在Java中操作Redis"></a>5. 在Java中操作Redis</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>前面我们讲解了Redis的常用命令，这些命令是我们操作Redis的基础，那么我们在java程序中应该如何操作Redis呢？这就需要使用Redis的Java客户端，就如同我们使用JDBC操作MySQL数据库一样。</p><p>Redis 的 Java 客户端很多，官方推荐的有三种：</p><ul><li>Jedis   </li><li>Lettuce</li><li>Redisson</li></ul><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。</p><h3 id="5-2-Jedis"><a href="#5-2-Jedis" class="headerlink" title="5.2 Jedis"></a>5.2 Jedis</h3><p>Jedis 是 Redis 的 Java 版本的客户端实现。</p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Jedis 操作 Redis 的步骤：</p><ol><li>获取连接</li><li>执行操作</li><li>关闭连接</li></ol><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 获取redis连接的客户端对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.78.128&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2. 存储数据</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;狗娃&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 获取数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+ jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//4. 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-Spring-Data-Redis"><a href="#5-3-Spring-Data-Redis" class="headerlink" title="5.3 Spring Data Redis"></a>5.3 Spring Data Redis</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p><img src="/2022/09/06/Redis/image-20210927143741458.png" alt="image-20210927143741458"></p><p>maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，针对 Jedis 客户端中大量api进行了归类封装,将同一类型操作封装为Operation接口，具体分类如下：</p><ol><li>ValueOperations：string类型，简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对hash类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ol><h4 id="5-3-2-环境搭建"><a href="#5-3-2-环境搭建" class="headerlink" title="5.3.2 环境搭建"></a>5.3.2 环境搭建</h4><p><img src="/2022/09/06/Redis/image-20220608162814121.png" alt="image-20220608162814121"> </p><h5 id="第一步-pom-xml"><a href="#第一步-pom-xml" class="headerlink" title="第一步: pom.xml"></a>第一步: pom.xml</h5><p>创建maven项目spring-data-redis-demo，配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 测试类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.76<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="第二步：编写启动类"><a href="#第二步：编写启动类" class="headerlink" title="第二步：编写启动类"></a>第二步：编写启动类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三步：配置application-yml"><a href="#第三步：配置application-yml" class="headerlink" title="第三步：配置application.yml"></a>第三步：配置application.yml</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 可以指定Linux或Window下Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.78</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># password:  有密码你才写</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#redis默认有16个数据库， 操作的数据库是哪个</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span> <span class="comment">#最大链接数，连接池中最多有10个</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">5</span>   <span class="comment"># 最大空闲数，多余的释放</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">1</span>   <span class="comment">#最小空闲数</span></span><br><span class="line">        <span class="comment">#举个例子：连接池初始化3个链接， 客户拿走2个链接，空闲1个,达到最小的空闲数，必须马上增加</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">200ms</span> <span class="comment">#连接池最大阻塞等待时间</span></span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>spring.redis.database：指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p></blockquote><h5 id="第四步：提供配置类"><a href="#第四步：提供配置类" class="headerlink" title="第四步：提供配置类"></a>第四步：提供配置类</h5><p>springdata_redis默认帮我们创建的RedisTemplate对象是使用jdk的序列号器帮我们键与值存储到redis中，而jdk的序列号器对键与值是采用二进制的方式存储的，所以我们会看到乱码的情况。如果我们需要看得懂，那么需要修改redistemplate使用的序列号器才行。   </p><ul><li>通过键使用字符串类型的序列化器：StringRedisSerializer</li><li>值使用JSON类型的序列化器：GenericJackson2JsonRedisSerializer</li><li>但因为在项目中LocalDateTime类型，GenericJackson2JsonRedisSerializer支持不理想，这里选择阿里巴巴的GenericFastJsonRedisSerializer，可以完美支持。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="comment">//创建模板对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//设置键的序列化器：字符串的序列化器StringRedisSerializer</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//设置值的序列化器：使用fastjson进行值的序列化器</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericFastJsonRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释说明：</p><blockquote><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别</p></blockquote><h5 id="第五步：提供测试类"><a href="#第五步：提供测试类" class="headerlink" title="第五步：提供测试类"></a>第五步：提供测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-3-操作字符串类型数据"><a href="#5-3-3-操作字符串类型数据" class="headerlink" title="5.3.3 操作字符串类型数据"></a>5.3.3 操作字符串类型数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set() 添加键和值</span><br><span class="line">get() 获取值</span><br><span class="line">setIfAbsent() 如果不存在这个键就添加</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用字符串类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;模板对象：&quot;</span> + redisTemplate);</span><br><span class="line">        <span class="comment">//1. 获取字符串操作对象</span></span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">opsForValue</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">//2. 添加字符串</span></span><br><span class="line">        opsForValue.set(<span class="string">&quot;book&quot;</span>, <span class="string">&quot;人鬼情喂鸟&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 获取字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">book</span> <span class="operator">=</span> (String) opsForValue.get(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;书籍：&quot;</span> + book);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 设置字符串，过期时间15秒</span></span><br><span class="line">        opsForValue.set(<span class="string">&quot;product&quot;</span>,<span class="string">&quot;娃娃&quot;</span>, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;产品：&quot;</span> + opsForValue.get(<span class="string">&quot;product&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 如果不存在才添加</span></span><br><span class="line">        opsForValue.setIfAbsent(<span class="string">&quot;book&quot;</span>, <span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">        <span class="comment">//获取字符串</span></span><br><span class="line">        book = (String) opsForValue.get(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;书籍：&quot;</span> + book);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.添加的值是User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">100</span>, <span class="string">&quot;孙悟空&quot;</span>, LocalDateTime.now());</span><br><span class="line">        opsForValue.set(<span class="string">&quot;kong&quot;</span>, user);</span><br><span class="line"></span><br><span class="line">        user = (User) opsForValue.get(<span class="string">&quot;kong&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象类型的序列化和反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime birthday;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis中内容</p><p><img src="/2022/09/06/Redis/image-20220608155108711.png" alt="image-20220608155108711"> </p><h4 id="5-3-4-操作哈希类型数据"><a href="#5-3-4-操作哈希类型数据" class="headerlink" title="5.3.4 操作哈希类型数据"></a>5.3.4 操作哈希类型数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put() 添加键，字段，值</span><br><span class="line">get() 通过键，字段获取值</span><br><span class="line">keys() 获取所有的字段</span><br><span class="line">values() 获取所有的值</span><br><span class="line">entries() 获取所有的键和值</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 使用hash类型</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取hash类型的操作对象</span></span><br><span class="line">    HashOperations&lt;String, Object, Object&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">    <span class="comment">//添加三个值</span></span><br><span class="line">    opsForHash.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    opsForHash.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    opsForHash.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取其中一个值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> opsForHash.get(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span> + age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有的键</span></span><br><span class="line">    Set&lt;Object&gt; keys = opsForHash.keys(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有的值</span></span><br><span class="line">    List&lt;Object&gt; values = opsForHash.values(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(values);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有键和值</span></span><br><span class="line">    Map&lt;Object, Object&gt; user = opsForHash.entries(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-5-操作列表类型数据"><a href="#5-3-5-操作列表类型数据" class="headerlink" title="5.3.5 操作列表类型数据"></a>5.3.5 操作列表类型数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leftPushAll() 从左边添加多个元素</span><br><span class="line">range() 获取指定范围所有的元素</span><br><span class="line">size() 获取列表的长度</span><br><span class="line">leftPop() 删除最左边的元素</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用list类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取操作列表的对象</span></span><br><span class="line">    ListOperations&lt;String, Object&gt; opsForList = redisTemplate.opsForList();</span><br><span class="line">    <span class="comment">//添加多个元素到列表中</span></span><br><span class="line">    opsForList.leftPushAll(<span class="string">&quot;books&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;黑楼梦&quot;</span>, <span class="string">&quot;青楼梦&quot;</span>);</span><br><span class="line">    <span class="comment">//获取所有的元素</span></span><br><span class="line">    List&lt;Object&gt; books = opsForList.range(<span class="string">&quot;books&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(books);</span><br><span class="line">    <span class="comment">//获取元素个数</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> opsForList.size(<span class="string">&quot;books&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;长度：&quot;</span> + size);</span><br><span class="line">    <span class="comment">//删除最左边的元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">book</span> <span class="operator">=</span> (String) opsForList.leftPop(<span class="string">&quot;books&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除的元素是：&quot;</span> + book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-6-操作集合类型数据"><a href="#5-3-6-操作集合类型数据" class="headerlink" title="5.3.6 操作集合类型数据"></a>5.3.6 操作集合类型数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add() 添加一个或多个元素</span><br><span class="line">members() 显示所有的成员</span><br><span class="line">remove() 删除其中一个元素</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用set类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    SetOperations&lt;String, Object&gt; opsForSet = redisTemplate.opsForSet();</span><br><span class="line">    <span class="comment">//添加多个元素</span></span><br><span class="line">    opsForSet.add(<span class="string">&quot;persons&quot;</span>, <span class="string">&quot;白骨精&quot;</span>, <span class="string">&quot;红骨精&quot;</span>, <span class="string">&quot;排骨精&quot;</span>);</span><br><span class="line">    <span class="comment">//获取所有的元素</span></span><br><span class="line">    Set&lt;Object&gt; persons = opsForSet.members(<span class="string">&quot;persons&quot;</span>);</span><br><span class="line">    System.out.println(persons);</span><br><span class="line">    <span class="comment">//删除其中一个元素</span></span><br><span class="line">    opsForSet.remove(<span class="string">&quot;persons&quot;</span>, <span class="string">&quot;排骨精&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-7-操作有序集合类型数据"><a href="#5-3-7-操作有序集合类型数据" class="headerlink" title="5.3.7 操作有序集合类型数据"></a>5.3.7 操作有序集合类型数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add() 添加一个或多个元素，同时指定值和分数</span><br><span class="line">range() 获取指定范围的所有元素</span><br><span class="line">incrementScore() 给某个元素加分</span><br><span class="line">rangeWithScores() 获取指定范围的值和分数</span><br><span class="line">getValue() 获取值</span><br><span class="line">getScore() 获取分数</span><br><span class="line">remove() 删除指定的元素</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用zset类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span> &#123;</span><br><span class="line">    ZSetOperations&lt;String, Object&gt; opsForZSet = redisTemplate.opsForZSet();</span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    opsForZSet.add(<span class="string">&quot;cities&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="number">3000</span>);</span><br><span class="line">    opsForZSet.add(<span class="string">&quot;cities&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    opsForZSet.add(<span class="string">&quot;cities&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//获取所有的元素</span></span><br><span class="line">    Set&lt;Object&gt; cities = opsForZSet.range(<span class="string">&quot;cities&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(cities);</span><br><span class="line">    <span class="comment">//给北京加500</span></span><br><span class="line">    opsForZSet.incrementScore(<span class="string">&quot;cities&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="number">500</span>);</span><br><span class="line">    <span class="comment">//获取值和分数</span></span><br><span class="line">    Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = opsForZSet.rangeWithScores(<span class="string">&quot;cities&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    tuples.forEach(tuple -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;值：&quot;</span> + tuple.getValue() + <span class="string">&quot;，分数：&quot;</span> + tuple.getScore());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//删除指定的元素</span></span><br><span class="line">    opsForZSet.remove(<span class="string">&quot;cities&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-8-通用操作"><a href="#5-3-8-通用操作" class="headerlink" title="5.3.8 通用操作"></a>5.3.8 通用操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys() 获取指定的键</span><br><span class="line">delete() 删除键和值</span><br><span class="line">hasKey() 判断是否存在某个键</span><br><span class="line">type() 获取值的类型</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用通用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOthers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用模板对象的方法</span></span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;c*&quot;</span>);</span><br><span class="line">    System.out.println(keys);</span><br><span class="line">    <span class="comment">//删除指定的键和值</span></span><br><span class="line">    redisTemplate.delete(<span class="string">&quot;company&quot;</span>);</span><br><span class="line">    <span class="comment">//判断某个值是否存在</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">exists</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;cities&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;键是否存在：&quot;</span> + exists);</span><br><span class="line">    <span class="comment">//获取某个值的类型</span></span><br><span class="line">    <span class="type">DataType</span> <span class="variable">type</span> <span class="operator">=</span> redisTemplate.type(<span class="string">&quot;country&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;类型：&quot;</span> + type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
