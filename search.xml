<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JWT技術</title>
      <link href="/2022/09/12/JWT/"/>
      <url>/2022/09/12/JWT/</url>
      
        <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>JWT 是什么?</li><li>有什么功能和作用?</li><li>实现的原理是?</li><li>使用场景?</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>JWT(Json Web Token) 是 基于JSON的，用于在目前Web开发中 最流行的跨域身份验证解决方案，可以面向服务器群集，需要一个类似“session”的角色来保存会话数据实现共享。</p><h4 id="JWT有什么功能？"><a href="#JWT有什么功能？" class="headerlink" title="JWT有什么功能？"></a>JWT有什么功能？</h4><ol><li>跨域身份验证</li></ol><h4 id="实现的原理"><a href="#实现的原理" class="headerlink" title="实现的原理"></a>实现的原理</h4><ol><li>服务器只负责提供token 给客户端，不保存会话数据。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="/2022/09/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>复杂度分析</li><li></li></ul><h3 id="大O复杂度表示法-记住四个原则"><a href="#大O复杂度表示法-记住四个原则" class="headerlink" title="大O复杂度表示法 记住四个原则"></a>大O复杂度表示法 记住四个原则</h3><p>首先要清楚基础概念,在CPU上运行的角度上看, 每一条语句执行类似的操作:”读数据 - 运算 - 写数据”。因此在CPU上的每一次操作都是原子性操作，譬如 i &#x3D; 1;  代表 cpu 将1写入到 i 变量就是一次原子性操作。</p><h4 id="原则1-一段代码的总执行时间-T-n-等于-每一条语句总执行次数-累加数-成正比"><a href="#原则1-一段代码的总执行时间-T-n-等于-每一条语句总执行次数-累加数-成正比" class="headerlink" title="原则1 一段代码的总执行时间 T(n)等于 每一条语句总执行次数(累加数) 成正比"></a>原则1 一段代码的总执行时间 T(n)等于 每一条语句总执行次数(累加数) 成正比</h4><p>把CPU 的一次原子性操作当做一个unit_time。分析如下代码的T(n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cal(int n)&#123;</span><br><span class="line">   int sum = 0; //原子性操作执行1次,CPU 将 10 写入到sum 的工作内存地址中  </span><br><span class="line">   int i = 1;   //原子性操作执行1次,CPU 将 1 写入到 变量 i 的工作内存地址中</span><br><span class="line">   for (int i = 0; i &lt; n; ++i)&#123;  // 这行代码执行n 次</span><br><span class="line">       sum = sum + i;    // 这行代码执行n 次 </span><br><span class="line">   &#125;</span><br><span class="line">   return sum; // 执行1次,返回存储在 sum 内存地址的值</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>分析得出上述 T(n) &#x3D; (2n+3) * unit_time</p><h4 id="原则2-时间复杂度公式中的-低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。"><a href="#原则2-时间复杂度公式中的-低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。" class="headerlink" title="原则2 时间复杂度公式中的 低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。"></a>原则2 时间复杂度公式中的 低阶，常量，系数3部分并不左右增长趋势，只需要记录一个最大量级。</h4><p>由上述 得出 T(n) &#x3D; (2n+3)*unit_time  &#x3D; O(f(n)) &#x2F;&#x2F; f(n)表示每一条代码语句执行次数的累加和<br>unit_time 不变, 系数为2 , 常量为3 。因此用大O表示法简写为： <strong>O(n)</strong></p><h4 id="原则3-加法法则-代码总复杂度等于量级最大的那段代码的复杂度。"><a href="#原则3-加法法则-代码总复杂度等于量级最大的那段代码的复杂度。" class="headerlink" title="原则3 加法法则:代码总复杂度等于量级最大的那段代码的复杂度。"></a>原则3 加法法则:代码总复杂度等于量级最大的那段代码的复杂度。</h4><p>通常会忽略公式中的常量,低阶和系数,只记录最大量级的基础上，我们也只需要关注 循环执行次数最多的那段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cal(int n)&#123;</span><br><span class="line">    int sum = 0; //原子性操作执行1次,CPU 将 10 写入到sum 的工作内存地址中  </span><br><span class="line">    int i = 1;   //原子性操作执行1次,CPU 将 1 写入到 变量 i 的工作内存地址中</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)&#123;  // 这行代码执行n 次</span><br><span class="line">        sum = sum + i;    // 这行代码执行n 次 </span><br><span class="line">    &#125;</span><br><span class="line">    return sum; // 执行1次,返回存储在 sum 内存地址的值</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>上述代码 , 循环执行次数最多的那段代码在 3,4行 ,因此 重点关注。</p><h4 id="原则4-乘法法则-嵌套代码的复杂度等于-嵌套内外代码复杂度的乘积"><a href="#原则4-乘法法则-嵌套代码的复杂度等于-嵌套内外代码复杂度的乘积" class="headerlink" title="原则4 乘法法则:嵌套代码的复杂度等于 嵌套内外代码复杂度的乘积"></a>原则4 乘法法则:嵌套代码的复杂度等于 嵌套内外代码复杂度的乘积</h4><p>根据乘法法则分析以下代码的时间复杂度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cal(int)&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 1;</span><br><span class="line">    int j = 1;</span><br><span class="line">    for(int i=0;i&lt;= n;++i)&#123;   // ++i 执行了 n次</span><br><span class="line">        j=1;   //执行 了n次 </span><br><span class="line">        for(int j=0;j&lt;=n;++j)&#123;  // ++j 执行了 n次</span><br><span class="line">            sum = sum + i * j;   // 执行了 n 次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析得出 T1(n) </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bug日志记录</title>
      <link href="/2022/09/10/Bug%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/"/>
      <url>/2022/09/10/Bug%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><table><thead><tr><th>异常类型</th><th>异常名</th><th>异常信息</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>解决方案:</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目产品分析</title>
      <link href="/2022/09/10/%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B9%A6/"/>
      <url>/2022/09/10/%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li><p>需求业务分析</p></li><li><p>概要设计分析</p></li><li><p>代码详细设计分析</p></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="项目背景和介绍"><a href="#项目背景和介绍" class="headerlink" title="项目背景和介绍"></a>项目背景和介绍</h3><p>随着时代的发展，越来越多的国内企业开始采用CRM客户关系管理系统，近年来CRM不仅受到大型企业的青睐，也是中小企业快速成长的催化剂。市场、客户信息、产品、业务人员、渠道等各类信息流的不断增长，传统方式对于管理全渠道信息流成本越来越高，所以需要一个软件产品来解决这些问题。</p><p>互联网+的出现，改变了很多行业同样很多行业的理念也在转变，伴随着电子商务、智能手机的不断应用，使企业更加简单的接触消费者，直接与消费者互动收集消费者反馈成为可能。那原本以产品以企业为核心的理念逐渐在转变，转变以“客户为中心”，及时服务客户，提高客户满意程度，从而提高企业营收。依托强大的信息技术，企业可以借助CRM系统不断把客户跟进，服务，成交，售后打通，而且不断依托CRM工具来优化这个流程，来适应整个市场的不断变化。</p><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>操作系统：Web平台<br>数据库系统：Mysql<br>运行环境：JRE<br>开发语言：JAVA<br>开发代码模式：多模块Maven模式<br>架构模式：MVC 三层架构模式</p><h3 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h3><p>常用的后台系统角色有：<br>运营人员：根据客户业务数据，统计当前系统及业务痛点，提出需求进行更新优化。<br>财务专员：负责系统财务结算审批或财务开销<br>销售专员：负责梳理客户资料，优化销售流程。借助软件提高销售成功率<br>销售主管：梳理工作内容，调整销售方案，提高销售业绩<br>客户管理人员：使用后台服务<br>市场专员：根据前端意向用户，跟进线索转换为意向客户<br>管理员：负责系统日常的运行和维护。</p><h3 id="系统架构图-和业务架构图"><a href="#系统架构图-和业务架构图" class="headerlink" title="系统架构图 和业务架构图"></a>系统架构图 和业务架构图</h3><h2 id="概要设计分析"><a href="#概要设计分析" class="headerlink" title="概要设计分析"></a>概要设计分析</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>服务器系统:Linux Centos7<br>客户端:Internet,Chorme<br>应用服务器:Tomcat<br>数据库:Mysql</p><p>开发工具:</p><table><thead><tr><th>工具</th><th>版本号</th></tr></thead><tbody><tr><td>IDEA</td><td>开发IDE</td></tr><tr><td>MobaXterm</td><td>Linux远程连接工具</td></tr><tr><td>Navicat</td><td>数据库连接工具</td></tr><tr><td>Another Redis Desktop Manager</td><td>Redis 客户端</td></tr><tr><td>PostMan</td><td>接口调试工具</td></tr><tr><td>代码管理</td><td>Git and Gitee</td></tr><tr><td>CHINER元数建模</td><td>数据库设计工具</td></tr><tr><td>Xminder</td><td>思维导图工具</td></tr></tbody></table><p>开发环境:</p><table><thead><tr><th>工具</th><th>版本号</th></tr></thead><tbody><tr><td>JDK</td><td>1.8</td></tr><tr><td>Mysql</td><td>5.7.24</td></tr><tr><td>Redis</td><td></td></tr><tr><td>SpringBoot</td><td>2.2.13.RELEASE</td></tr><tr><td>其他依赖包版本</td><td>参考项目parent模块</td></tr></tbody></table><h3 id="主要模块介绍"><a href="#主要模块介绍" class="headerlink" title="主要模块介绍"></a>主要模块介绍</h3><ul><li>首页功能(常用于数据展示)</li><li>活动管理</li><li>统计分析</li><li>系统管理</li><li>CRM管理</li></ul><h3 id="数据结构表设计-只列出核心字段-其他普通字段不做分析"><a href="#数据结构表设计-只列出核心字段-其他普通字段不做分析" class="headerlink" title="数据结构表设计(只列出核心字段,其他普通字段不做分析)"></a>数据结构表设计(只列出核心字段,其他普通字段不做分析)</h3><p>线索表tb_clue:</p><table><thead><tr><th>字段名</th><th>姓名</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>线索id</td><td>id 是tb_clue_track_record的外键</td></tr><tr><td>activity_id</td><td>活动id</td><td></td></tr><tr><td>type</td><td>0代表线索,1代表商机</td><td></td></tr><tr><td>lastest</td><td>代表最终归属人</td><td></td></tr></tbody></table><p>线索跟进记录表tb_clue_track_record:</p><table><thead><tr><th>字段名</th><th>姓名</th><th>备注</th></tr></thead><tbody><tr><td>分配记录表tb_assign_record:</td><td></td><td></td></tr><tr><td>字段名</td><td>姓名</td><td>备注</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><p>商机表:tb_business</p><table><thead><tr><th>字段名</th><th>姓名</th><th>备注</th></tr></thead><tbody><tr><td>商机跟进记录表:tb_business_track_record</td><td></td><td></td></tr><tr><td>字段名</td><td>姓名</td><td>备注</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr><tr><td>合同表:tb_contract</td><td></td><td></td></tr><tr><td>字段名</td><td>姓名</td><td>备注</td></tr><tr><td>—-</td><td>—-</td><td>—-</td></tr></tbody></table><h4 id="用户、角色、权限数据库设计"><a href="#用户、角色、权限数据库设计" class="headerlink" title="用户、角色、权限数据库设计"></a>用户、角色、权限数据库设计</h4><p>用户表:sys_user</p><table><thead><tr><th>字段名</th><th>代表</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>用户id</td><td></td></tr></tbody></table><p>用户角色中间表 sys_user_role<br>|字段名|代表|备注|<br>|user_id|用户id||<br>|role_id|该用户的角色id||</p><p>角色表 sys_role<br>|role_id|角色id||</p><p>角色和权限菜单目录表 sys_role_menu<br>|role_id|角色id||<br>|menu_id|菜单id||</p><p>权限目录表 sys_menu<br>|menu_id|目录菜单id|</p><h2 id="代码详细设计分析"><a href="#代码详细设计分析" class="headerlink" title="代码详细设计分析"></a>代码详细设计分析</h2><p>由于本项目是由<strong>Maven多模块</strong>实现现,简单介绍下项目各模块技术:</p><h3 id="源码模块分析"><a href="#源码模块分析" class="headerlink" title="源码模块分析"></a>源码模块分析</h3><p>parent基本模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>容器+MVC框架</td></tr><tr><td>Druid</td><td>阿里云数据库连接池</td></tr><tr><td>eu.bitwalker</td><td>解析客户端操作系统、浏览器等</td></tr><tr><td>pageHelper</td><td>分页插件</td></tr><tr><td>oshi</td><td>获取系统信息</td></tr><tr><td>jna</td><td>Java工具类用于在运行期间动态访问系统本地库</td></tr><tr><td>commons-io</td><td>io常用工具类</td></tr><tr><td>commons-fileupload</td><td>文件上传工具类</td></tr><tr><td>commons-colletions</td><td>collectons工具类</td></tr><tr><td>poi</td><td>常用excel工具</td></tr><tr><td>velocity</td><td>velocity代码生成模板器</td></tr><tr><td>fastjson</td><td>阿里Json解析器</td></tr><tr><td>kaptcha</td><td>验证码</td></tr><tr><td>lombok</td><td>lombok管理</td></tr><tr><td>minio</td><td>io工具类</td></tr><tr><td>okHttp</td><td>Http工具类</td></tr></tbody></table><p>framework核心框架技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot-Web</td><td>Web容器</td></tr><tr><td>SpringBoot-AOP</td><td>AOP拦截器</td></tr></tbody></table><p>admin模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>mysql-connector-java</td><td>mysql驱动包</td></tr><tr><td>mybatis</td><td>mybatis ORM框架</td></tr></tbody></table><p>bussiness模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>showfun公共模块</td></tr><tr><td>showfun-system</td><td>showfun项目系统模块</td></tr><tr><td>showfun-clues</td><td>项目clues模块</td></tr></tbody></table><p>clues模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>showfun公共模块</td></tr><tr><td>showfun-system</td><td>showfun项目系统模块</td></tr></tbody></table><p>common模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Spring-context-support</td><td>Spring上下文核心工具</td></tr><tr><td>Spring-web</td><td>SpringWeb模块</td></tr><tr><td>Spring-security</td><td>Spring安全认证模块</td></tr><tr><td>PageHelper</td><td>分页插件</td></tr><tr><td>Validation-api</td><td>自定义验证注解</td></tr><tr><td>commons-lang</td><td>常用工具类</td></tr><tr><td>jackson-databind</td><td>Jackson工具类</td></tr><tr><td>snakeyaml</td><td>YAML解析器</td></tr><tr><td>jjwt</td><td>Token生成与解析器</td></tr><tr><td>redis</td><td>redis 缓存</td></tr><tr><td>EasyExcel</td><td>easyExcel 工具类</td></tr></tbody></table><p>contract合同模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>mysql-connector-java</td><td>mysql驱动工具类</td></tr><tr><td>showfun-common</td><td>项目公共模块</td></tr><tr><td>showfun-bussiness</td><td>项目业务模块</td></tr></tbody></table><p>report模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-contract</td><td>项目合同模块</td></tr></tbody></table><p>task模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>项目公共模块</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程技术</title>
      <link href="/2022/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程编程-上"><a href="#多线程编程-上" class="headerlink" title="多线程编程(上)"></a>多线程编程(上)</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>进程和线程的基本概念</li><li>多线程并发出现问题的根源</li><li>Java如何解决并发问题</li><li>线程安全的实现方式</li></ul><h3 id="多线程的一些名词"><a href="#多线程的一些名词" class="headerlink" title="多线程的一些名词"></a>多线程的一些名词</h3><ul><li>四核八处理器：指的是拥有四个CPU ，可以同时处理8个进程，且CPU之间可以切换运行不同的进程。</li><li>进程: 进程指的是运行中的应用程序,通常操作系统会分配 CPU, 内存, 磁盘,网络资源给该进程使用，进程有各自的内存单元相互独立。</li><li>线程：指一个进程（应用程序）内的线性程序功能，共享内存。一般的软件都是支持多线程的，指<strong>同一时刻内</strong>可以同时执行多个线程任务，实现高并发。</li><li>并发：指的是单个CPU <strong>同一个时刻</strong> 可以切换多个线程任务交替执行,我们的大脑就是简单的单个CPU处理多种复杂事情的并发。但由于并发是不断切换执行任务，容易出现“问题”，要谨慎处理。</li><li>并行：指的是 多个CPU 在<strong>同一时刻同时执行任务</strong>  。类似于马拉松选手在同一时刻同时出发的场景。</li></ul><p>多线程的好处和坏处<br>好处：由于CPU，内存，IO读写设备的速度是有极大的差异的，为了合理利用CPU的高性能和平衡三者的差异，<br>经常做一些优化的设计：</p><ol><li>CPU 增强了缓存，均衡了与内存的速度差异 </li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异</li><li>编译程序优化代码指令执行次序，使得缓存能够得到更加合理地利用</li></ol><p>缺点:</p><ol><li>CPU 增加缓存机制, 导致了可见性问题。</li><li>操作系统的操作 导致了原子性问题。</li><li>编译程序的操作 导致了有序性问题。</li></ol><h3 id="并发出现问题的根源-可见性问题-原子性问题-有效性问题"><a href="#并发出现问题的根源-可见性问题-原子性问题-有效性问题" class="headerlink" title="并发出现问题的根源: 可见性问题, 原子性问题,有效性问题"></a>并发出现问题的根源: 可见性问题, 原子性问题,有效性问题</h3><p>可见性问题：常出现在读写过程中。 指的是一个对象A(对象包括数据库事务，CPU…等等)在写入数据过程中，但未写入到内存完成或数据被临时存储(譬如缓存),另一对象B读取（查询）还是共享数据的值，则无法正确获取修改后的值。这就是可见性问题，不同计算机组件有不同的解决方案：(待写)</p><p>原子性问题：操作系统分时复用导致</p><p>即一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>在Java中，对<strong>基本数据类型的变量的读取和赋值操作</strong>是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//假设有两个线程执行以下代码:</span><br><span class="line">int i = 1;  //原子性操作</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">假设CPU执行这段代码使用线程1包括三个原子性操作: </span><br><span class="line">1)将变量i从内存读取到CPU寄存器  </span><br><span class="line">2)CPU寄存器中执行 i+1 </span><br><span class="line">3)将结果2写入到内存中(缓存机制导致可能写入的是CPU缓存而不是内存)</span><br><span class="line">*/</span><br><span class="line">i += 1;  //这不是原子性操作,只有单一的读取和赋值才是原子性操作。</span><br><span class="line"></span><br><span class="line">i += 1;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">由于CPU有分时复用(线程切换)到线程2执行这个代码,当时变量i在内存还是1,因此最终线程2执行完成的结果比线程1更快结束,导致写入内存的值是 2, 再切换到线程1执行后续操作 而不是预期结果 3 </span><br><span class="line">出现原子性问题</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>有效性问题: 由编译器重排序引起的<br>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型:(从先到后)</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 </li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 </li><li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ol><h4 id="Java如何解决并发的问题"><a href="#Java如何解决并发的问题" class="headerlink" title="Java如何解决并发的问题?"></a>Java如何解决并发的问题?</h4><p>JAVA 提供了JMM（Java Memory Model）规范JVM 如何提供按需禁用缓存和编译的方法和JMM保证了基本读取和赋值是原子性操作，且必须是将数字赋值给某个变量。</p><p>提供了以下一些功能保证并发不出现问题：</p><ul><li>3个关键字 volatile synchronized 和 final </li><li>Happens-Before规范规则</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分析如下的语句哪些操作是原子性操作</span><br><span class="line">x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br><span class="line">y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br><span class="line">x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br><span class="line">x = x + 1;     //语句4： 同语句3</span><br></pre></td></tr></table></figure><p>因此JAVA提供了synchronized 和 java.util.concurrent.locks.Lock 锁接口 ,synchronized应用于变量，方法和类，代表该代码块是同步且锁定的，可以  :</p><ol><li>可以保证任一时刻只有一个线程执行同步代码块,释放锁之前对变量的修改刷新到主存中。</li><li>保证了数据读取和写入的原子性。</li><li>保证了共享变量的内存可见性</li></ol><p>JAVA 提供了volatitle关键字：本质上就是告知JVM 当前变量在CPU寄存器中的值是不确定，需要重新到内存取值。<br>有以下作用：</p><ol><li>保证了共享变量被修改的值立刻被更新到主存中,方便其他线程读取新的值。</li><li>应用于变量中，保证了其他线程对共享变量的可见性。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus技術详解</title>
      <link href="/2022/09/08/MybatisPlus/"/>
      <url>/2022/09/08/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>MybatisPlus的简介和技术介绍</li><li>能够基于MybatisPlus完成标准Dao开发,CURD操作</li><li>能够掌握MybatisPlus的条件查询</li><li>能够掌握MybatisPlus的字段映射和 表名映射</li><li>能够配置”代码生成器”的相关配置</li></ul><h3 id="MybatisPlus-的简介和源码解析"><a href="#MybatisPlus-的简介和源码解析" class="headerlink" title="MybatisPlus 的简介和源码解析"></a>MybatisPlus 的简介和源码解析</h3><h4 id="Mybatis-是什么"><a href="#Mybatis-是什么" class="headerlink" title="Mybatis 是什么?"></a>Mybatis 是什么?</h4><h3 id="使用MybatisPlus实现Java代码访问数据库"><a href="#使用MybatisPlus实现Java代码访问数据库" class="headerlink" title="使用MybatisPlus实现Java代码访问数据库"></a>使用MybatisPlus实现Java代码访问数据库</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li><p>添加mp起步依赖 mybatis-plus-boot-starter , mybatis-plus-boot-starter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>设置springboot *.yml 配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">  #将SQL语句操作的日志打印到Console</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mappers/*.xml</span><br></pre></td></tr></table></figure></li><li><p>编写Mapper 接口 并继承 BaseMapper&lt;要映射实体的类名&gt;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍 BaseMaaper 接口:该类封装了一个Mapper对象中执行DML DQL 的方法<br>[CURD] 基本操作方法</p></li></ol><ul><li>int insert(T entity) 插入一个 实体类对象</li><li>int deteleById(T entity) 删除一个 实体类对象</li><li>int deteleBatchIds(Collection&lt;? extends Serializable&gt; idList) 根据ids 集合批量删除多条记录:</li><li>int updateById(T entity) 根据id更新记录</li><li>T selectById(Serializable id) 根据主键ID 查询单个对象</li><li>List<T> selectBatchIds(Collection&lt;? extends Serializable&gt; idList) 根据ids 集合查询多个实体对象。</li><li>List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper); 根据Entity条件,查询全部记录。</li></ul><p>[Wrapper] 包装接口,包装各种大部分生成 where 条件的方法</p><ul><li>QueryWrapper  DQL条件查询接口</li><li>UpdateWrapper DML条件更新接口</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-BeanFactory详解</title>
      <link href="/2022/09/07/Spring-BeanFacotry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/07/Spring-BeanFacotry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IOC-容器-和-Beans"><a href="#Spring-IOC-容器-和-Beans" class="headerlink" title="Spring IOC 容器 和 Beans"></a>Spring IOC 容器 和 Beans</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>Spring是什么</li><li>Spring IOC &#x2F; DI</li><li>Spring-beans 模块</li><li>Spring AOP</li><li>BeanFacotry是自动创建一个Bean对象的流程</li></ul><h3 id="Spring-是什么"><a href="#Spring-是什么" class="headerlink" title="Spring 是什么"></a>Spring 是什么</h3><p>Spring 是一个减轻传统 JAVAEE应用 EJB 管理,和复杂配置的轻量级框架, 其底层模块有 core ,content , beans , AOP ,SpEL表达式 ,Spring-JDBC, ORM模块。<br>也是一个生态，基于Spring Framework 已经衍生出各种 Spring 优秀框架 ，譬如Spring MVC， Spring Boot ，Spring JPA ， Spring Cloud， Spring Cloud Alibaba 。<br>Spring Framework 包含了两个核心理念，Spring - IOC 和Spring AOP 理念。</p><h3 id="Spring-IOC-理念"><a href="#Spring-IOC-理念" class="headerlink" title="Spring IOC 理念"></a>Spring IOC 理念</h3><p>Inversion of Control 控制反转原理，也叫做DI ，在DI过程中，支持构造器注入，setter方法注入和返回值。 Spring的Bean容器具有Ioc 的能力，Spring提供了两种配置方式 可以注入到 BeanFactory 容器中，从而创建 Bean 对象和初始化对象属性。</p><h4 id="配置一：通过外部XML-文件定义BD信息。"><a href="#配置一：通过外部XML-文件定义BD信息。" class="headerlink" title="配置一：通过外部XML 文件定义BD信息。"></a>配置一：通过外部XML 文件定义BD信息。</h4><p>通过外部XML文件生成BeanDefinition 信息的基本流程是:<br>XML文件 ——  IO流  ——  dom4j (DocmentForJava) —— 获取Docment 对象 —— 获取父子节点Node —— 通过Node 节点 得到各节点的属性 —— 封装到RootBeanDefination&#x2F;ChildDefinition</p><h4 id="配置二：通过注解-Annoation-定义BD信息。"><a href="#配置二：通过注解-Annoation-定义BD信息。" class="headerlink" title="配置二：通过注解@Annoation 定义BD信息。"></a>配置二：通过注解@Annoation 定义BD信息。</h4><p>注解类 生成BeanDefinition 的基本流程是<br>@Annotaion类 - 获取该注释类Class对象 - AnnotationBeanDefinition </p><h3 id="Spring-beans-模块解析"><a href="#Spring-beans-模块解析" class="headerlink" title="Spring-beans 模块解析"></a>Spring-beans 模块解析</h3><h4 id="BeanDefinitionReader-和-BeanDefinition-接口"><a href="#BeanDefinitionReader-和-BeanDefinition-接口" class="headerlink" title="BeanDefinitionReader 和 BeanDefinition 接口"></a>BeanDefinitionReader 和 BeanDefinition 接口</h4><p><strong>BeanDefinitionReader</strong> 本接口不用实现, 仅仅为了规范和约束 BeanDefinition的标准命名格式。</p><blockquote><p>Simple interface for bean definition readers. Specifies load methods with Resource and String location parameters.<br>Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format.<br>Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions</p></blockquote><p><strong>BeanDefinition</strong></p><blockquote><p>官方注释： A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations.<br>This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor to introspect and modify property values and other bean metadata </p></blockquote><p>一个BeanDefinition 对应一个Bean实例 ,包含<strong>Bean属性值, 构造器 和 bean之间的关系</strong> ,这个接口的主要目的就是</p><ol><li>接收符合BeanDefinition的配置信息。</li><li>允许 BeanFactoryPostProcessor 去修改属性值和bean的数据模型。</li></ol><h4 id="BeanPostProcessor-Bean后置处理器"><a href="#BeanPostProcessor-Bean后置处理器" class="headerlink" title="BeanPostProcessor Bean后置处理器"></a>BeanPostProcessor Bean后置处理器</h4><p>由于 BeanDefinition 只负责将Bean的配置存储,并不负责数据的转换。譬如jdbc.properties 的jdbc.username 存入的XML文件时 是${jdbc.username},在BD 时依然还是jdbc.username,Spring 使用 Wrapper模式,执行PostProcess后置处理器可以将${jdbc.username}替换成 root </p><h4 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h4><h4 id="BeanFactoryPostProcess-Bean工厂后置处理器"><a href="#BeanFactoryPostProcess-Bean工厂后置处理器" class="headerlink" title="BeanFactoryPostProcess Bean工厂后置处理器"></a>BeanFactoryPostProcess Bean工厂后置处理器</h4><p>对BeanFacotry 进行增强处理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 技术详解</title>
      <link href="/2022/09/06/Redis%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/09/06/Redis%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis中间件技术"><a href="#Redis中间件技术" class="headerlink" title="Redis中间件技术"></a>Redis中间件技术</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>了解Redis技术的背景和功能</li><li>Redis 的原理机制 和优缺点</li><li>Redis环境搭建。</li><li>Java Redis API 的初级应用</li><li>Spring-cache + Redis 的应用</li><li>项目调试中常出现的问题</li></ul><h2 id="了解Redis技术的背景和作用"><a href="#了解Redis技术的背景和作用" class="headerlink" title="了解Redis技术的背景和作用"></a>了解Redis技术的背景和作用</h2><p>Redis 是一位 Salvatore Sanfilippo 意大利程序员写的， 是一个 <strong>key-vlaue</strong> 存储系统的 非关系型数据库。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言（<strong>包括JAVA</strong>）的 API。</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets) 、sorted set（有序set）</p><p>作用：</p><p>为了解决用户 过度请求频繁访问数据亏库，导致数据库访问压力大，系统性能下降，用户体验差等问题的一种缓存型中间技术。</p><p>！！！！人人都说官网就是最好的教程。必须学会看</p><p>如下是翻译，如果有不对。可以自己去官网看<a href="https://redis.io/docs/about/">Redis官网</a></p><p>其主要功能：</p><ol><li><p>提供<strong>5种数据结构</strong>（字符串(String)、哈希(Hash)、列表(list)、集合(sets) 、sorted set（有序set）支持范围查询 ，bitmaps，基数估计算法，地址空间索引 和 流式化的操作</p></li><li><p>Redis 已内置主从复制，Lua脚本，LRU 回收，事务、在磁盘上不同级别的持久性、通过Redis Sentinel和Redis Cluster自动分区提供高可用性</p></li><li><p>为了达到最好的性能，Redis使用一个内存的数据集，两种方式实现缓存。</p><p> ）您的数据Redis可以通过定期将数据集转储到磁盘（Redis DB），将redis存储的数据生成快照存储到磁盘上。</p><p> ）将每个命令附加到基于磁盘的日志来持久化数据（Append Only File）先记录日志，下次启动再加载此类文件。</p><p> 两个可以一起使用，但如果您只需要一个功能丰富的、联网的、内存中的缓存，您也可以禁用持久性（ARF）。</p></li></ol><blockquote><p>To achieve top performance, Redis works with an  <strong>in-memory dataset</strong> . Depending on your use case, Redis can persist your data either by periodically <a href="https://redis.io/topics/persistence#snapshotting">dumping the dataset to disk</a> or by <a href="https://redis.io/topics/persistence#append-only-file">appending each command to a disk-based log</a>. You can also disable persistence if you just need a feature-rich, networked, in-memory cache.</p><p>Redis supports <a href="https://redis.io/topics/replication">asynchronous replication</a>, with fast non-blocking synchronization and auto-reconnection with partial resynchronization on net split.</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p>image.png​</p><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并<strong>发</strong></h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p>image.png</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a><strong>缓存和数据库双写一致性问题</strong></h4><p>一致性的问题很常见，因为加入了缓存之后，请求是先从 redis中查询，如果 redis 中存在数据就不会走数据库了，如果不能保证缓存跟数据库的一致性就会导致请求获取到的数据不是最新的数据。</p><p>解决方案：</p><p>1、编写删除缓存的接口，在更新数据库的同时，调用删除缓存</p><p>的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。</p><p>2、消息队列：ActiveMQ，消息通知。</p><h4 id="缓存的并发竞争问题"><a href="#缓存的并发竞争问题" class="headerlink" title="缓存的并发竞争问题"></a><strong>缓存的并发竞争问题</strong></h4><p>并发竞争，指的是同时有多个子系统去 set 同一个 key 值。</p><p>解决方案：</p><p>1、最简单的方式就是准备一个分布式锁，大家去抢锁，抢到</p><p>锁就做 set 操作即可</p><h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a><strong><strong><strong>缓存</strong></strong>雪崩问题</strong></h4><p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波</p><p>请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p>解决方案：</p><p>1、给缓存的失效时间，加上一个随机值，避免集体失效。</p><p>2、使用互斥锁，但是该方案吞吐量明显下降了。</p><p>3、搭建 redis 集群。</p><h4 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a><strong><strong><strong>缓存</strong></strong>击穿问题</strong></h4><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p>解决方案：</p><p>1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，</p><p>再去请求数据库。没得到锁，则休眠一段时间重试</p><p>2、采用异步更新策略，无论 key 是否取到值，都直接返回，</p><p>value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程</p><p>去读数据库，更新缓存。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
