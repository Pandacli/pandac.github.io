<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目产品分析</title>
      <link href="/2022/09/10/%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B9%A6/"/>
      <url>/2022/09/10/%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li><p>需求业务分析</p></li><li><p>概要设计分析</p></li><li><p>代码详细设计分析</p></li></ul><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="项目背景和介绍"><a href="#项目背景和介绍" class="headerlink" title="项目背景和介绍"></a>项目背景和介绍</h3><p>随着时代的发展，越来越多的国内企业开始采用CRM客户关系管理系统，近年来CRM不仅受到大型企业的青睐，也是中小企业快速成长的催化剂。市场、客户信息、产品、业务人员、渠道等各类信息流的不断增长，传统方式对于管理全渠道信息流成本越来越高，所以需要一个软件产品来解决这些问题。</p><p>互联网+的出现，改变了很多行业同样很多行业的理念也在转变，伴随着电子商务、智能手机的不断应用，使企业更加简单的接触消费者，直接与消费者互动收集消费者反馈成为可能。那原本以产品以企业为核心的理念逐渐在转变，转变以“客户为中心”，及时服务客户，提高客户满意程度，从而提高企业营收。依托强大的信息技术，企业可以借助CRM系统不断把客户跟进，服务，成交，售后打通，而且不断依托CRM工具来优化这个流程，来适应整个市场的不断变化。</p><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><h3 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h3><p>操作系统：Web平台<br>数据库系统：Mysql<br>运行环境：JRE<br>开发语言：JAVA<br>开发代码模式：多模块Maven模式<br>架构模式：MVC 三层架构模式</p><h3 id="用户角色"><a href="#用户角色" class="headerlink" title="用户角色"></a>用户角色</h3><p>常用的后台系统角色有：<br>运营人员：根据客户业务数据，统计当前系统及业务痛点，提出需求进行更新优化。<br>财务专员：负责系统财务结算审批或财务开销<br>销售专员：负责梳理客户资料，优化销售流程。借助软件提高销售成功率<br>销售主管：梳理工作内容，调整销售方案，提高销售业绩<br>客户管理人员：使用后台服务<br>市场专员：根据前端意向用户，跟进线索转换为意向客户<br>管理员：负责系统日常的运行和维护。</p><h3 id="系统架构图-和业务架构图"><a href="#系统架构图-和业务架构图" class="headerlink" title="系统架构图 和业务架构图"></a>系统架构图 和业务架构图</h3><h2 id="概要设计分析"><a href="#概要设计分析" class="headerlink" title="概要设计分析"></a>概要设计分析</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>服务器系统:Linux Centos7<br>客户端:Internet,Chorme<br>应用服务器:Tomcat<br>数据库:Mysql</p><p>开发工具:</p><table><thead><tr><th>工具</th><th>版本号</th></tr></thead><tbody><tr><td>IDEA</td><td>开发IDE</td></tr><tr><td>MobaXterm</td><td>Linux远程连接工具</td></tr><tr><td>Navicat</td><td>数据库连接工具</td></tr><tr><td>Another Redis Desktop Manager</td><td>Redis 客户端</td></tr><tr><td>PostMan</td><td>接口调试工具</td></tr><tr><td>代码管理</td><td>Git and Gitee</td></tr><tr><td>CHINER元数建模</td><td>数据库设计工具</td></tr><tr><td>Xminder</td><td>思维导图工具</td></tr></tbody></table><p>开发环境:</p><table><thead><tr><th>工具</th><th>版本号</th></tr></thead><tbody><tr><td>JDK</td><td>1.8</td></tr><tr><td>Mysql</td><td>5.7.24</td></tr><tr><td>Redis</td><td></td></tr><tr><td>SpringBoot</td><td>2.2.13.RELEASE</td></tr><tr><td>其他依赖包版本</td><td>参考项目parent模块</td></tr></tbody></table><h3 id="主要模块介绍"><a href="#主要模块介绍" class="headerlink" title="主要模块介绍"></a>主要模块介绍</h3><ul><li>首页功能(常用于数据展示)</li><li>活动管理</li><li>统计分析</li><li>系统管理</li><li>CRM管理</li></ul><h3 id="数据结构表设计与分析"><a href="#数据结构表设计与分析" class="headerlink" title="数据结构表设计与分析"></a>数据结构表设计与分析</h3><h2 id="代码详细设计分析"><a href="#代码详细设计分析" class="headerlink" title="代码详细设计分析"></a>代码详细设计分析</h2><p>由于本项目是由<strong>Maven多模块</strong>实现现,简单介绍下项目各模块技术:</p><h3 id="源码模块分析"><a href="#源码模块分析" class="headerlink" title="源码模块分析"></a>源码模块分析</h3><p>parent基本模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>容器+MVC框架</td></tr><tr><td>Druid</td><td>阿里云数据库连接池</td></tr><tr><td>eu.bitwalker</td><td>解析客户端操作系统、浏览器等</td></tr><tr><td>pageHelper</td><td>分页插件</td></tr><tr><td>oshi</td><td>获取系统信息</td></tr><tr><td>jna</td><td>Java工具类用于在运行期间动态访问系统本地库</td></tr><tr><td>commons-io</td><td>io常用工具类</td></tr><tr><td>commons-fileupload</td><td>文件上传工具类</td></tr><tr><td>commons-colletions</td><td>collectons工具类</td></tr><tr><td>poi</td><td>常用excel工具</td></tr><tr><td>velocity</td><td>velocity代码生成模板器</td></tr><tr><td>fastjson</td><td>阿里Json解析器</td></tr><tr><td>kaptcha</td><td>验证码</td></tr><tr><td>lombok</td><td>lombok管理</td></tr><tr><td>minio</td><td>io工具类</td></tr><tr><td>okHttp</td><td>Http工具类</td></tr></tbody></table><p>framework核心框架技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot-Web</td><td>Web容器</td></tr><tr><td>SpringBoot-AOP</td><td>AOP拦截器</td></tr></tbody></table><p>admin模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>mysql-connector-java</td><td>mysql驱动包</td></tr><tr><td>mybatis</td><td>mybatis ORM框架</td></tr></tbody></table><p>bussiness模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>showfun公共模块</td></tr><tr><td>showfun-system</td><td>showfun项目系统模块</td></tr><tr><td>showfun-clues</td><td>项目clues模块</td></tr></tbody></table><p>clues模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>showfun公共模块</td></tr><tr><td>showfun-system</td><td>showfun项目系统模块</td></tr></tbody></table><p>common模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>Spring-context-support</td><td>Spring上下文核心工具</td></tr><tr><td>Spring-web</td><td>SpringWeb模块</td></tr><tr><td>Spring-security</td><td>Spring安全认证模块</td></tr><tr><td>PageHelper</td><td>分页插件</td></tr><tr><td>Validation-api</td><td>自定义验证注解</td></tr><tr><td>commons-lang</td><td>常用工具类</td></tr><tr><td>jackson-databind</td><td>Jackson工具类</td></tr><tr><td>snakeyaml</td><td>YAML解析器</td></tr><tr><td>jjwt</td><td>Token生成与解析器</td></tr><tr><td>redis</td><td>redis 缓存</td></tr><tr><td>EasyExcel</td><td>easyExcel 工具类</td></tr></tbody></table><p>contract合同模块技术:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>mysql-connector-java</td><td>mysql驱动工具类</td></tr><tr><td>showfun-common</td><td>项目公共模块</td></tr><tr><td>showfun-bussiness</td><td>项目业务模块</td></tr></tbody></table><p>report模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-contract</td><td>项目合同模块</td></tr></tbody></table><p>task模块:</p><table><thead><tr><th>技术</th><th>说明</th></tr></thead><tbody><tr><td>showfun-common</td><td>项目公共模块</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程技术</title>
      <link href="/2022/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程编程-上"><a href="#多线程编程-上" class="headerlink" title="多线程编程(上)"></a>多线程编程(上)</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>进程和线程的基本概念</li><li>多线程并发出现问题的根源</li><li>Java如何解决并发问题</li><li>线程安全的实现方式</li></ul><h3 id="多线程的一些名词"><a href="#多线程的一些名词" class="headerlink" title="多线程的一些名词"></a>多线程的一些名词</h3><ul><li>四核八处理器：指的是拥有四个CPU ，可以同时处理8个进程，且CPU之间可以切换运行不同的进程。</li><li>进程: 进程指的是运行中的应用程序,通常操作系统会分配 CPU, 内存, 磁盘,网络资源给该进程使用。</li><li>线程：指一个进程（应用程序）内的线性程序功能，一般的软件都是支持多线程的，指<strong>同一时刻内</strong>可以同时执行多个线程任务，提供不同的功能。</li><li>并发：指的是单个CPU <strong>同一个时刻</strong> 可以切换多个线程任务交替执行,我们的大脑就是简单的单个CPU处理多种复杂事情的并发。但由于并发是不断切换执行任务，容易出现“问题”，要谨慎处理。</li><li>并行：指的是 多个CPU 在<strong>同一时刻同时执行任务</strong>  。类似于马拉松选手在同一时刻同时出发的场景。</li></ul><p>多线程的好处和坏处<br>好处：由于CPU，内存，IO读写设备的速度是有极大的差异的，为了合理利用CPU的高性能和平衡三者的差异，<br>经常做一些优化的设计：</p><ol><li>CPU 增强了缓存，均衡了与内存的速度差异 </li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异</li><li>编译程序优化代码指令执行次序，使得缓存能够得到更加合理地利用</li></ol><p>缺点:</p><ol><li>CPU 增加缓存机制, 导致了可见性问题。</li><li>操作系统的操作 导致了原子性问题。</li><li>编译程序的操作 导致了有序性问题。</li></ol><h4 id="拓展-可见性问题-原子性问题-有效性问题"><a href="#拓展-可见性问题-原子性问题-有效性问题" class="headerlink" title="拓展: 可见性问题, 原子性问题,有效性问题"></a>拓展: 可见性问题, 原子性问题,有效性问题</h4><p>可见性问题：常出现在读写过程中。 指的是一个对象A(对象包括数据库事务，CPU…等等)在写入数据过程中，但未提交完成前,或数据被临时存储(譬如缓存),另一对象B读取（查询）还是原数据的值，无法正确获取修改后的值。这就是可见性问题，不同计算机组件有不同的解决方案：(待写)</p><p>原子性问题:</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus技術详解</title>
      <link href="/2022/09/08/MybatisPlus/"/>
      <url>/2022/09/08/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>MybatisPlus的简介和技术介绍</li><li>能够基于MybatisPlus完成标准Dao开发,CURD操作</li><li>能够掌握MybatisPlus的条件查询</li><li>能够掌握MybatisPlus的字段映射和 表名映射</li><li>能够配置”代码生成器”的相关配置</li></ul><h3 id="MybatisPlus-的简介和源码解析"><a href="#MybatisPlus-的简介和源码解析" class="headerlink" title="MybatisPlus 的简介和源码解析"></a>MybatisPlus 的简介和源码解析</h3><h4 id="Mybatis-是什么"><a href="#Mybatis-是什么" class="headerlink" title="Mybatis 是什么?"></a>Mybatis 是什么?</h4><h3 id="使用MybatisPlus实现Java代码访问数据库"><a href="#使用MybatisPlus实现Java代码访问数据库" class="headerlink" title="使用MybatisPlus实现Java代码访问数据库"></a>使用MybatisPlus实现Java代码访问数据库</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li><p>添加mp起步依赖 mybatis-plus-boot-starter , mybatis-plus-boot-starter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>设置springboot *.yml 配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">  #将SQL语句操作的日志打印到Console</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mappers/*.xml</span><br></pre></td></tr></table></figure></li><li><p>编写Mapper 接口 并继承 BaseMapper&lt;要映射实体的类名&gt;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍 BaseMaaper 接口:该类封装了一个Mapper对象中执行DML DQL 的方法<br>[CURD] 基本操作方法</p></li></ol><ul><li>int insert(T entity) 插入一个 实体类对象</li><li>int deteleById(T entity) 删除一个 实体类对象</li><li>int deteleBatchIds(Collection&lt;? extends Serializable&gt; idList) 根据ids 集合批量删除多条记录:</li><li>int updateById(T entity) 根据id更新记录</li><li>T selectById(Serializable id) 根据主键ID 查询单个对象</li><li>List<T> selectBatchIds(Collection&lt;? extends Serializable&gt; idList) 根据ids 集合查询多个实体对象。</li><li>List<T> selectList(@Param(Constants.WRAPPER) Wrapper<T> queryWrapper); 根据Entity条件,查询全部记录。</li></ul><p>[Wrapper] 包装接口,包装各种大部分生成 where 条件的方法</p><ul><li>QueryWrapper  DQL条件查询接口</li><li>UpdateWrapper DML条件更新接口</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-BeanFactory详解</title>
      <link href="/2022/09/07/Spring-BeanFacotry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/07/Spring-BeanFacotry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IOC-容器-和-Beans"><a href="#Spring-IOC-容器-和-Beans" class="headerlink" title="Spring IOC 容器 和 Beans"></a>Spring IOC 容器 和 Beans</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>Spring是什么</li><li>Spring IOC &#x2F; DI</li><li>Spring-beans 模块</li><li>Spring AOP</li><li>BeanFacotry是自动创建一个Bean对象的流程</li></ul><h3 id="Spring-是什么"><a href="#Spring-是什么" class="headerlink" title="Spring 是什么"></a>Spring 是什么</h3><p>Spring 是一个减轻传统 JAVAEE应用 EJB 管理,和复杂配置的轻量级框架, 其底层模块有 core ,content , beans , AOP ,SpEL表达式 ,Spring-JDBC, ORM模块。<br>也是一个生态，基于Spring Framework 已经衍生出各种 Spring 优秀框架 ，譬如Spring MVC， Spring Boot ，Spring JPA ， Spring Cloud， Spring Cloud Alibaba 。<br>Spring Framework 包含了两个核心理念，Spring - IOC 和Spring AOP 理念。</p><h3 id="Spring-IOC-理念"><a href="#Spring-IOC-理念" class="headerlink" title="Spring IOC 理念"></a>Spring IOC 理念</h3><p>Inversion of Control 控制反转原理，也叫做DI ，在DI过程中，支持构造器注入，setter方法注入和返回值。 Spring的Bean容器具有Ioc 的能力，Spring提供了两种配置方式 可以注入到 BeanFactory 容器中，从而创建 Bean 对象和初始化对象属性。</p><h4 id="配置一：通过外部XML-文件定义BD信息。"><a href="#配置一：通过外部XML-文件定义BD信息。" class="headerlink" title="配置一：通过外部XML 文件定义BD信息。"></a>配置一：通过外部XML 文件定义BD信息。</h4><p>通过外部XML文件生成BeanDefinition 信息的基本流程是:<br>XML文件 ——  IO流  ——  dom4j (DocmentForJava) —— 获取Docment 对象 —— 获取父子节点Node —— 通过Node 节点 得到各节点的属性 —— 封装到RootBeanDefination&#x2F;ChildDefinition</p><h4 id="配置二：通过注解-Annoation-定义BD信息。"><a href="#配置二：通过注解-Annoation-定义BD信息。" class="headerlink" title="配置二：通过注解@Annoation 定义BD信息。"></a>配置二：通过注解@Annoation 定义BD信息。</h4><p>注解类 生成BeanDefinition 的基本流程是<br>@Annotaion类 - 获取该注释类Class对象 - AnnotationBeanDefinition </p><h3 id="Spring-beans-模块解析"><a href="#Spring-beans-模块解析" class="headerlink" title="Spring-beans 模块解析"></a>Spring-beans 模块解析</h3><h4 id="BeanDefinitionReader-和-BeanDefinition-接口"><a href="#BeanDefinitionReader-和-BeanDefinition-接口" class="headerlink" title="BeanDefinitionReader 和 BeanDefinition 接口"></a>BeanDefinitionReader 和 BeanDefinition 接口</h4><p><strong>BeanDefinitionReader</strong> 本接口不用实现, 仅仅为了规范和约束 BeanDefinition的标准命名格式。</p><blockquote><p>Simple interface for bean definition readers. Specifies load methods with Resource and String location parameters.<br>Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format.<br>Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions</p></blockquote><p><strong>BeanDefinition</strong></p><blockquote><p>官方注释： A BeanDefinition describes a bean instance, which has property values, constructor argument values, and further information supplied by concrete implementations.<br>This is just a minimal interface: The main intention is to allow a BeanFactoryPostProcessor to introspect and modify property values and other bean metadata </p></blockquote><p>一个BeanDefinition 对应一个Bean实例 ,包含<strong>Bean属性值, 构造器 和 bean之间的关系</strong> ,这个接口的主要目的就是</p><ol><li>接收符合BeanDefinition的配置信息。</li><li>允许 BeanFactoryPostProcessor 去修改属性值和bean的数据模型。</li></ol><h4 id="BeanPostProcessor-Bean后置处理器"><a href="#BeanPostProcessor-Bean后置处理器" class="headerlink" title="BeanPostProcessor Bean后置处理器"></a>BeanPostProcessor Bean后置处理器</h4><p>由于 BeanDefinition 只负责将Bean的配置存储,并不负责数据的转换。譬如jdbc.properties 的jdbc.username 存入的XML文件时 是${jdbc.username},在BD 时依然还是jdbc.username,Spring 使用 Wrapper模式,执行PostProcess后置处理器可以将${jdbc.username}替换成 root </p><h4 id="BeanFactory-接口"><a href="#BeanFactory-接口" class="headerlink" title="BeanFactory 接口"></a>BeanFactory 接口</h4><h4 id="BeanFactoryPostProcess-Bean工厂后置处理器"><a href="#BeanFactoryPostProcess-Bean工厂后置处理器" class="headerlink" title="BeanFactoryPostProcess Bean工厂后置处理器"></a>BeanFactoryPostProcess Bean工厂后置处理器</h4><p>对BeanFacotry 进行增强处理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 技术详解</title>
      <link href="/2022/09/06/Redis%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/09/06/Redis%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis中间件技术"><a href="#Redis中间件技术" class="headerlink" title="Redis中间件技术"></a>Redis中间件技术</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>了解Redis技术的背景和功能</li><li>Redis 的原理机制 和优缺点</li><li>Redis环境搭建。</li><li>Java Redis API 的初级应用</li><li>Spring-cache + Redis 的应用</li><li>项目调试中常出现的问题</li></ul><h2 id="了解Redis技术的背景和作用"><a href="#了解Redis技术的背景和作用" class="headerlink" title="了解Redis技术的背景和作用"></a>了解Redis技术的背景和作用</h2><p>Redis 是一位 Salvatore Sanfilippo 意大利程序员写的， 是一个 <strong>key-vlaue</strong> 存储系统的 非关系型数据库。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言（<strong>包括JAVA</strong>）的 API。</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets) 、sorted set（有序set）</p><p>作用：</p><p>为了解决用户 过度请求频繁访问数据亏库，导致数据库访问压力大，系统性能下降，用户体验差等问题的一种缓存型中间技术。</p><p>！！！！人人都说官网就是最好的教程。必须学会看</p><p>如下是翻译，如果有不对。可以自己去官网看<a href="https://redis.io/docs/about/">Redis官网</a></p><p>其主要功能：</p><ol><li><p>提供<strong>5种数据结构</strong>（字符串(String)、哈希(Hash)、列表(list)、集合(sets) 、sorted set（有序set）支持范围查询 ，bitmaps，基数估计算法，地址空间索引 和 流式化的操作</p></li><li><p>Redis 已内置主从复制，Lua脚本，LRU 回收，事务、在磁盘上不同级别的持久性、通过Redis Sentinel和Redis Cluster自动分区提供高可用性</p></li><li><p>为了达到最好的性能，Redis使用一个内存的数据集，两种方式实现缓存。</p><p> ）您的数据Redis可以通过定期将数据集转储到磁盘（Redis DB），将redis存储的数据生成快照存储到磁盘上。</p><p> ）将每个命令附加到基于磁盘的日志来持久化数据（Append Only File）先记录日志，下次启动再加载此类文件。</p><p> 两个可以一起使用，但如果您只需要一个功能丰富的、联网的、内存中的缓存，您也可以禁用持久性（ARF）。</p></li></ol><blockquote><p>To achieve top performance, Redis works with an  <strong>in-memory dataset</strong> . Depending on your use case, Redis can persist your data either by periodically <a href="https://redis.io/topics/persistence#snapshotting">dumping the dataset to disk</a> or by <a href="https://redis.io/topics/persistence#append-only-file">appending each command to a disk-based log</a>. You can also disable persistence if you just need a feature-rich, networked, in-memory cache.</p><p>Redis supports <a href="https://redis.io/topics/replication">asynchronous replication</a>, with fast non-blocking synchronization and auto-reconnection with partial resynchronization on net split.</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p>image.png​</p><h4 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并<strong>发</strong></h4><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p>image.png</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="缓存和数据库双写一致性问题"><a href="#缓存和数据库双写一致性问题" class="headerlink" title="缓存和数据库双写一致性问题"></a><strong>缓存和数据库双写一致性问题</strong></h4><p>一致性的问题很常见，因为加入了缓存之后，请求是先从 redis中查询，如果 redis 中存在数据就不会走数据库了，如果不能保证缓存跟数据库的一致性就会导致请求获取到的数据不是最新的数据。</p><p>解决方案：</p><p>1、编写删除缓存的接口，在更新数据库的同时，调用删除缓存</p><p>的接口删除缓存中的数据。这么做会有耦合高以及调用接口失败的情况。</p><p>2、消息队列：ActiveMQ，消息通知。</p><h4 id="缓存的并发竞争问题"><a href="#缓存的并发竞争问题" class="headerlink" title="缓存的并发竞争问题"></a><strong>缓存的并发竞争问题</strong></h4><p>并发竞争，指的是同时有多个子系统去 set 同一个 key 值。</p><p>解决方案：</p><p>1、最简单的方式就是准备一个分布式锁，大家去抢锁，抢到</p><p>锁就做 set 操作即可</p><h4 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a><strong><strong><strong>缓存</strong></strong>雪崩问题</strong></h4><p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波</p><p>请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p><p>解决方案：</p><p>1、给缓存的失效时间，加上一个随机值，避免集体失效。</p><p>2、使用互斥锁，但是该方案吞吐量明显下降了。</p><p>3、搭建 redis 集群。</p><h4 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a><strong><strong><strong>缓存</strong></strong>击穿问题</strong></h4><p>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p><p>解决方案：</p><p>1、利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，</p><p>再去请求数据库。没得到锁，则休眠一段时间重试</p><p>2、采用异步更新策略，无论 key 是否取到值，都直接返回，</p><p>value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程</p><p>去读数据库，更新缓存。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
